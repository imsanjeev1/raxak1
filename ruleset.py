import os
import os.path
import subprocess
import re
import sys
import ConfigParser
import string 
import re
import platform
import logging
#import datetime

logging.basicConfig(filename="raxak-logging.log", level=logging.INFO)
# from cloud.cli.argparsers import dest

from commonstub import * # New header file for common stub items to be sent over execnet gateway
from CRrules import *   # CRRules.py is the file with rule definitions for nonstandard rules


# (c) 2014 Cloud Raxak Inc.
#
#  Changelog
#
#  07/25/14  PGM   fixed numerous global calls <x> to <>
#  09/17/14  ASG   Made changes necessary code changes to execute the rule's fix on remote machine
#  09/22/14  ASG   - Rule:38469 - Corrected the code changes made for check and fix function.
#                  - Rule:38475-77-79-80 - Made the necessary code changes to fetch element's value and validate the rule based on element's 
#                    value.
#                  - Issue fixed: If the rule remediated and same element modified more than once then 
#                                 keep the one line per element saying "Cloud Raxak updated next line"
#                  - Rule:38482/38671/38672/38673 - Issues fixed
#                  - Rule:38484 - Made changes inside checkrule function as per observation
#                        Changes: Search the word PrintLastLog and ignore the line that begins with "#"
#                                 if no PrintLastLog configured then by default it displays the last logon user's information 
#                                 hence should return as a true in this case.
#                            Fix: Should restart the sshd service to affect the changes after remediation.
#  10/16/14  PGM   Removed RuleDef as a class and flattened the structure. All methods are top level
#  10/28/14  ASG   Sudo changes for execution of the rules at target VM using non-root user
#  12/08/14  ASG   CheckRule and FixRule changes for 38471-38494-38537-38608-38610-38611-38612-38618-38624-38692-38579-38639
#  02/13/15  ASG   Made the code changes to check and fix the security rule based on OS name and OS version. 
#  05/28/15  PGM   Removed sudo from individual runOnShell commands 

#REQUIRES Python 3: only for print statements. This can easily be changed to be compatible with
# backward versions

# temp to allow progress



# Global Variables------------------------------
verbose = True
runlocal = True
consoleChan = None

##Password aging controls
PASS_MAX_DAYS=60
PASS_MIN_DAYS=1
PASS_MIN_LEN=14
PASS_WARN_AGE=7

#Differentiating Fail case and Manual Intervention case
g_rule38481FailAndMnual = False
g_rule38447FailAndMnual = False

OsName = ""
OsVersion = ""
 
# Utility Functions-------------------------------------------------------

#ASG
#Convert the OS version string into tuple for the comparison
def versiontuple(v):
    return tuple(map(int, (v.split("."))))


#ASG
#Retrieve the OS name, OS version and set the values in the global variable for further operations
def SetOsValues():
	global OsName,OsVersion
	try:
		OsName = str(platform.dist()[0])
		OsVersion = versiontuple(str(platform.dist()[1]))
	except:
		OsName = ""
		OsVersion = ""

SetOsValues()


def removeSpaces(string):
	return "".join(string.split())

def appendToFile(filename,appendText,addNewLine=False):#assumes at end of newline character
	with open(filename,"a") as myfile:
		myfile.write(appendText)
		if addNewLine:
			myfile.write("\n")


def writeFile(filename, contents, mode="wt"):
	# wt stands for "write text"
	fout = None
	try:
		fout = open(filename, mode)
		fout.write(contents)
	finally:
		if (fout != None): fout.close()

	return True

    
def substituteLines(lineBeginWith,replaceLine,filename):
	textNoSpaces=removeSpaces(lineBeginWith)
	subLineCount=0
	newContents=""
	replaceLine=replaceLine+"\n"
	with open(filename, "r") as f:
		for line in f:
			lineNoSpaces=removeSpaces(line)
			if line[0:len(textNoSpaces)]==textNoSpaces:
				subLineCount+=1
				newContents+=replaceLine
			#check that I append it as a new line
			else:
				newContents+=line
	writeFile(filename,newContents)
	if (subLineCount==0):
		appendToFile(filename,replaceLine)
	return subLineCount

    
def removeUnwantedLines(filename,unwanted):
	with open(filename, "r") as f:
            newContents=""
	    for line in f:
                if unwanted not in line:
                    #check that I append it as a new line
                    newContents+=line
        writeFile(filename,newContents)
    
    
def lineInFile(filename,line):
	contents=readFile(filename)
	contentsNoSpaces=removeSpaces(contents)
	return removeSpaces(line) in contents


def readFile(filename, mode="rt"):
	# rt stands for "read text"
	fin = contents = None
	try:
		fin = open(filename, mode)
		contents = fin.read()
	finally:
		if (fin != None): fin.close()
	return contents


def logging (line):
	print(line)
	return

# PGM 10-16-2014 Removed class RuleDef, pulled all methods to top level
    #Python 2.7
    #def runOnShell(commands):
    #    return subprocess.check_output(''.join(commands), shell=True)
    #Python 2.6


def runOnShell(command):
	try:
# PGM: Note--
# subprocess.Popen cannot handle pipes since pipes are a shell construct
# many of the calls to runOnShell were actually piped commands that broke.
# solution is to either fork a shell to handle the pipes (as below), or to 
# programatically separate the individual command lines and build your own pipe in 
# runOnShell as in stackoverflow.com/questions/14568663/invoking-pipe-...
# Having shell=True is a security vulnerability but is OK in our context since the
# command being executed is programattically bounded.

		ret = subprocess.Popen(command, shell=True, stdin=PIPE, stdout=subprocess.PIPE).communicate()[0]
	except:
		ret = "Not found"

	logging("# " + command)
	for line in ret.splitlines():
		logging("> " + line)
		
	return ret


def atoi (s):
	p = re.compile(r'[^\d-]*(-?[\d]+(\.[\d]*)?([eE][+-]?[\d]+)?)')
	m = p.match(s)
	if m:
		result = m.groups()[0]
		if "." in result or "e" in result or "E" in result:
			return int("{1}".format(s, float(result)))
		else:
			return int('{1}'.format(s, int(result)))
	else:
		print "unable to convert '" + s + "'"
		return "error"


def tokenMatch (src, dest):
	# PGM: there were several errors. the split function used was src.split(" ") which 
	# does not split on tabs. the return was all (x in .. which only works if all tokens are found)
	sL = filter(lambda a: a != "", src.split())
	dL = dest.split()
	return any (x in dL for x in sL)


def serviceInstalled (service):
	if service == "":
		return False
	else:
		return "No such file" not in service


def isL(line):
	return line == "" or not(line[0] == "#")


def checkContainsValue (id, val, str):
	n = str.find(id)
	if n >= 0:
		return atoi(str[n + len(id):]) == val
	else:
		return False


def strcmp ( a, b):
	return a.lower().lstrip(" ").rstrip(" ") == b.lower().lstrip(" ").rstrip(" ")


def keyValEqMatch (key, val, res):
	key = key.lower()
	val = val.lower()
	res = res.lower()
	n = res.find(key)
	if n >= 0:
		eq = res[n + len(key):].find('=')
		if eq >= 0:
			return filter(lambda x: not(x == ""),
	                      res[n + len(key):][eq + 1:].split(" "))[0] == val
	return False

        
def returnExpected(command,expectedOutput):
	output=runOnShell(command)
	#strip the white spaces from both the expected output, and output
	output=removeSpaces(output)
	expectedOutput=removeSpaces(expectedOutput)
	#compare the two
	return (expectedOutput in output) or (output in expectedOutput)

        
def hasFile(directory,filepath):
        return runOnShell("find "+directory+" -path "+"*"+filepath)
        
#---------------------------------- CHECK RULES AND FIX RULES -----------------------


def checkRule38437():
	if not CheckPackage("autofs"):
		return True
	checkAutomount = False
	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		service_status = runOnShell('systemctl is-active autofs.service').replace('\n','')
		if service_status in ["inactive", "unknown","failed"]:
			return True
		service_at_runlevel = runOnShell("systemctl is-enabled autofs.service").replace('\n','')
		if service_status == "active" or service_at_runlevel == "enabled":
			if "no master map entries found" not in runOnShell("automount -m"):
				logging("Autofs (Automated file system mounting) service is already in use, hence need manual intervention to fix this.")
				return None
			logging("Autofs (Automated file system mounting) service is running.")
			return False
	else:
		if OsName.lower() == "ubuntu":
			service_at_level = 'sysv-rc-conf --list autofs'
			token_match = "stop/waiting"
		else:
			service_at_level = 'chkconfig --list autofs'
			token_match = "stopped"

		#As init.d command is working same as service command in case of red hat
		#hence not using this in case of redhat.	
		if not OsName.lower() == 'redhat':
			logging("Checking the status of autofs service.")
			service_status_automount = runOnShell('/etc/init.d/autofs status')
			service_status_automount = service_status_automount.translate(string.maketrans("\n\t\r", "   "))
			if "automountisrunning" in service_status_automount.replace(" ",''):
				return False

		service_status = runOnShell('service autofs status')
		service_status = service_status.translate(string.maketrans("\n\t\r", "   "))
		if not tokenMatchIC(token_match, service_status): #if service is runnning...
			checkAutomount = True

		logging("Checking the status of autofs service at all runlevel")
		service_at_level = runOnShell(service_at_level).translate(string.maketrans("\n\t\r", "   "))
		if OsName.lower() == "ubuntu":
			service_at_level_repl = service_at_level.replace(" ",'')
			if not checkAutomount and len(service_at_level_repl) == len("autofs") and tokenMatchIC("autofs",service_at_level):
				logging("Autofs (Automated file system mounting) service is off at all runlevel.")
				return True
			if "on" in service_at_level_repl:
				logging("Autofs (Automated file system mounting) service is on at runlevel.")
				checkAutomount = True
		else:
			if not(tokenMatchIC("autofs 0:off 1:off 2:off 3:off 4:off 5:off 6:off", service_at_level)):
				checkAutomount = True

		if checkAutomount:
			logging("Checking the configuration of autofs service.")
			service_configured_msg = runOnShell("automount -m 2>/dev/null")
			if "no master map entries found" not in service_configured_msg:
				logging("Autofs (Automated file system mounting) service is already in use, hence need manual intervention to fix this.")
				return None

			return False

	return True


def fixRule38437():
	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		runOnShell("systemctl disable autofs.service;systemctl stop autofs.service")
	else:
		if OsName.lower() == "ubuntu":
			service_manager_name = "sysv-rc-conf"
			logging("Disabling the autofs service at all runlevel")
			runOnShell('sysv-rc-conf  --level 0123456S autofs off') 
			service_status = runOnShell('service autofs status')
			service_status = service_status.translate(string.maketrans("\n\t\r", "   "))
			if not tokenMatchIC("stop/waiting", service_status):
				logging("Disabling the autofs service at runtime level.")
				runOnShell('service autofs stop')
			automount_out = runOnShell('/etc/init.d/autofs status')
			if "automountisrunning" in automount_out.replace(" ",''):
				automount_out = runOnShell('/etc/init.d/autofs stop')
		else:
			runOnShell('chkconfig --level 0123456 autofs off; service autofs stop')


def checkRule38438():
	if not CheckService("auditd"):
		return False

	if (OsName.lower() == "ubuntu"):
	    if not os.path.exists ("/boot/grub/grub.cfg"):
		logging ("The grub file is not existed, Hence fix it manually.")
		return None
	    logging("Checking the grub file permissions.")
	    if int (runOnShell ('stat -c "%a" /boot/grub/grub.cfg')) == 600:
	        logging ("Checking and updating grub file.")
		grubCheckRes = runOnShell ("update-grub")
	        logging("The system boot loader configuration file(s) must have mode 0600 or less permissive, But after running the \"update-grub\" command the boot loader configuration file permissions was changing to 0444 ,So reverting the permissions to 0600.")
		runOnShell('chmod 600 /boot/grub/grub.cfg')
	    else:
		grubCheckRes = runOnShell ("update-grub")

	    if ("Syntax error" in grubCheckRes)  or ("not found" in grubCheckRes):
		logging ("Since there is a syntax error in the grub file, need manual intervention to fix the grub syntax error.")
		return None

	if (((OsName.lower() == "redhat") or (OsName.lower() == "centos")) and OsVersion >= (7,0)) or OsName.lower() == "ubuntu":
	    filePath =  '/etc/default/grub'
	    if not os.path.exists (filePath):
		logging ("The grub file does not exist, hence fix it manually.")
		return None
	    fileLines = open(filePath, 'r').readlines()
	else:
	    filePath = '/etc/grub.conf'
	    if not os.path.exists (filePath):
		logging ("The grub file does not exist, hence fix it manually.")
		return None

	    logging("Checking if auditing is enabled at boot time.")
	    fileLines = open(filePath, 'r').readlines()
	    if len (filter(lambda ele: re.search('^\s*kernel\s*', ele, re.M|re.L), fileLines)) == 0:
		logging("The kernel line does not exist in grubfile, hence fix it manually.")
		return None
	matchFlag = False
	for line in fileLines:
	    line = line.strip()
	    if isL(line) and (re.search("GRUB_CMDLINE_LINUX", line) and not("GRUB_CMDLINE_LINUX_" in line)) or line.startswith('kernel'):
		line = line.translate(string.maketrans("\n\t\r", "   "))
		if re.match(r'.*\s*(\baudit=1\b)\s*', line):
		    matchFlag = True

	if matchFlag:
		logging("Auditing is enabled at boot time.")
		return True
	else:
		logging("Auditing is not enabled at boot time.")
		return False

def fixRule38438():
        if not InstallPackage("audit"):
            return None

	if (((OsName.lower() == "redhat") or (OsName.lower() == "centos")) and OsVersion >= (7,0)) or OsName.lower() == "ubuntu":
	    filePath =  '/etc/default/grub'
	else:
	    filePath = '/etc/grub.conf'

	concat_data = ""
	lastLine = ""
	with open(filePath, "r") as filehandler:
	    #The matchFlag is useful when given pattern should be 
	    #available in a file atleast for 1 time
	    matchFlag = False
            for line in filehandler:
		#The below one will be executed in case of Version < 7.0
		if (line.strip().startswith('kernel')):
			if ("audit" not in line):
			    lineList = line.strip().split(' ')
			    lineList.append("audit=1")
			    if "Cloud Raxak" not in lastLine:
			        concat_data = concat_data + "# Cloud Raxak updated next line\n"
			    concat_data = concat_data + ' ' * 8 + " ".join(lineList) + "\n"
			else: # Else, try to replace last element by the "audit=1" in the list
			    lineList = line.strip().split(' ')
			    for auditIndx in range(0, len(lineList)):
				if "audit" in lineList[auditIndx]:
				    lineList[auditIndx] = "audit=1"
			    if "Cloud Raxak" not in lastLine:
			        concat_data = concat_data + "# Cloud Raxak updated next line\n"
			    logging("Updating the kernel argument for every process during boot audit.")
			    concat_data = concat_data + ' ' * 8 + " ".join(lineList) + "\n"
		#The below one will be executed in case of Version >= 7.0
		elif isL(line) and re.search("GRUB_CMDLINE_LINUX", line) and not("GRUB_CMDLINE_LINUX_" in line):
			matchFlag = True
			#Since our basic functionality which does not match with audit=1, then try to fix the issue
			line = re.sub(' +', ' ', line)
			splitLine = line.split('\"')
			if len(splitLine) == 1:
			    equalSplitLine = line.split('=')
			    if ("Cloud Raxak" not in lastLine):
			        concat_data = concat_data + "# Cloud Raxak updated next line\n"
			    concat_data = concat_data + equalSplitLine[0] + '="audit=1"' + '\n'
			    continue
			splitLine[1] = re.sub(' +', ' ', splitLine[1])
			subSplitLine = splitLine[1].split(" ")
			#Removing all empty indexes in the list
			for indx in range(0, len(subSplitLine) - 1):
			    if (subSplitLine[indx] == ''):
				subSplitLine.remove(subSplitLine[indx])

			if (len(subSplitLine) == 1):
			    if subSplitLine == "" or "audit" in line:
				logging("Updating the kernel argument for every process during boot audit.")
				if ("Cloud Raxak" not in lastLine):
				    concat_data = concat_data + "# Cloud Raxak updated next line\n"
				concat_data = concat_data + splitLine[0] + "\"audit=1\"" + "\n"
			    else:
				logging("Updating the kernel argument for every process during boot audit.")
				if ("Cloud Raxak" not in lastLine):
				    concat_data = concat_data + "# Cloud Raxak updated next line\n"
				concat_data = concat_data + splitLine[0]+ "\"" + subSplitLine[0] + " audit=1\"" + "\n"
			else:
			    auditFlag = False #To check whether audit value is available or not
			    for idx in range (0, len(subSplitLine)):
				if "audit" in subSplitLine[idx]:
				    auditFlag = True
				    subSplitLine[idx] = "audit=1"
			    if auditFlag == False:
				tmpStr = " ".join(subSplitLine) + " audit=1" + "\"" + "\n"
			    else:
				tmpStr = " ".join(subSplitLine) + "\"" + "\n"
			    #replacing multiple spaces by a single space
			    tmpStr = re.sub(' +', ' ', tmpStr)
			    logging("Updating the kernel argument for every process during boot audit.")
			    if ("Cloud Raxak" not in lastLine):
			        concat_data = concat_data + "# Cloud Raxak updated next line\n"
			    concat_data = concat_data + splitLine[0] + "\"" + tmpStr
		#The below line will be executed, if line neither matches "kernel" nor "GRUB_CMDLINE_LINUX"
	        else:
			lastLine = line
			#Concatenating every line to the string variable which does not match with "kernel" or "GRUB_CMDLINE_LINUX"
			concat_data = concat_data + line	

	if OsName.lower() == "ubuntu" and matchFlag == False:
		logging("Adding the kernel argument for every process during boot audit.")
		if ("Cloud raxak" not in line):
		    concat_data = concat_data + "# Cloud Raxak updated next line\n"
		concat_data = concat_data + "GRUB_CMDLINE_LINUX=\"audit=1\""
        fout = None
        try:
            fout = open(filePath, 'wt')
            fout.write(concat_data)
        finally:
            if fout is not None:
                fout.close()

        RunService("auditd")

def checkRule38439():
        logging("Interview the SA to determine if there is an automated system for managing user accounts, preferably integrated\
 with an existing enterprise user management system.")
	return None

def fixRule38439():
        logging("Implement an automated system for managing user accounts that minimizes the risk of errors, either intentional or deliberate.\
If possible, this system should integrate with an existing enterprise user management system, such as, one based Active Directory or Kerberos.")
	return None

def checkRule38443():
	if os.path.exists('/etc/gshadow') == False:
		logging("File : /etc/gshadow does not exist.")	
		return True
	logging("Checking permissions of file '/etc/gshadow/'.")
	own_value = runOnShell('ls -l /etc/gshadow')
	own_value = own_value.split(" ")[2] == "root"
	if own_value:
		logging("File '/etc/gshadow' is owned by root.")
		return True
	else:
		logging("File '/etc/gshadow' is not owned by root.")
		return False

def fixRule38443():
	logging("Changing the ownership of '/etc/gshadow'.")
        runOnShell('chown root /etc/gshadow')


def checkRule38444():
	logging("Checking if IPv6 is enabled.")
	network_file_exist = False
	ipv6_file = False
	ipv6_output = ""
	if os.path.exists('/etc/sysctl.conf'):	
		network_file_exist = True
        	ipv6_output = runOnShell('grep -w net.ipv6.conf.all.disable_ipv6 /etc/sysctl.conf | grep -v "^#"')
        	ipv6_output = ipv6_output.translate(string.maketrans("\n\t\r", "   "))
		if keyValEqMatch_new("net.ipv6.conf.all.disable_ipv6", "1", ipv6_output):
			ipv6_file = True

	#1 is disabled and 0 is enabled
	runtime_ipv6_status = runOnShell("cat /proc/sys/net/ipv6/conf/all/disable_ipv6").translate(string.maketrans("\n\t\r", "   "))
	if atoi(runtime_ipv6_status) == 1: 
	    if not network_file_exist:
	    	logging("IPv6 is disabled in present state, hence rule is not applicable but network configuration file is not present \
which may cause of changing the present state of IPv6 after rebooting.")
	    elif ipv6_output == "":
	    	logging("IPv6 is disabled in present state, hence rule is not applicable but IPv6 parameter setting is missing in network configuration file \
which may cause of changing the present state of ipv6 after rebooting")
	    elif not ipv6_file:
	    	logging("IPv6 is disabled in present state, hence rule is not applicable but the value of IPv6 parameter is set to on \
in network configuration file which may cause of enabling the ipv6 after rebooting.")
	    else:
	    	logging("IPv6 is disabled, hence it is not applicable.")

	    return True

	#Checking Firewall policy.
	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		firewall_status = runOnShell("systemctl is-active firewalld").replace('\n','')
		iptables_status = runOnShell("systemctl is-active ip6tables").replace('\n','')
		if (firewall_status == "active" and iptables_status == "active"):
		    logging("Firewalld and iptables both are running which should not be used at a time.\
Please fix it manually by turning off one of them.In CentOS 7 the default firewall is `firewalld` so it is recommended to use firewalld.")	
		    return None
		elif firewall_status == "active": 
			enabled_token = runOnShell("systemctl is-enabled firewalld").replace('\n','')
			ipv6_rule = runOnShell("firewall-cmd --permanent --direct --get-rules ipv6 filter INPUT")
			if enabled_token == "enabled" and "DROP" in ipv6_rule:
				return True
		elif iptables_status == "active":
			enabled_token = runOnShell("systemctl is-enabled ip6tables").replace('\n','')
			drop_policy = runOnShell("grep -w :INPUT /etc/sysconfig/iptables | grep -v '^#' ")
			if enabled_token == "enabled" and "DROP" in drop_policy:
				return True
        elif OsName.lower() == "ubuntu":
		logging("Checking the status of Firewall")
		ufw_status_res = runOnShell('ufw status verbose').split('\n')[0].split(':')[1]
		if tokenMatch('active', ufw_status_res):
			logging("Checking the service status of Firewall.")
			service_ufw_status_res = runOnShell("service ufw status").split('\n')[0]
			if "start/running" in service_ufw_status_res:
				logging("Checking the status of IPv6 Firewall.")
             			ipv6_status = runOnShell('grep -w IPV6=yes /etc/default/ufw | grep -v "^#"')
				logging("Checking the deny-all policy for inbound packets.")
             			default_policy_value = runOnShell('grep -w DEFAULT_INPUT_POLICY /etc/default/ufw | grep -v "^#"')
             			if (tokenMatch("IPV6=yes", ipv6_status) and tokenMatch('DEFAULT_INPUT_POLICY="DROP"', default_policy_value)):
					logging("IPv6 Firewall is implemented with a deny-all policy for inbounds packets.")
					return True
        else:
    		if CheckService("ip6tables"):
			res_input = runOnShell('grep -w :INPUT /etc/sysconfig/ip6tables | grep -v "^#"')
			res_input = res_input.translate(string.maketrans("\n\t\r", "   "))
			if os.path.exists('/etc/sysconfig/ip6tables'):
				if tokenMatchIC("DROP", res_input):
					logging("IPv6 firewall is enabled and Input policy is set to DROP.")
					return True

	logging("IPv6 firewall is not active/running or default input policy is not set to drop, \
hence it is recommended to fix it manually.")
	return None


def fixRule38444():
	logging("Please fix it manually.")
	return None
        file_data = ""
        if OsName.lower() == "ubuntu":
             file_path = '/etc/default/ufw'
             with open(file_path, "r") as f:
                  flag = False
                  for line in f:
                      if isL(line) and "IPV6=" in line:
                          file_data += "# Cloud Raxak updated next line\n"
                          file_data += "IPV6=yes\n"
                          flag = True
                      else:
                          file_data += line
                  if not(flag):
                      file_data += "IPV6=yes\n"
        else:
             file_path = '/etc/sysconfig/ip6tables'
             with open(file_path, "r") as f:
                  flag = False
                  for line in f:
                      if isL(line) and ":INPUT" in line:
                          file_data += "# Cloud Raxak updated next line\n"
                          file_data += ":INPUT DROP [0:0]\n"
                          flag = True
                      else:
                          file_data += line
                  if not(flag):
                      file_data += ":INPUT DROP [0:0] \n"
        fout = None
        try:
            fout = open(file_path, 'wt')
            fout.write(file_data)
        finally:
            if fout is not None:
                fout.close()
	runOnShell("service ip6tables start")

def checkRule38445():
	if os.path.exists('/etc/audit/auditd.conf'):
		check_auditd_file = runOnShell("sed -ie 's/^[ \t]*//;s/[ \t]*=/ =/;s/=[ \t]*/= /' /etc/audit/auditd.conf")
		audit_log_file = runOnShell('grep "^log_file" /etc/audit/auditd.conf|sed s/^[^\/]*//')
		audit_log_file = audit_log_file.strip("\n")
		if os.path.exists(audit_log_file) == False:
			logging("Audit log file does not exist.")
			return True
		logging("Checking the group owner of the system Audit logs file(s).")
		audit_res = runOnShell('find '+ audit_log_file +'* -type f |sed s/^[^\/]*//|xargs stat -c %G:%n 2>/dev/null')
	        for grp_owner in audit_res.split("\n"):
	            if grp_owner != '':
			grp_owner = grp_owner.split(":")[0]
	                if not(strcmp(grp_owner, "root")):
			    logging("Audit log file(s) is not group-owned by root.")
	                    return False
		logging("Audit log file(s) is group-owned by root.")
	        return True
	else:
		logging("Audit configuration file does not exist.")
		return True

def fixRule38445():
	check_auditd_file = runOnShell("sed -ie 's/^[ \t]*//;s/[ \t]*=/ =/;s/=[ \t]*/= /' /etc/audit/auditd.conf")
	audit_log_file = runOnShell('grep "^log_file" /etc/audit/auditd.conf|sed s/^[^\/]*//')
	audit_log_file = audit_log_file.strip("\n")
	if os.path.exists(audit_log_file):
		audit_res = runOnShell('find '+ audit_log_file +'* -type f |sed s/^[^\/]*//|xargs stat -c %G:%n 2>/dev/null')
		logging("Changing the group owner of the system Audit logs file(s).")
	        for grp_owner_path in audit_res.split("\n")[:-1]:
			grp_owner = grp_owner_path.split(":")[0]
	                if not(strcmp(grp_owner, "root")):
				runOnShell('chgrp root %s' % grp_owner_path.split(":")[1])

def checkRule38446():
        if not os.path.exists('/usr/sbin/postfix'):
            logging("'postfix' service is not installed. Please install it manually.")
            return None
        runOnShell('newaliases')  #This command is to update the database for any new aliases.
        aliases_path = runOnShell('postconf alias_maps')
        filePath = aliases_path.split("=")
        if not filePath[1][:-1]:
            logging("'postfix' is not configured properly. File path is missing for aliase maps.")
            return False
        aliases = runOnShell('postmap -q root %s' % filePath[1][:-1])
        if aliases == "":
            logging("No alias configured for root that forward to a monitored email address.")
            return False
        elif tokenMatch("Error",aliases):
            logging("There is some configuration error in 'postfix' configuration file.")
            return None
        else:
            logging("Alias(es) are configured for root that forward to a monitored email address.")
            return True

def fixRule38446():
    if not os.path.exists('/usr/sbin/postfix'):
        return None
    if os.path.exists("/etc/postfix/main.cf"):
        postfixConfFile = runOnShell('grep -w "^alias_maps" /etc/postfix/main.cf')
        if postfixConfFile == "":
            logging("No configuration found for alias map in 'postfix' configuration file. Configure it manually.")
            return None
    res = runOnShell('postconf alias_maps')
    file_name = res.split("=")
    if not file_name[1][:-1]:
        runOnShell('postconf -e alias_maps=hash:/etc/aliases')
        res = runOnShell('postconf alias_maps')
    res1 = runOnShell('postmap -q root %s' % file_name[1][:-1])
    if res1 == "":
       uid_min = runOnShell('awk \'{ if($1 == "UID_MIN") print $2;}\' /etc/login.defs')
       uid_max = runOnShell('awk \'{ if($1 == "UID_MAX") print $2;}\' /etc/login.defs')
       hostname_remote_str = runOnShell('hostname')
       hostname_remote     = '@'+hostname_remote_str.strip()
       #this will get all user ids except system user ids
       user_list_cmd = 'awk -F\':\' -v "min='+uid_min.strip()+'" -v "max='+uid_max.strip()+'" \'{ if ( $3 >= min && $3 <= max ) print $1}\' /etc/passwd'
       user_list_cmd_result = runOnShell(user_list_cmd)
       user_list = filter(None,user_list_cmd_result.split("\n"))
       if(user_list):
          user_email_list = []
          for user in user_list:
               sudoer_check = runOnShell('sudo -l -U '+user)
               if not 'is not allowed to run sudo' in sudoer_check:
                    user_email_list.append(user.strip()+hostname_remote)
               else:
                    logging("There are no alias(es) configured for root that forward to a monitored email address. Please create alias(es) manually.")
          if(user_email_list):
               user_email_list.append('root'+hostname_remote)
               user_email_str =   ','.join(user_email_list)
               runOnShell("sed -i '/^root:/d' /etc/aliases")
               runOnShell('echo "root: '+user_email_str+'" >> /etc/aliases; newaliases;')
               if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
                   runOnShell('systemctl restart postfix')
               else:
                   runOnShell('service postfix restart')
               logging(user_email_str+' aliases is configured successfully for root that forward to a monitored email address.')
       else:
            logging("No Administrator user present.")

def checkRule38447():
	global g_rule38447FailAndMnual

	if OsName.lower() == "ubuntu":
		if not CheckPackage ("debsums"):
			logging("debsums package is not installed as debsums is required to verify all installed packages.")
			return False

	        logging ("It will take more time to complete the process if there are many packages which are need to be reinstalled.\
Checking if all files contents are matching with the given database or not.")
		#It will list all changed packages except configuration files
		databaseMismatchFiles = runOnShell("debsums -c 2> /dev/null")
		if "not found" in databaseMismatchFiles:
		    logging ("debsums package is not installed as it is required to verify all installed packages.")
		    return False
	else:
		databaseMismatchFiles = runOnShell("rpm -Va | awk '$1 ~ /..5/ && $2 != \"c\"'")

	if databaseMismatchFiles != "":
	    splitRes = databaseMismatchFiles.splitlines()
	    if any ("prelink" not in fileEle for fileEle in splitRes):
		if g_rule38447FailAndMnual:
		    #This code part will be executed after fixing the rule, if there is any mismatchig database files are available
		    logging ("As there are packages which are dependent on front-end like debconf or interlinked with other packages \
which are not available in the system, these packages will remain for reinstalling. Hence, run it as manually.")
		    return None
		else:
		    logging ("There are files whose contents are not matching with the given database.")
		    return False

	logging ("All file contents are verified and matching with the given database.")
	return True

def fixRule38447():
	global g_rule38447FailAndMnual
	g_rule38447FailAndMnual = True

	#It contains the packages which are not successfully reinstalled
	reinstallionFailList = []
	if OsName.lower() == "ubuntu":
            if not InstallPackage("debsums"):
                return None
	    databaseMismatchFiles = runOnShell("debsums -c 2> /dev/null").splitlines()
	    pkgList = []
	    logging ("Restarting the packages for synchronizing with Ubuntu database.")
	    for file1 in databaseMismatchFiles:
		package = runOnShell('dpkg -S {0} | cut -d ":" -f1'.format(file1))
		if package not in pkgList:
		    pkgList.append(package)
		    installPackage = runOnShell("apt-get -y install --reinstall {0} 1>/dev/null".format(package))
                    if "dpkg was interrupted" in installPackage:
                        logging("dpkg is not properly configured, it needs to be configured properly using \
command 'dpkg --configure -a'. Please fix this manually.")
                        return None
                    if "debconf" in installPackage:
			reinstallionFailList.append(package)
	else:
	    if OsName.lower() == "amazon linux ami":
		yumFlag = False #To know whether yum is enabled or not
		yumFlagStr = "plugins=0" #yumFlag enabling string
		#open the /etc/yum.conf file for searching yumString
		with open("/etc/yum.conf", "r") as yumConfigFile:
		    for line in yumConfigFile:
			if isL(line) and tokenMatchIC(yumFlagStr, line):
			    yumFlag = True
			    break

	    if OsName.lower() == "amazon linux ami" and yumFlag == False:
		#If YUM flag is not enabled, enable it
		setPluginParamYum(False)

	    file_name = ""
	    #Maintains all available packages under this list
	    pkgList = []
	    databaseMismatchFiles = runOnShell("rpm -Va | awk '$1 ~ /..5/ && $2 != \"c\"'")
	    finalReinstallPackages = filter(lambda elem:elem != '', databaseMismatchFiles.splitlines())
	    for line in finalReinstallPackages:
		if "prelink:" in line:
		    continue
		line = re.sub(' +', ' ', line)
		splitLine = line.split(' ')
		try:
		    if len(splitLine) == 3:
			fileName = splitLine[2]
		    else:
			fileName = splitLine[1]
		except IndexError:
		    logging ("This is not a valid file to produce the package: {0}.".format(line))
		    continue

		packages = runOnShell('rpm -qf %s' % fileName).split('\n')
		if (packages):
		    #Comments: If there is a package which is not downloaded, following the below steps 
		    #Step 1: yum -y install yum-utils
		    #Step 2: yumdownloader <package>
		    #Step 3: yum -y reinstall <package>
		    #Otherwise, we have to download that package and install the same
		    for package in packages[:-1]:
			if package not in pkgList:
			    pkgList.append(package)
        	            res = runOnShell("yum -y reinstall {0}".format(package))
			    if "not available" in res:
				#runOnShell("yum -y install yum-utils")
				runOnShell("yumdownloader -y {0}".format(package))
				res = runOnShell("yum -y reinstall {0}".format(package))
				if "not available" in res:
				    logging ("There is a problem with {0} package, not able to download. Hence, unable to reinstall it.".format(package))
				    reinstallionFailList.append(package)

	    if OsName.lower() == "amazon linux ami" and yumFlag == False:
	        #After using YUM, disable the flag
		setPluginParamYum(True)

	#Listing all packages which are not properly re-installed
	if len(reinstallionFailList) > 0:
	    logging ("Listing the packages which are not successfully reinstalled.")
	    logging ("\n".join(reinstallionFailList))
	    #for package in reinstallionFailList:
	    #    logging (str(package) + "\n")


#Note, per RedHat/CentOS forums, it is safer to do 
#  /usr/sbin/prelink -av -mR
#before running the rpm -V check since some libraries may not be
#prelinked and will give a warning that some files have changed
#Note that this check is quite slow (runs through the entire set of
#  rpm files. 
def checkRule38448():
	if os.path.exists('/etc/gshadow') == False:
		logging("/etc/gshadow file does not exist.")
		return True
	logging("Checking permissions of file '/etc/gshadow/'.")
	own_value = runOnShell('ls -l /etc/gshadow')
	own_value = own_value.split(" ")[3] == "root"
	if own_value:
		logging("File '/etc/gshadow' is goup-owned by root.")
		return True
	else:
		logging("File '/etc/gshadow' is not goup-owned by root.")
		return False

def fixRule38448():
	logging("Changing the group owner of '/etc/gshadow'.")
        runOnShell('chgrp root /etc/gshadow')


def checkRule38449():
	if not os.path.exists('/etc/gshadow'):
		logging("File '/etc/gshadow' does not exist.")
		return True
	logging("Checking whether the permissions of file '/etc/gshadow' are set correctly.")
        # Permissions of /etc/gshadow should be 0000, anything other than that is not acceptable.
	if not int(runOnShell ('stat -c "%a" /etc/gshadow')):
		logging("Permissions of file '/etc/gshadow' are set correctly.")
		return True
	else:
		logging("Permissions of file '/etc/gshadow' are not set correctly.")
		return False

def fixRule38449():
	logging("Changing the permissions of file '/etc/gshadow'.")
        runOnShell('chmod 0000 /etc/gshadow')


def checkRule38450():
	if os.path.exists('/etc/passwd') == False:
		logging("'/etc/passwd' file does not exist.")
		return True
	logging("Checking the ownership of file '/etc/passwd'.")
	own_value = runOnShell('ls -l /etc/passwd')
	own_value = own_value.split(" ")[2] == "root"
	if own_value:
		logging("File '/etc/passwd' is owned by root.")
		return True
	else:
		logging("File '/etc/passwd' is not owned by root.")
		return False


def fixRule38450():
	logging("Changing the owner of file '/etc/passwd'.")
        runOnShell('chown root /etc/passwd')


def checkRule38451():
	if os.path.exists('/etc/passwd') == False:
		logging("'/etc/passwd' file does not exist.")
		return True
	logging("Checking the group ownership of file '/etc/passwd'.")
	own_value = runOnShell('ls -l /etc/passwd')
	own_value = own_value.split(" ")[3] == "root"
	if own_value:
		logging("File '/etc/passwd' is group-owned by root.")
		return True
	else:
		logging("File '/etc/passwd' is not group-owned by root.")
		return False

def fixRule38451():
	logging("Changing the group owner of '/etc/passwd'.")
        runOnShell('chgrp root /etc/passwd')

# 38452 needs to be redone. Check for ^.M. then for each file
# rpm -qf [filename]
def checkRule38452():
	if OsName.lower() == "ubuntu":
            logging("dpkg did not provide support for setperms option, not applicable for ubuntu.")
            return None
	else:
            res = runOnShell("sudo rpm -Va | grep '^.M'")
	    if res == "":
		logging ("The system package management verifies permissions on all files and directories associated with packages.")
		return True
	    splitRes = res.splitlines()
            for fileName in splitRes:
		if "prelink" in fileName:
		    continue
		else:
		    logging ("The system package management does not verify permissions on all files and directories associated with packages.")
		    return False

	    logging ("The system package management verifies permissions on all files and directories associated with packages.")
            return True

def fixRule38452():
	if OsName.lower() == "ubuntu":
            logging("dpkg did not provide support for setperms option, not applicable for ubuntu.")
            return None

	fileName = ""
	res = runOnShell("sudo rpm -Va | grep '^.M'")
	#The list contains all files whose permissions are differenet from redhat data basae
	permissionList = filter(lambda elem:elem != '', res.splitlines())
	#Maintains packages list to avoid setting permissions again
	pkgList = []
	for line in permissionList:
	    if "prelink" in line:
	        continue
	    line = re.sub(' +', ' ', line)
	    splitLine = line.split(' ')
	    try:
		if len(splitLine) == 3:
		    fileName = splitLine[2]
		else:
		    fileName = splitLine[1]
	    except IndexError:
		continue

	    packages = runOnShell('sudo rpm -qf %s' %fileName).splitlines()
	    for package in packages:
		if package not in pkgList:
		    pkgList.append(package)
		    #Setting permissions to the package for synching with database
		    runOnShell("sudo rpm --setperms %s 2> /dev/null" %package)

def checkRule38453():
	if OsName.lower() == "ubuntu":
            logging("dpkg did not provide support for setugids option, not applicable for ubuntu.")
            return None
	else:
            res = runOnShell("sudo rpm -Va | grep '^......G'")
	    if res == "":
		logging ("The system package management verifies group-ownership on all files and directories associated with packages.")
		return True
	    splitRes = res.splitlines()
            for fileName in splitRes:
		if "prelink" in fileName:
		    continue
		else:
		    logging ("The system package management does not verify group-ownership on all files and directories associated with packages.")
		    return False

	    logging ("The system package management verifies group-ownership on all files and directories associated with packages.")
            return True

def fixRule38453():
	if OsName.lower() == "ubuntu":
            logging("dpkg did not provide support for setperms option, not applicable for ubuntu.")
            return None

	fileName = ""
	res = runOnShell("sudo rpm -Va | grep '^......G'")
	#The list contains all files whose group-ownership is differenet from redhat data basae
	groupOwnerList = filter(lambda elem:elem != '', res.splitlines())
	#Maintains packages list to avoid setting permissions again
	pkgList = []
	for line in groupOwnerList:
	    if "prelink" in line:
	        continue
	    line = re.sub(' +', ' ', line)
	    splitLine = line.split(' ')
	    try:
		if len(splitLine) == 3:
		    fileName = splitLine[2]
		else:
		    fileName = splitLine[1]
	    except IndexError:
		continue

	    packages = runOnShell('sudo rpm -qf %s' %fileName).splitlines()
	    for package in packages:
		if package not in pkgList:
		    pkgList.append(package)
		    #Setting permissions to the package for synching with database
		    runOnShell("sudo rpm --setugids %s 2> /dev/null" %package)

def checkRule38454():
	if OsName.lower() == "ubuntu":
            logging("setugids option is not supported by ubuntu. So, this rule is not applicable.")
            return None
	else:
            res = runOnShell("sudo rpm -Va | grep '^.....U'")
	    if res == "":
		logging ("The system package management verifies ownership on all files and directories associated with packages.")
		return True

	    splitRes = res.splitlines()
            for fileName in splitRes:
		if "prelink" in fileName:
		    continue
		else:
		    logging ("The system package management does not verify ownership on all files and directories associated with packages.")
		    return False

	    logging ("The system package management verifies ownership on all files and directories associated with packages.")
            return True

def fixRule38454():
	if OsName.lower() == "ubuntu":
            logging("setugids option is not supported by ubuntu. So, this rule is not applicable.")
            return None

	fileName = ""
	res = runOnShell("sudo rpm -Va | grep '^.....U'")
	#The list contains all files whose ownership is differenet from redhat data basae
	ownerList = filter(lambda elem:elem != '', res.splitlines())
	#Maintains packages list to avoid setting permissions again
	pkgList = []
	for line in ownerList:
	    if "prelink" in line:
	        continue
	    line = re.sub(' +', ' ', line)
	    splitLine = line.split(' ')
	    try:
		if len(splitLine) == 3:
		    fileName = splitLine[2]
		else:
		    fileName = splitLine[1]
	    except IndexError:
		continue

	    packages = runOnShell('sudo rpm -qf %s' %fileName).splitlines()
	    for package in packages:
		if package not in pkgList:
		    pkgList.append(package)
		    #Setting permissions to the package for synching with database
		    runOnShell("sudo rpm --setugids %s 2> /dev/null" %package)

def checkRule38455():
	if checkMount('/tmp'):
                return True 

        logging("The tmp partition is used as temporary storage by many programs. Placing /tmp in its own partition enables the setting of more restrictive mount options, which can help protect programs which use it. Please create a separate file system for /tmp.")
        return None

def fixRule38455():
	#rulegui.showFix( 38455 )
	logging("The tmp partition is used as temporary storage by many programs. Placing /tmp in its own partition enables the setting of more restrictive mount options, which can help protect programs which use it. Please create a separate file system for /tmp.")
        return None

def checkRule38456():
	if checkMount('/var'):
                return True

        logging("Ensuring that /var is mounted on its own partition enables the setting of more restrictive mount options. This helps protect system services such as daemons or other programs which use it. It is not uncommon for the /var directory to contain world-writable directories, installed by other software packages. Please create a separate file system for /var.")
        return None

def fixRule38456():
	#rulegui.showFix (38456 )
	logging("Ensuring that /var is mounted on its own partition enables the setting of more restrictive mount options. This helps protect system services such as daemons or other programs which use it. It is not uncommon for the /var directory to contain world-writable directories, installed by other software packages. Please create a separate file system for /var.")
        return None

def checkRule38457():
	if os.path.exists('/etc/passwd') == False:
		logging("'/etc/passwd' file does not exist.")
		return True
	logging("Checking the permissions of file '/etc/passwd'.")
	tmpOct = int(runOnShell ('stat -c "%a" /etc/passwd'),8)
	# 07133 is an octal number which binary ands with tmpOct, it's result is used to decide if permissions are set correctly or not.
	# why 7133? Because when 7133 converted to binary gives 111 001 011 011
	# Linux file permissions                                rwx   x  wx  wx
	# permsissions above are the ones which we don't want the owner,group and others to have.
	if tmpOct & 07133:
		logging("Permissions for /etc/passwd file are not configured properly.")
		return False
	logging("Permissions for /etc/passwd file are configured properly.")
	return True

def fixRule38457():
	logging("Changing the permissions of '/etc/passwd'.")
        runOnShell('chmod 0644 /etc/passwd')

def checkRule38458():
	if os.path.exists('/etc/group') == False:
		logging("'/etc/group' file does not exist.")
		return True
	logging("Checking the ownership of file '/etc/group'.")
	own_value = runOnShell('ls -l /etc/group')
	own_value = own_value.split(" ")[2] == "root"
	if own_value:
		logging("File '/etc/group' is owned by root.")
		return True
	else:
		logging("File '/etc/group' is not owned by root.")
		return False

def fixRule38458():
	logging("Changing the owner of file '/etc/group'.")
        runOnShell('chown root /etc/group')

def checkRule38459():
	if os.path.exists('/etc/group') == False:
		logging("'/etc/group' file does not exist.")
		return True
	logging("Checking the group ownership of '/etc/group'.")
	own_value = runOnShell('ls -l /etc/group')
	own_value = own_value.split(" ")[3] == "root"
	if own_value:
		logging("File '/etc/group' is group-owned by root.")
		return True
	else:
		logging("File '/etc/group' is not group-owned by root.")
		return False

def fixRule38459():
	logging("Changing the group owner of '/etc/group'.")
        runOnShell('chgrp root /etc/group')

def checkRule38460():
	if OsName.lower() == "ubuntu":
	    service_name = "nfs-kernel-server"
	else:
            service_name = "nfs-utils"

	#Indicates all_squash option with ro option
	roFlag = False

	if not CheckPackage(service_name):
	    return True

	logging("Checking NFS server's mount configuration file existence.")
	if not os.path.exists('/etc/exports'):
	    logging("NFS package is installed but, NFS server configuration file is not available. Please fix it manually.")
	    return None

	logging("Checking syntax errors on NFS server configuration file.")
	if runOnShell("exportfs -a"):
	    logging("As NFS server configuration file has syntax errors, please fix it manually.")
	    return None

	logging("Checking the content of NFS server's configuration file.")
	if not int(runOnShell ("cat /etc/exports | grep -v '^$\|^#\|^\s*\#' | wc -l")):
	    logging("The NFS configuration file is not configured with any NFS client entries.")
	    return True

	logging("Checking all_squash option in /etc/exports file at NFS Server.")
	NFSServerConfigureList = runOnShell("grep -w all_squash /etc/exports | grep -v '^#'").splitlines()
	for NFSEntry in NFSServerConfigureList:
	    if isL(NFSEntry):
		optionObj= re.match(r".*\((.*)\)", NFSEntry)
		if optionObj != None:
		    optionList = optionObj.group(1).split(',')
		    for option in xrange (len (optionList) - 1, -1, -1):
			if "ro" == optionList[option]:
			    break
			elif "rw" == optionList[option]:
			    logging("The below mentioned entry has read-write permissions & all_squash options.\n{0}".format(NFSEntry))
			    return False
			else:
			    pass
	    roFlag = True

	if roFlag:
	    logging("The NFS server configuration file is configured with 'all_squash' with 'read-only' option entries.")
	else:
	    logging("The NFS server configuration file is not configured with 'all_squash' option.")
	return True

def fixRule38460():
	logging("Checking NFS server's mount configuration file existence.")
	if not os.path.exists('/etc/exports'):
	    logging("NFS package is installed but, NFS server configuration file is not available.")
	    return None

	logging("Checking syntax errors on NFS server configuration file.")
	if runOnShell("exportfs -a"):
	    logging("As NFS server configuration file has syntax errors.")
	    return None

	logging("Checking and removing all_squash option of the instance from /etc/exports file.")
	with open("/etc/exports", "r") as NFSConfigFileContent:
		NFSConfigFileInfo = ""
		for NFSEntry in NFSConfigFileContent:
			if isL(NFSEntry) and "all_squash" in NFSEntry:
			    splitNFSEntry = NFSEntry.split('(')
			    optionObj= re.match(r".*\((.*)\)", NFSEntry)
			    if optionObj != None:
				#It contains individual NFS entry's options
		    		optionList = optionObj.group(1).split(',')
				optionList = list(set (optionList))
				optionList.remove("all_squash")
				NFSEntry = splitNFSEntry[0] + "(" + ",".join(optionList) + ")\n" 
			else:
			    lastLine = NFSEntry

			#Updating NFS Configuration file Content
			NFSConfigFileInfo += NFSEntry

	NFSConfigFileRef = open("/etc/exports", 'wt')
	if NFSConfigFileRef is not None:
	    NFSConfigFileRef.write(NFSConfigFileInfo)
	    NFSConfigFileRef.close()

	if OsName.lower() == "ubuntu":
		logging ("Restarting nfs-kernel-server after removing all_squash option instance from /etc/exports file.")
		runOnShell("service nfs-kernel-server restart")
	elif OsName.lower() == "centos" and OsVersion >= (7,0):
		logging("Restarting nfs-server after removing all_squash option instance from /etc/exports file.")
	        runOnShell("systemctl restart nfs-server")
	else:
		logging("Restarting nfs after removing all_squash option instance from /etc/exports file.")
		runOnShell("service nfs restart")

def checkRule38461():
	if os.path.exists('/etc/group') == False:
		logging("'/etc/group' file does not exist.")
		return True
	logging("Checking the permissions of file '/etc/group'.")
	tmpOct = int(runOnShell ('stat -c "%a" /etc/group'), 8)
	# 07133 is an octal number which binary ands with tmpOct, it's result is used to decide if permissions are set correctly or not.
        # why 7133? Because when 7133 converted to binary gives 111 001 011 011
        # Linux file permissions                                ugs   x  wx  wx     u=set uid , g=set gid, s=set sticky bit
        # permsissions above are the ones which we don't want the owner,group and others to have.
	if tmpOct & 07133:
		logging("Permissions for /etc/group file are not configured properly.")
		return False
	logging("Permissions for /etc/group file are configured properly.")
	return True

def fixRule38461():
	logging("Changing the permissions of file '/etc/group'.")
        runOnShell('chmod 0644 /etc/group')

def checkRule38462():
	if OsName.lower() == "ubuntu":
	    if os.path.isdir("/etc/apt/"):
		logging("Checking if the Unauthenticated package(s) are allowed for installation on the system.")
		result = runOnShell('grep -rwi AllowUnauthenticated /etc/apt/ | grep -v ":\s*#"')
		if result != "":
                        logging("Unauthenticated package(s) are allowed for installation. Hence authenticity of \
system software packages during installation will not be cryptographically verified.")
			return False
		logging("Unauthenticated package(s) are not allowed for installation. Hence authenticity of \
system software packages during installation will be cryptographically verified.") 
		return True
	    else:
		logging("The unauthenticated package(s) cryptographic signatures directory does not exist. \
Please fix it manually.")
		return None
	else:
	    logging("Checking the RPM signature validation.")
	    validation_value = runOnShell('grep -w nosignature /etc/rpmrc /usr/lib/rpm/rpmrc /usr/lib/rpm/redhat/rpmrc ~root/.rpmrc 2>/dev/null | grep -v ":\s*#"')
            if validation_value != "":
		logging("RPM signature validation is disabled.")
		return False
	    else:
	    	logging("RPM signature validation is enabled.")
		return True

def fixRule38462():
	if OsName.lower() == "ubuntu":
	    if os.path.isdir("/etc/apt/"):
	        result = runOnShell('grep -rwi AllowUnauthenticated /etc/apt/ | grep -v ":\s*#"')
	        result = result.splitlines()
	        for line in result:
		    resultFile = line.split(":")[0]
		    if os.path.exists(resultFile):
		        with open(resultFile, "r") as fileData:
			    fileString = ""
			    logging("Removing the unauthenticated entries from the /etc/apt/ directory.")
                            for line in fileData:
			        if "AllowUnauthenticated" in line:
				    continue
			        else:
				    fileString += line
		        fout = None
                        fout = open(resultFile, 'wt')
                        if fout != None:
                            fout.write(fileString)
                            fout.close()
            else:
	        logging("The unauthenticated package(s) cryptographic signatures directory does not exist. Please fix it manually.")
                return None
	else:
	        res = runOnShell('grep -w nosignature /etc/rpmrc /usr/lib/rpm/rpmrc /usr/lib/rpm/redhat/rpmrc ~root/.rpmrc 2>/dev/null | grep -v ":\s*#"')
		for filename in res.splitlines():
		    filename  = filename.split(":")[0]
		    with open(filename, "r") as fileContent:
		        fileString = ""
			logging("Updating the configuration for RPM signature validation.")
		        for line in fileContent:
		            fileString += line.replace("nosignature", "")
		    fout = None
		    fout = open(filename, 'wt')
                    if fout != None:
                        fout.write(fileString)
                        fout.close()

def checkRule38463():
	if checkMount('/var/log'):
		return True

	logging("Placing /var/log in its own partition enables better separation between log files and other files in /var/log. \
Please create a separate file system for /var/log.")
	return None

def fixRule38463():
	#showFix (38463)
	logging("Placing /var/log in its own partition enables better separation between log files and other files in /var/log. Please create a separate file system for /var/log.")
	return None

def checkRule38464():
	if not CheckService("auditd"):
		return False
	if not os.path.exists('/etc/audit/auditd.conf'):
		logging("The configuration file for audit daemon does not exist. You have to fix this manually.")
		return None

	logging("Checking whether audit is configured to take appropriate action in case of disk errors.")
	res = runOnShell('grep -w disk_error_action /etc/audit/auditd.conf | grep -v "^#"')
	if not res:
		logging("Audit is not configured to take appropriate action in case of disk errors.")
		return False

	value = getValueOfKey("disk_error_action", res.rstrip('\n'))
	if value is not None:
		if not ("syslog" == value.lower() or "exec" == value.lower()):
			logging("Audit is not configured properly to take appropriate action in case of disk errors.")
			return False

		res = re.sub(' +',' ',res)
		value = getValueOfKey("disk_error_action", res.rstrip('\n'))
		if not ("disk_error_action =" +" "+value  in res.lower()):
			logging("Audit is not configured properly to take appropriate action in case of disk errors.")
			return False

		res = res.split()
		# If disk_full_action = exec, there should be a /path-to-script after "exec". For eg : disk_full_action = exec /usr/bin/logger
		# but the script should not accept parameters, the rule fails if it is configured like that. Rule will fail even if /path-to-script
		# does not exist or no /path-to-script provided.
		if value.lower() == "exec":
                        if len(res) == 4 and os.path.exists(res[3]):
                                logging("Audit is configured properly to take appropriate action in case of disk errors.")
                                return True
                        else:
                                logging("Audit is not configured properly to take appropriate action in case of disk errors.")
                                return False

		logging("Audit is configured properly to take appropriate action in case of disk errors.")
		return True

	logging("Configuration to take appropriate action in case of disk errors was either not found or has a syntax error.")
	return False

def fixRule38464():
        if not InstallPackage("audit"):
            return None

	if not os.path.exists('/etc/audit/auditd.conf'):
		logging("The configuration file for audit daemon does not exist. You have to fix this manually.")
		return None

	lastLine = ""
	file_string = ""
	flag = False
	fileSplit = open("/etc/audit/auditd.conf").readlines()
	for line in fileSplit:
		if isL(line) and ("disk_error_action" in line):
			line = line.translate(string.maketrans("\n\t\r", "   "))
			line = line.split("=")
			if tokenMatch("disk_error_action",line[0]):
				if not tokenMatch("# Cloud Raxak updated next line",lastLine):
					file_string += "# Cloud Raxak updated next line\n"
				logging("Updating audit configuration to take appropriate action in case of disk errors.")
				file_string += "disk_error_action = SYSLOG\n"
				flag = True
	        else:
	                file_string += line
	                lastLine=line
	if not(flag):
		logging("Configuring audit to take appropriate action in case of disk errors.")
	        file_string += "# Cloud Raxak updated next line\n"
	        file_string += "disk_error_action = SYSLOG\n"
	fout = None
	try:
	        fout = open("/etc/audit/auditd.conf", 'wt')
	        fout.write(file_string)
	finally:
	        if fout is not None:
	                fout.close()

	logging("Restarting audit service.")
        RunService("auditd")

def checkRule38465():
	file_path = []
        ret = True
	#Checking /lib directory
	logging("Checking the shared libraries that are group-writable or world-writable.")
        res = runOnShell('find -L /lib -perm /022 -type f')
        if res and not("No such file or directory" in res):
            for line in res.splitlines():
                if line:
		    #Avoiding any loops
		    if "loop detected" in line:
			continue
		    file_path.append(line)

    	res = runOnShell("uname -m")
       	if "64" in res:
		#Checking /lib64 directory
		logging("Checking the world-writable files in /lib64 directory.")
	        res = runOnShell('find -L /lib64 -perm /022 -type f')
	        if res and not("No such file or directory" in res):
	            for line in res.splitlines():
	                if line:
			    #Avoiding any loops
			    if "loop detected" in line:
				continue
			    file_path.append(line)
	
		logging("Checking the existence of /usr/lib64 directory.")
		#Checking /usr/lib64 directory
		if os.path.isdir('/usr/lib64'):
			logging("Checking the world-writable files in /usr/lib64 directory.")
			res = runOnShell('find -L /usr/lib64 -perm /022 -type f')
			if res and not("No such file or directory" in res):
			    for line in res.splitlines():
			        if line:
				    #Avoiding any loops
				    if "loop detected" in line:
					continue
				    file_path.append(line)

	#Checking /usr/lib directory
	logging("Checking the world-writable files in /usr/lib directory.")
        res = runOnShell('find -L /usr/lib -perm /022 -type f')
        if res and not("No such file or directory" in res):
            for line in res.splitlines():
                if line:
		    #Avoiding any loops
		    if "loop detected" in line:
			continue
		    file_path.append(line)

	if len(file_path) != 0:
		file_path_list = ','.join(file_path)
	    	logging ("There are shared libraries that are group-writable or world-writable, the list of file(s) are as following :  "+"'"+ file_path_list+"'")
	    	return False
	logging ("There are no shared libraries that are group-writable or world-writable.")
	return True

def fixRule38465():
	#Fixing /lib directory
	logging("Checking the shared libraries that are group-writable or world-writable.")
        res = runOnShell('find -L /lib -perm /022 -type f')
	logging("Changing the permission of shared libraries.")
        if res and not("No such file or directory" in res):
            for line in res.split("\n"):
                if line:
		    #Avoiding any loops
		    if "loop detected" in line:
			continue
                    runOnShell("chmod go-w " + line)

    	res = runOnShell("uname -m")
       	if "64" in res:
		#Fixing /lib64 directory
		logging("Checking the world-writable files in /lib64 directory.")
	        res = runOnShell('find -L /lib64 -perm /022 -type f')
	        if res and not("No such file or directory" in res):
	            for line in res.split("\n"):
	                if line :
			    #Avoiding any loops
			    if "loop detected" in line:
				continue
	                    runOnShell("chmod go-w " + line)

		logging("Checking the existence of /usr/lib64 directory.")
		if os.path.isdir('/usr/lib64'):
			logging("Checking the world-writable files in /usr/lib64 directory.")
			#Fixing /usr/lib64 directory
		        res = runOnShell('find -L /usr/lib64 -perm /022 -type f')
		        if res and not("No such file or directory" in res):
		            for line in res.split("\n"):
		                if line:
				    #Avoiding any loops
				    if "loop detected" in line:
					continue
		                    runOnShell("chmod go-w " + line)
		
	#Fixing /usr/lib directory
	logging("Checking the world-writable files in /usr/lib directory.")
        res = runOnShell('find -L /usr/lib -perm /022 -type f')
        if res and not("No such file or directory" in res):
            for line in res.split("\n"):
                if line:
		    #Avoiding any loops
		    if "loop detected" in line:
			continue
                    runOnShell("chmod go-w " + line)

def checkRule38466():
	file_path = []
	logging("Checking Library files which are not owned by root.")
	res = runOnShell('find -L /lib \! -user root')
        if res and not("No such file or directory" in res):
            for line in res.splitlines():
                if line:
		    # if File system loop is detected 
		    if "loop detected" in line:
                        continue
		    file_path.append(line)
 
    	res = runOnShell("uname -m")
       	if "64" in res:
		logging("Checking Library files which are not owned by root.")
		res = runOnShell('find -L /lib64 \! -user root')
	        if res and not("No such file or directory" in res):
	            for line in res.splitlines():
	                if line:
			    if "loop detected" in line:
	                        continue
			    file_path.append(line)

		logging("Checking the existence of /usr/lib64 directory")
		if os.path.isdir('/usr/lib64'):
			logging("Checking Library files which are not owned by root.")
			res = runOnShell('find -L /usr/lib64 \! -user root')
		        if res and not("No such file or directory" in res):
		            for line in res.splitlines():
		                if line:
				    if "loop detected" in line:
		                        continue
				    file_path.append(line)
	logging("Checking Library files which are not owned by root.")
	res = runOnShell('find -L /usr/lib \! -user root')
        if res and not("No such file or directory" in res):
            for line in res.splitlines():
                if line:
		    if "loop detected" in line:
                        continue
		    file_path.append(line)
	if len(file_path) != 0:
		file_path_list = ','.join(file_path)
	    	logging ("There are library file(s) which are not owned by root, the list of file(s) are as following :  "+"'"+ file_path_list + "'")
	    	return False
	logging ("Library files are owned by root.")
	return True

def fixRule38466():
	logging("Checking Library files which are not owned by root.")
	res = runOnShell('find -L /lib \! -user root')
	logging("Changing the Library files which are not owned by root.")
        if res and not("No such file or directory" in res):
            for line in res.splitlines():
                if line:
		    # if File system loop is detected 
		    if "loop detected" in line:
                        continue
                    runOnShell("chown -h root " + line)

    	res = runOnShell("uname -m")
       	if "64" in res:
		logging("Checking Library files which are not owned by root.")
		res = runOnShell('find -L /lib64 \! -user root')
		if res and not("No such file or directory" in res):
		    for line in res.splitlines():
		        if line:
			    if "loop detected" in line:
		                continue
		            runOnShell("chown -h root " + line)
		
		logging("Checking the existence of /usr/lib64 directory.")
		if os.path.isdir('/usr/lib64'):
			logging("Checking Library files which are not owned by root.")
			res = runOnShell('find -L /usr/lib64 \! -user root')
		        if res and not("No such file or directory" in res):
		            for line in res.splitlines():
		                if line:
				    if "loop detected" in line:
		                        continue
		                    runOnShell("chown -h root " + line)
			
	logging("Checking Library files which are not owned by root.")
	res = runOnShell('find -L /usr/lib \! -user root')
        if res and not("No such file or directory" in res):
            for line in res.splitlines():
                if line:
		    if "loop detected" in line:
                        continue
                    runOnShell("chown -h root " + line )

def checkRule38467():
	if checkMount('/var/log/audit'):
		return True
	
	logging("Placing '/var/log/audit' in its own partition enables better separation between audit files and other files, and helps ensure that auditing cannot be halted due to the partition running out of space. Please create a separate file system for /var/log/audit manually.")
	return None

def fixRule38467():
	logging("Placing '/var/log/audit' in its own partition enables better separation between audit files and other files, and helps ensure that auditing cannot be halted due to the partition running out of space. Please create a separate file system for /var/log/audit manually.")
	return None

def checkRule38468():
	if not CheckService("auditd"):
		return False
	if not os.path.exists('/etc/audit/auditd.conf'):
		logging("The configuration file for audit daemon does not exist. You have to fix this manually.")
		return None

	logging("Checking whether audit is configured to take appropriate action when the audit storage volume is full.")
	res = runOnShell('grep -w disk_full_action /etc/audit/auditd.conf | grep -v "^#"')
	if not res:
		logging("Audit is not configured to take appropriate action when the audit storage volume is full.")
		return False

	res = res.translate(string.maketrans("\n\t\r","   "))
	value = getValueOfKey("disk_full_action", res.rstrip('\n'))
	if value is not None:
		if not ("syslog" == value.lower() or "exec" == value.lower()):
			logging("Audit is not configured properly to take appropriate action when the audit storage volume is full.")
			return False

		if not ("disk_full_action =" +" "+value  in res.lower()):
			logging("Audit is not configured properly to take appropriate action in case of disk errors.")
			return False

		res = res.split()
		# If disk_full_action = exec, there should be a /path-to-script after "exec". For eg : disk_full_action = exec /usr/bin/logger
		# but the script should not accept parameters, the rule fails if it is configured like that. Rule will fail even if /path-to-script
		# does not exist or no /path-to-script provided.
		if value.lower() == "exec":
			if len(res) == 4 and os.path.exists(res[3]):
				logging("Audit is configured properly to take appropriate action when the audit storage volume is full.")
				return True
			else:
				logging("Audit is not configured properly to take appropriate action when the audit storage volume is full.")
				return False

		logging("Audit is configured to take appropriate action when the audit storage volume is full.")
		return True

	logging("Configuration for taking appropriate action when the audit storage volume reaches full capacity was not found.")
	return False

def fixRule38468():
        if not InstallPackage("audit"):
            return None

	if not os.path.exists('/etc/audit/auditd.conf'):
		logging("The configuration file for audit daemon does not exist. You have to fix this manually.")
		return None

	lastLine = ""
	file_string = ""
	flag = False
	fileSplit = open("/etc/audit/auditd.conf").readlines()
	for line in fileSplit:
		if isL(line) and ("disk_full_action" in line):
			line = line.translate(string.maketrans("\n\t\r", "   "))
			line = line.split("=")
			if tokenMatch("disk_full_action",line[0]):
				if not tokenMatch("# Cloud Raxak updated next line",lastLine):
					file_string += "# Cloud Raxak updated next line\n"
				logging("Updating the audit configuration to take appropriate action when the audit storage volume is full.")
				file_string += "disk_full_action = SYSLOG\n"
				flag = True
	        else:
	                file_string += line
	                lastLine=line
	if not(flag):
	        file_string += "# Cloud Raxak updated next line\n"
		logging("Configuring audit to take appropriate action when the audit storage volume is full.")
	        file_string += "disk_full_action = SYSLOG\n"
	fout = None
	try:
	        fout = open("/etc/audit/auditd.conf", 'wt')
	        fout.write(file_string)
	finally:
	        if fout is not None:
	                fout.close()

        RunService("auditd")

def checkRule38469():
	file_path = []
	list_path = ['/bin','/usr/bin','/usr/local/bin','/usr/sbin','/sbin/','/usr/local/sbin']
	if list_path != "":
	    logging("Checking for the system executables that are group-writable or world-writable.")
	    for element in list_path:
		res = runOnShell('find -L '+ element +' -perm /022 -type f')
		if res and not("No such file or directory" in res):
		   for line in res.split("\n"):
			if line:
			    if ("dangling symlink" in line) or ("loop detected" in line):
				continue
			    file_path.append(line)
	    if len(file_path) != 0:
		file_path_list = ','.join(file_path)
	    	logging ("There are files  having group-writable or world-writable permissions, the list of file(s) are as following :  "+"'"+ file_path_list+"'")
	    	return False
	logging ("There are no file(s) which are having group-writable or world-writable permissions.")
	return True

def fixRule38469():
	list_path = ['/bin','/usr/bin','/usr/local/bin','/usr/sbin','/sbin/','/usr/local/sbin']
	if list_path != "":
	    logging("Changing permissions of the file(s) that are group-writable or world-writable.")
	    for element in list_path:
		res = runOnShell('find -L '+ element +' -perm /022 -type f')
		if res and not("No such file or directory" in res):
		   for line in res.split("\n"):
			if line:
			    if ("dangling symlink" in line) or ("loop detected" in line):
				continue
			    runOnShell("chmod go-w " + line)

def checkRule38470():
	if not CheckService("auditd"):
		return False

	if not os.path.exists('/etc/audit/auditd.conf'):
		logging ("The audit configuration file does not exist, please fix this manually.")
		return None

	logging ("Checking whether system is configured to audit the storage volume when it approaches capacity.")
	res = runOnShell('grep -wi space_left_action /etc/audit/auditd.conf | grep -v "^#"')
	if res == "":
		logging ("The audit system is not configured to audit the storage volume when it approaches capacity.")
		return False
	value = getValueOfKey("space_left_action", res.rstrip('\n'))
	if value is None:
		logging("Configuration for auditing the storage volume when it approaches capacity, was either not found or has a syntax error.")
		return False
	if value.lower() == "email" or value.lower() == "syslog":
		update_res =  re.sub(' +', ' ', res)
		if  "space_left_action = email" in update_res.lower() or "space_left_action = syslog" in update_res.lower():
			# Section-1 Validating the value of dependant variable space_left_action
			validate_space_left = False
			disk_space_msg = "The system is not configured properly to check the disk space problem"
			display_flag = True
			val = 75
			value_num_logs = ""
			logging("Checking the maximum number of log files.")
			res_max_log_file = runOnShell('grep -wi max_log_file /etc/audit/auditd.conf | grep -v "^#"')
			converted_max_log_int = 0
	                value_max_log_file = ""
	                try:
		            value_max_log_file = getValueOfKey("max_log_file", res_max_log_file.rstrip('\n'))
		            converted_max_log_int = int(value_max_log_file)
                            update_res_max_log_file = re.sub(' +', ' ', res_max_log_file)
                            if "max_log_file = " + value_max_log_file not in update_res_max_log_file.lower():
				logging ("The maximum audit log file size flag value is not configured properly, to configure \
the maximum audit log file size remediate the Rule V-38633.")
				return None
	                except (ValueError, TypeError) as e:
			    logging ("The maximum audit log file size flag value is not configured properly, to configure the maximum \
audit log file size remediate the Rule V-38633.")
		            return None
			if  value_max_log_file != None:
			    logging("Checking the total number of log files.")
			    res_num_logs = runOnShell('grep -wi num_logs /etc/audit/auditd.conf | grep -v "^#"')
			    converted_num_log_int = 0
			    value_num_logs = ""
			    try:
			        value_num_logs = getValueOfKey("num_logs", res_num_logs.rstrip('\n'))
		                converted_num_log_int = int(value_num_logs)
				update_res_num_logs = re.sub(' +', ' ', res_num_logs)
				if "num_logs = " + value_num_logs not in update_res_num_logs.lower():
					logging ("The overall system log file(s) retention num_log value is not properly configured, \
to configure the system log file(s) retention remediate the Rule V-38636.")
					return None
	                    except (ValueError, TypeError) as e:
			        logging ("The overall system log file(s) retention num_log value is not properly configured, \
to configure the system log file(s) retention remediate the Rule V-38636.")
				return None

			    if  value_num_logs != None:
			        calculated_value = (int(value_max_log_file) * int(value_num_logs))*10/100
			        logging("Checking the remaining audit partition capacity.")
			        out = runOnShell('grep -wi space_left /etc/audit/auditd.conf | grep -v "^#"')
			        if out == "":
			            disk_space_msg = "The system is not configured to check the disk space problem"
			        else:
			            file_value = getValueOfKey("space_left", out.rstrip('\n'))
				    try:
			                if file_value is not None:
                                            space_left_flag = True
			                    out = out.split(" ")
			                    for element in out:
			                        if ("space_left=" in element) or ("="+file_value in element):
			                   	        disk_space_msg = "The system is not configured properly to check the disk space problem"
							space_left_flag = False
			                    list_of_int = [int(file_value), val, calculated_value]
			                    max_value = max(list_of_int)
                                            if space_left_flag:
			                        if int(file_value) >= max_value:
			                            validate_space_left = True
                                                    disk_space_msg = "The system is properly configured to check the disk space problem"
			                        else:
			                            display_flag = False
			                            disk_space_msg = "Need to change the setting that handles disk space problem, currently configured \
with " +file_value + "MB and recommended is "+ str(max_value) +"MB "
			                else:
			                    disk_space_msg = "The system is not configured properly to check the disk space problem"
				    except ValueError:
			            	disk_space_msg = "System is not configured properly to check the disk space problem as space_left value is not expected"

			# Section-2 Validating the value of dependant variable action_mail_acct 
			validate_action_mail_act = False
			mail_act_msg = "System is not properly configured to send email to notify administrator"
			logging("Checking whether the system is configured to send an email to an account in case if it needs to notify an administrator.")
			line = runOnShell('grep "action_mail_acct" /etc/audit/auditd.conf | grep -v "^#" ')
			if line != "":
			    value = getValueOfKey("action_mail_acct", line.rstrip('\n'))
			    if value is not None:
				if value == "root":
					output =  re.sub(' +', ' ', line)
			    		if "action_mail_acct = root" in output:
						validate_action_mail_act = True
			    			mail_act_msg = "System is configured to send an email to an account when it needs to notify an administrator"

			# Checking the space_left and action_mail_acct parameter's results and adding logging accordingly.
			if validate_space_left and validate_action_mail_act:
				logging ("System is configured to audit the storage volume when it approaches capacity.")
				return True
			elif not validate_space_left and not validate_action_mail_act:
				if display_flag :
					logging("The system is not configured properly to check the disk space problem as well as\
 not to send an email to an account when it needs to notify an administrator,\
 hence it could not be configured to audit the storage volume approaches capacity,\
 to configure the system to audit the disk space problem properly remediate the Rule V-38678 and V-38680.") 
				else:
					logging(disk_space_msg +" as well as not configured properly to send an email to an account when it needs to notify an administrator,\
 hence it could not be configured to audit the storage volume approaches capacity, \
to configure the system to audit the disk space problem properly remediate the Rule V-38678 and V-38680.")
			elif not validate_space_left:
				logging(disk_space_msg + ", hence system could not be configured to audit the storage volume when it approaches capacity,\
 to configure the system to audit the disk space problem properly remediate the Rule V-38678 first.")
			elif not validate_action_mail_act:
				logging(mail_act_msg + ", hence system could not be configured to audit the storage volume when it approaches capacity,\
to configure the system to notify administrator for sending an email remediate the Rule V-38680 first.")	
		else:
			logging ("The audit system is not configured to audit the storage volume when it approaches capacity.")
			return False
	else:
		logging ("The audit system is not configured to audit the storage volume when it approaches capacity.")
		return False
					
	return None


def fixRule38470():
	if not CheckPackage("audit"):
		InstallPackage("audit")

	if not os.path.exists('/etc/audit/auditd.conf'):
                logging ("The audit configuration file does not exist, hence fix it manually.")
                return None

	runOnShell('sed -ie "s/^[ \t]*space_left_action/space_left_action/;s/[ \t]*=/ =/;s/=[ \t]*/= /" /etc/audit/auditd.conf')
	with open('/etc/audit/auditd.conf', "r") as file_data:
		concat_line = ""
		lastLine = ""
		flag = False
		for line in file_data:
			if isL(line) and ("space_left_action" in line.lower()):
				flag = True
				value = line.split("_")
				if len(value)>3:
					concat_line += line
					lastLine = line
					continue
				splitLine = line.translate(string.maketrans("\n\t\r", "   "))
				splitLine = line.split("=")
				try:
					if tokenMatch("space_left_action",splitLine[0].lower()) and not tokenMatch("syslog",splitLine[1].lower()):
						if not tokenMatch("Cloud Raxak updated next line", lastLine):
							concat_line += "# Cloud Raxak updated next line\n"
						logging ("Updating the audit storage volume capacity flag.")
						concat_line += "space_left_action = email\n"
					else:
						concat_line += line
						lastLine = line
				except IndexError:
					if not tokenMatch("Cloud Raxak updated next line", lastLine):
                                                       concat_line += "# Cloud Raxak updated next line\n"
					logging ("Updating the audit storage volume capacity flag.")
					concat_line += "space_left_action = email\n"
			else:
				concat_line += line
				lastLine = line
	if not(flag):
		if not tokenMatch("Cloud Raxak updated next line", lastLine):
			concat_line += "# Cloud Raxak updated next line\n"
		logging ("Adding the audit storage volume capacity flag.")
		concat_line += "space_left_action = email\n"
	fout = None
	try:
		fout = open('/etc/audit/auditd.conf', "wt")
		fout.write(concat_line)
	finally:
		if (fout is not None):
			fout.close()

	logging("Restarting the audit daemon service.")
        RunService("auditd")

def checkRule38471():
	if not CheckService("auditd"):
		logging ("auditd service is not running.")
		return False
	logging("Checking configuration whether audispd plugin is active or not.")
	res = runOnShell('grep -w active /etc/audisp/plugins.d/syslog.conf | grep -v "^#"')
	if isL(res) and tokenMatch("yes",res.lower()):
		logging("Audispd plugin is active.")
		return True
	logging("Audispd plugin is not active.")
	return False 


def fixRule38471():
        if not InstallPackage("audit"):
            return None

	lastLine = ""
	file_string = ""
	flag = False
	fileSplit = open("/etc/audisp/plugins.d/syslog.conf").readlines()
	for line in fileSplit:
		if isL(line) and ("active" in line) and (flag == False):
			line = line.translate(string.maketrans("\n\t\r", "   "))
			line = line.split("=")
			if tokenMatch("active",line[0]):
				if not tokenMatch("# Cloud Raxak updated next line",lastLine):
					file_string += "# Cloud Raxak updated next line\n"
				logging("Updating audispd plugin to allow system to forward audit records to the syslog service.")
				file_string += "active = yes\n"
				flag = True
		else:
			file_string += line
			lastLine=line
	if not(flag):
		logging("Configuring audispd plugin to allow system to forward audit records to the syslog service.")
		file_string += "# Cloud Raxak updated next line\n"
		file_string += "active = yes\n"
	fout = None
	try:
		fout = open("/etc/audisp/plugins.d/syslog.conf", 'w')
		fout.write(file_string)
	finally:
		if fout is not None:
			fout.close()
        RunService("auditd")

def checkRule38472():
	file_path = []
	list_path = ['/bin','/usr/bin','/usr/local/bin','/usr/sbin','/sbin/','/usr/local/sbin']
	for element in list_path:
		logging("Checking ownership of system command files.")
		res = runOnShell('find -L '+ element +' \! -user root ')
		if res and not("No such file or directory" in res):
		   for line in res.split("\n"):
			if line:
			    if "loop detected" in line:
				continue
			    file_path.append(line)
	if len(file_path) != 0:
		file_path_list = ','.join(file_path)
	    	logging ("There are files which are owned by a user other than root, the list of file(s) are as following :  "+"'"+ file_path_list+"'")
	    	return False
	logging ("There are no file(s) which are owned by a user other than root.")
	return True

def fixRule38472():
	list_path = ['/bin','/usr/bin','/usr/local/bin','/usr/sbin','/sbin/','/usr/local/sbin']
	logging("Changing the ownership of the system command files.")
	for element in list_path:
		res = runOnShell('find -L '+ element +' \! -user root ')
		if res and not("No such file or directory" in res):
		   for line in res.split("\n"):
			if line:
			    if "loop detected" in line:
				continue
			    runOnShell("chown root " + line)

def checkRule38473():
	logging("Check if '/home' mounted as an NFS server.")
        check_nfs_mount = runOnShell('mount -t nfs | grep ":/" | grep "on[[:space:]]/home"[[:space:]]')
	if check_nfs_mount == "":
		logging("Checking if '/home' is on its own partition or logical volume.")
		check_part_mount = runOnShell('mount | grep "^/dev" |grep "on[[:space:]]/home[[:space:]]"')
		if check_part_mount == "":
			logging("The system must use a separate file system for user home directories, it is recommended to create a separate partition for '/home' manually.")
			return None
		else:
			logging("'/home' has its own partition or volume group.")
			return True
	logging("'/home' is mounted from another system such as an NFS server.")
	return True

def fixRule38473():
	#showFix (38473)
	logging("If '/home' will be mounted from another system such as an NFS server, then creating a separate partition is not necessary at installation time, and the mountpoint instead, can be configured later. Please fix this manually.")
        return None


def checkRule38474():
	# Checking If system is GUI or NON-GUI
	if check_gui_system():
		return True
        logging("Checking the keybindings for the Gnome screensaver.")
	nonSupportedTuple = ("<Alt>Escape", "<Shift>Return")
	supportedKeyTuple = ("Alt", "Control", "Shift", "Tab", "Primary", "Super", "Control_L", "Shift_L")
	if OsName.lower() == "ubuntu" or ((OsName.lower() == "redhat" or OsName.lower() == "centos") and OsVersion >= (7,0)):
		getCommand = "gsettings get org.gnome.settings-daemon.plugins.media-keys screensaver"
		# To Check the keybinding value of globalusers.
		gconf_golbal_users(getCommand)
		# This string Listing the Invalid keybinding user names.
		usersInfoFalse = ""
		# This string Listing the valid keybinding user names.
		usersInfoTrue = ""
		for nameOfUser, keybindingGuserValue in commandsOutDict.items():
			# Declaring the keyTrueFlag to stop againg going into true condition once it does true
			keyTrueFlag = False
			# Declaring the falseLogFlag to stop going into defalut true condition once it does false.
			falseLogFlag = False
			keybindingValue = keybindingGuserValue.strip().split(">")
			# Iterating the loop two times to replace elemnts for display the proper logmessage.
			keybindingValue =  [primaryValue.replace("<Primary","<Control").replace("_L", "") for primaryValue in keybindingValue]
			stripKeybindingValue =  [primaryValue.replace("'", "").replace("<", "") for primaryValue in keybindingValue]
			# To check if any nonsupported key's existancy
			for nonKey in nonSupportedTuple:
				if nonKey in keybindingGuserValue:
					falseLogFlag = True
					usersInfoFalse += ", " + nameOfUser
					logging("The specified keybinding " + keybindingGuserValue + " of " + nameOfUser + " is invalid \
format for the Gnome screensaver.")
			if len(keybindingValue) > 1:
				if any(bindValue in supportedKeyTuple for bindValue in stripKeybindingValue):
					# Accepting Numerics and alphabets if key combiantion is like <Control>1 or <Control>f
					if len(keybindingValue) == 2 and stripKeybindingValue[1].isdigit():
						usersInfoTrue += ", " + nameOfUser
						logging("The specified keybindings of " + nameOfUser + " \
is " + ">".join(keybindingValue) + " exist for the Gnome screensaver.")
						keyTrueFlag = True
					if not keyTrueFlag:
						# Accepting Only Alphabets not numeric and special charecters if key combination is more than 3 keys.
						for specialChar in stripKeybindingValue:
							if not re.match("^[a-zA-Z_]*$", specialChar.strip()):
								falseLogFlag = True
								usersInfoFalse += ", " + nameOfUser
								logging("The specified keybinding " + keybindingGuserValue + " \
of " + nameOfUser + " is invalid format for the Gnome screensaver.")
				else:
					falseLogFlag = True
					usersInfoFalse += ", " + nameOfUser
					logging("The specified keybinding " + keybindingGuserValue + " of " + nameOfUser + " is invalid \
format for the Gnome screensaver.")
			else:
				# If keybinding format is only single value <Control> or <Shift> etc..
				if any(singleValue in supportedKeyTuple for singleValue in stripKeybindingValue):
					usersInfoTrue += ", " + nameOfUser
					logging("The specified keybindings of " + nameOfUser + " is " + ">".join(keybindingValue) + " exist \
 for the Gnome screensaver.")
				else:
					falseLogFlag = True
					usersInfoFalse += ", " + nameOfUser
					logging("The specified keybinding " + keybindingGuserValue + " of " + nameOfUser + " is invalid \
format for the Gnome screensaver.")
			# Default true condition
			if not falseLogFlag and not keyTrueFlag:
				usersInfoTrue += ", " + nameOfUser
				logging("The specified keybindings of " + nameOfUser + " is " + ">".join(keybindingValue) + " \
exist for the Gnome screensaver.")

		if usersInfoFalse:
			return False
		if usersInfoTrue:
			return True
	else:
		keyCombination = runOnShell('gconftool-2 --get /apps/gnome_settings_daemon/keybindings/screensaver').strip()
		keybindingValue = keyCombination.strip().split(">")
		# Iterating the loop two times to replace elemnts for display the proper logmessage.
		keybindingValue = [primaryValue.replace("<Primary","<Control").replace("_L", "") for primaryValue in keybindingValue]
		stripKeybindingValue = [primaryValue.replace("'", "").replace("<", "") for primaryValue in keybindingValue]
		for nonKey in nonSupportedTuple:
			if nonKey in keyCombination:
				logging("The specified keybindings is invalid format for the Gnome screensaver.")
				return False
		if len(keybindingValue) > 1:
			if any(bindValue in supportedKeyTuple for bindValue in stripKeybindingValue):
				# Accepting Numerics and alphabets if key combiantion is like <Control>1 or <Control>f
				if len(keybindingValue) == 2 and stripKeybindingValue[1].isdigit():
					logging("The keybindings " + keyCombination + " exist for the Gnome screensaver.")
					return True
				#Accepting Only Alphabets if key combination is more than 3 keys.
				for specialChar in stripKeybindingValue:
					if not re.match("^[a-zA-Z_]*$", specialChar.strip()):
						logging("The specified keybindings is invalid format for the Gnome screensaver.")
						return False
			else:
                                logging("The specified keybindings is invalid format for the Gnome screensaver.")
                                return False
                else:
                        # If keybinding format is only single value <Control> or <Shift> etc..
			if any(singleValue in supportedKeyTuple for singleValue in stripKeybindingValue):
				logging("The keybindings " + keyCombination + " exist for the Gnome screensaver.")
				return True
			else:
				logging("The keybinding does not exist for the Gnome screensaver.")
				return False

		logging("The keybindings " + keyCombination + " exist for the Gnome screensaver.")
		return True


def fixRule38474():
	if OsName.lower() == "ubuntu" or ((OsName.lower() == "redhat" or OsName.lower() == "centos") and OsVersion >= (7,0)):
		# To check and install the gsetting package if does not exist.
		gsetting_package_check()
		getCommand = "gsettings get org.gnome.settings-daemon.plugins.media-keys screensaver"
		# Check the users which is having idle-activation disabled.
		gconf_golbal_users(getCommand)
		usersInfo = ""
		nonSupportedTuple = ("<Alt>Escape", "<Shift>Return")
		supportedKeyTuple = ("Alt", "Control", "Shift", "Tab", "Primary", "Super", "Control_L", "Shift_L")
		# Iterating the commandsOutDict dictionary to check the idle-activation status.
		for nameOfUser, keybindingGuserValue in commandsOutDict.items():
			loginUserFlag = False
			if (OsName.lower() == "ubuntu" and username == nameOfUser) or ("root" == nameOfUser):
				# Directly using the set command without login as user If user is logged in user in ubuntu or \
				# If user is root user in redhat
				loginUserFlag = True
			nonkeyFlag = False
			keybindingValue = keybindingGuserValue.strip().split(">")
			stripKeybindingValue = [primaryValue.replace("'", "").replace("<", "") for primaryValue in keybindingValue]
			for nonKey in nonSupportedTuple:
				if nonKey in keybindingGuserValue:
					nonkeyFlag = True
					logging("Setting the Gnome desktop keybinding '<Control><Alt>l' for locking the screen.")
					if loginUserFlag:
						runOnShell("dbus-launch gsettings set org.gnome.settings-daemon.plugins.media-keys\
 screensaver '<Control><Alt>l'")
					else:
						runOnShell("sudo -u " + nameOfUser + " -H dbus-launch gsettings set\
 org.gnome.settings-daemon.plugins.media-keys screensaver '<Control><Alt>l'")
			if not nonkeyFlag:
				if not any(bindValue in supportedKeyTuple for bindValue in stripKeybindingValue):
					logging("Setting the Gnome desktop keybinding '<Control><Alt>l' for locking the screen.")
					if loginUserFlag:
						runOnShell("dbus-launch gsettings set \
org.gnome.settings-daemon.plugins.media-keys screensaver '<Control><Alt>l'")
					else:
						runOnShell("sudo -u " + nameOfUser + " -H dbus-launch \
gsettings set org.gnome.settings-daemon.plugins.media-keys screensaver '<Control><Alt>l'")
				else:
					if len(keybindingValue)>1:
						for specialChar in stripKeybindingValue:
							# If any special charecters exists in key combination
							if (not re.match("^[a-zA-Z]*$", specialChar)) and (len(keybindingValue) != 2):
								logging("Setting the Gnome desktop keybinding '<Control><Alt>l' for\
 locking the screen.")
								if loginUserFlag:
									runOnShell("dbus-launch gsettings set \
org.gnome.settings-daemon.plugins.media-keys screensaver '<Control><Alt>l'")
								else:
									runOnShell("sudo -u " + nameOfUser + " -H dbus-launch gsettings set \
org.gnome.settings-daemon.plugins.media-keys screensaver '<Control><Alt>l'")
					else:
						# Key combination is like <Control>, <Alt>..etc or if it is empty.
						if not any(singleValue in supportedkeyList for singleValue in keybindingValue):
							logging("Setting the Gnome desktop keybinding '<Control><Alt>l' for\
 locking the screen.")
							if loginUserFlag:
								runOnShell("dbus-launch gsettings set \
org.gnome.settings-daemon.plugins.media-keys screensaver '<Control><Alt>l'")
							else:
								runOnShell("sudo -u " + nameOfUser + " -H dbus-launch gsettings set \
org.gnome.settings-daemon.plugins.media-keys screensaver '<Control><Alt>l'")

		logging ("Copying the dconfdata vlaues to local dconf database.")
		runOnShell("cp -u ~/.config/dconf/user /etc/dconf/db/local")
	else:
		logging("Setting the Gnome desktop keybinding '<Control><Alt>l' for locking the screen.")
		runOnShell("gconftool-2 --direct --config-source xml:readwrite:/etc/gconf/gconf.xml.mandatory --type string \
--set /apps/gnome_settings_daemon/keybindings/screensaver '<Control><Alt>l'")

	logging("Please reboot the system to complete the process of Gnome desktop setting.")


def checkRule38475(val=14):
	if OsName.lower() == "ubuntu":
	    logging("Checking if PAM module (libpam-cracklib) is installed to make sure there is no weak password during password change.")
	    check_libpam = runOnShell("dpkg -s libpam-cracklib")
	    if ("is not installed" in check_libpam) or ("deinstall" in check_libpam):
		logging("libpam-cracklib package is not installed on the system.")
		return False
	    filePath = "/etc/pam.d/common-password"
	    grep_module = 'pam_cracklib.so'
	else:
	    filePath = "/etc/pam.d/system-auth" 
	    #For Version >=7.
            if OsVersion >= (7,0):
                grep_module = 'pam_pwquality.so'
            else:
	        grep_module = 'pam_cracklib.so'
	logging("Checking for the minimum password length and also checking the other settings required for the password authentication.")
	res = runOnShell('grep -v "^#" ' + filePath + ' | grep -w '+ grep_module +' | grep -w password')
	res = res.translate(string.maketrans("\n\t\r", "   ")).strip()
	search_obj =  re.match(r'.*\s*(\bminlen=\d*\b)\s*', res)
	if (search_obj):
	    parameter = search_obj.group(1)
	    try:
	        actual_param,value =  parameter.split("=")
		minlen_value = int(value)
		if minlen_value != "":
			option_list = ['ucredit', 'lcredit', 'ocredit', 'dcredit']
			flag = False
			sumof_value = 0
			for option in option_list:
			    if option in res:# if for check options
				try:
					search_obj = re.search(r'.\b%s=-?\d\b' % option, res)
					parameter = search_obj.group()
					actual_param,param_value =  parameter.split("=")
					if int(param_value) < 0:
					    param_value_split = param_value.split('-')[1]
					    #sum of all credit values
					    sumof_value = sumof_value + int(param_value_split)
					elif int(param_value) > 0:
					    logging("The system requirement for the password is not configured correctly, need to update with credit parameter for authentication purpose.")
					    return False
					else:
					    flag = True
				except:
				    logging("The system password requirement for " + option + " is not correctly set, need to update with credit parameter for authentication purpose.")
				    return False
			    else:#else for check options
				logging("The system requirement for the password is not configured correctly, need to update with credit parameter for authentication purpose.")
				return False
			if sumof_value < val and minlen_value < val:
				logging("The system requirement for the password authentication is not configured correctly.")
				return False
			else:
				flag = True
			if flag:
			    logging("The system requirement for password minimum characters is valid.")
			    return True
		else:
		    logging("The minimum password length is not correct, the DoD requirement is '14'.")
		    return False
	    except ValueError:
		logging("The minimum password length is not correct, the DoD requirement is '14'.")
		return False
	else:
		logging("The minimum password length does not exist, the DoD requirement is '14'.")
		return False

def fixRule38475(val=14):
	if OsName.lower() == "ubuntu":
	    logging("Checking if PAM module (libpam-cracklib) is installed to make sure there is no weak password during password change.")
	    check_libpam = runOnShell("dpkg -s libpam-cracklib")
	    if ("not installed" in check_libpam) or ("deinstall" in check_libpam) or ("error" in check_libpam):
		logging("Installing the libpam-cracklib package.")
	    	if "dpkg was interrupted" in runOnShell("apt-get -y install libpam-cracklib"):
		    logging ("dpkg is not properly configured.\ndpkg need to be properly configured using 'dpkg --configure -a' command. Hence, run it as manually.")
		    return None
	    filePath = "/etc/pam.d/common-password"
	    grep_module = 'pam_cracklib.so'
	else:
	    filePath = "/etc/pam.d/system-auth" 
	    #For Version >=7.
            if OsVersion >= (7,0):
                grep_module = 'pam_pwquality.so'
            else:
	        grep_module = 'pam_cracklib.so'
	res = runOnShell('grep -v "^#" ' + filePath + ' | grep -w '+ grep_module +' | grep -w password')
	with open(filePath, "r") as file_content:
            file_string = ""
            lastLine = ""
	    flag = False
            for line in file_content:
		module_search_obj = re.search('^password\s*requisite\s*'+ grep_module, line)
		if module_search_obj != None and res != "":
			flag = True
			minlen_value_flag = False
			minlen_value = 0
			res = res.translate(string.maketrans("\n\t\r", "   ")).strip()
			try:
			    search_obj = re.match(r'.*\s*(\bminlen=\d*\b', res)
			    if (search_obj):
				parameter = search_obj.group(1)
				actual_param,value =  parameter.split("=")
				minlen_value = int(value)
				if minlen_value == "":
				    minlen_value_flag = True
			    else:
				minlen_value_flag = True
			except:
				minlen_value_flag = True
			
			option_list = ['ucredit', 'lcredit', 'ocredit', 'dcredit']
			updated_line = ""
			sumof_credit_values = 0
			for option in option_list:
			    #if option is in line
                            if isL(line) and option in line:
    	        	        line = line.translate(string.maketrans("\n\t\r", "   ")).strip()
				search_obj = re.search(r'\b%s=-?\d\b' % option, line)
				if search_obj != None:
					parameter = search_obj.group()
					actual_param,param_value =  parameter.split("=")
				        start = line.index(option)
	        		        new = line[start:]
					param_value_error_flag = False
					try:
					    if int(param_value) <= 0 and param_value != "":
					        try:
					    	    param_value_split = param_value.split('-')[1]
					    	    sumof_credit_values = sumof_credit_values + int(param_value_split)
					        except:
					    	    minlen_value_flag = True
				            elif int(param_value) > 0:
						param_value_error_flag = True
					    else:
						pass
					except:
					    param_value_error_flag = True
					if param_value_error_flag:
    						try:
				    	            end = new.index(" ")
				    	            updated_line = line[0:start] + option+"=0" + line[start+end:] + "\n"
				    	    	except:
				    	            end = 9
				    	            updated_line = line[0:start] + option+"=0" + line[start+end:len(line[start:])] + "\n"
			            		line = updated_line
				else:
					line = line.translate(string.maketrans("\n", " ")).strip()
					line = line+ " " +option+"=0"
			    #if credit option is not in line
			    else:
			        line = line.translate(string.maketrans("\n", " ")).strip()
	    		        line = line+ " " +option+"=0"+'\n'
			if sumof_credit_values < val and minlen_value < val:
				minlen_value_flag = True
			if minlen_value_flag:
			    if isL(line) and "minlen" in line:
				start = line.index("minlen")
				new = line[start:]
				try:
				    value = new.split("=")
				    end = new.index(" ")
				    line = line[0:start] + "minlen=14" + line[start+end:]
				except:
				    end = 9
				    line = line[0:start] + "minlen=14" + line[start+end:len(line[start:])]
			    else:
				#if minlen is not in line
				logging("Updating the system requirement for the minimum password length.")
				line = line.translate(string.maketrans("\n", " ")).strip()
				line = line +' minlen=14'
		if not(flag):
		    if OsName.lower() == "ubuntu":
		        if re.search('^password\s*\[success\=1\sdefault=ignore\]\s*pam_unix.so', line):
			    file_string += "# Cloud Raxak updated next line\n"
		            file_string += "password    requisite     pam_cracklib.so  minlen=14 lcredit=0 ucredit=0 dcredit=0 ocredit=0\n"
			    file_string += line
			    continue
	    	    else:
		        if re.search('^password\s*sufficient\s*pam_unix.so',line):
			    file_string += "# Cloud Raxak updated next line\n"
		            file_string += "password   requisite   "+ grep_module + " minlen=14 lcredit=0 ucredit=0 dcredit=0 ocredit=0\n"
		            file_string += line
			    continue
		if re.search('^password\s*requisite\s*'+ grep_module,line):
			if not tokenMatch("# Cloud Raxak updated next line",lastLine):
				file_string += "# Cloud Raxak updated next line\n"
			line = line +'\n'
		file_string += line
                lastLine = line
	fout = None
	try:
	    fout = open(filePath, "wt")
	    fout.write(file_string)
	finally:
	    if (fout is not None):
	        fout.close()
	
def checkRule38476():
	if (OsName.lower() == "ubuntu"):
	    logging("Checking if GPG key is installed.")
	    res = runOnShell('apt-key list')
	    if res != "" and "Ubuntu Archive" in res:
		logging("Cryptographic certificates are installed on the system, which are used to verify the integrity of system software.")
		return True
            else:
                logging("To ensure that the system can cryptographically verify base software packages, GPG key need to be updated.")
                return False
	else:
	    logging("Checking if GPG key is installed.")
	    res = runOnShell('rpm -qa gpg-pubkey')
	    if res != "" and "gpg-pubkey-" in res:
		logging("Cryptographic certificates are installed on the system, which are used to verify the integrity of system software.")
	        return True
            else:
		if (OsName.lower() == 'centos'):
                    logging("To ensure that the system can cryptographically verify base software packages, need to import GPG key.")
                    return False
                else:
                    logging("Please fix it manually because for installing the GPG keys,run 'rhn_register' command(rhn-client-tools package is required) user inputs are required such as keytype,keysize etc. If the system is not connected to the Internet or an RHN Satellite, then install the Red Hat GPG keys from trusted media such as the Red Hat installation CD-ROM or DVD. Assuming the disc is mounted in '/media/cdrom', use the following command as the root user to import them into the keyring 'sudo rpm --import /media/cdrom/RPM-GPG-KEY'")
                    return None

def fixRule38476(): 
	if (OsName.lower() == "ubuntu"):
            logging("Updating the GPG key list.")
            runOnShell("apt-key update")
	elif (OsName.lower() == 'centos'):
	    if OsVersion >= (7,0):
                runOnShell("rpm --import http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-7")
	    else:
                runOnShell("rpm --import http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-6")
        else:
	    logging("For installing the keys, user inputs are required such as keytype, keysize etc.")
            return None
        
#ASG:Made the necessary code changes to fetch element's value
#and validate the rule based on element's value.
def checkRule38477():
        if os.path.exists('/etc/login.defs'):
                logging("Checking for minimum password age.")
                pass_min = runOnShell('grep -w PASS_MIN_DAYS /etc/login.defs | grep -v "^#" | awk -F" " \'{ print $2 }\'')
		try:
			pass_min = int(pass_min)
		except ValueError:
			logging("The minimum password age is either not defined or not configured correctly for all users.")
			return False
		if pass_min < PASS_MIN_DAYS:
			logging("The minimum password age is not configured correctly for all users.")
			return False
		logging("Checking for maximum password age.")
                pass_max = runOnShell('grep -w PASS_MAX_DAYS /etc/login.defs | grep -v "^#" | awk -F" " \'{ print $2 }\'')
		try:
			pass_max = int(pass_max)
                        if pass_max <= 0:
				logging("The maximum password age for all users is not configured correctly. Please remediate rule V-38479 first.")
				return None
			else:
				pass
                # This block will be executed only if PASS_MAX_DAYS value is not defined or has been configured absurdly.
		except ValueError:
			logging("The maximum password age for all users is either not defined or not configured correctly. Please remediate rule V-38479 first.")
			return None
		if pass_min <= pass_max:
			if CheckPasswdAge(pass_min, "Minimum number of days between password change"):
				logging("The minimum password age is configured correctly for all users.")
				return True
			else:
				logging("The minimum password age is not configured correctly for all users.")
				return False
		else:
			logging("The minimum password age is not configured correctly for all users.")
			return False
	else:
		logging("The file /etc/login.defs sets the minimum password age for users, but it does not exist. Please fix this manually.")
		return None

def fixRule38477():
	if not os.path.exists('/etc/login.defs'):
		logging("The file /etc/login.defs sets the minimum password age for users, but it does not exist. Please fix this manually.")
		return None
	pass_min = runOnShell('grep -w PASS_MIN_DAYS /etc/login.defs | grep -v "^#" | awk -F" " \'{ print $2 }\'')
	pass_max = runOnShell('grep -w PASS_MAX_DAYS /etc/login.defs | grep -v "^#" | awk -F" " \'{ print $2 }\'')
	try:
		pass_max = int(pass_max)
		if pass_max <= 0:
			logging("The maximum password age for all users is not configured correctly. Please remediate rule V-38479 first.")
			return None
		else:
			pass
	except ValueError:
		logging("The maximum password age for all users is either not defined or not configured correctly. Please remediate rule V-38479 first.")
		return None
	pass_min = pass_min.strip()
	if pass_min == "" or not(pass_min.isdigit()) or int(pass_min) < PASS_MIN_DAYS or int(pass_min) >= pass_max:
		lastLine = ""
		string_write = ""
		flag = False
		fileSplit = open("/etc/login.defs").readlines()
		logging("Updating the minimum password age.")
		for line in fileSplit:
			if isL(line) and "PASS_MIN_DAYS" in line:
				if not flag:
					if not tokenMatch("Cloud Raxak updated next line",lastLine):
						string_write += "# Cloud Raxak updated next line\n"
					string_write += "PASS_MIN_DAYS\t"+str(PASS_MIN_DAYS)+"\n"
					flag = True
			else:
				string_write += line
				lastLine=line
		if not flag:
			logging("Setting the minimum password age.")
			if not tokenMatch("Cloud Raxak updated next line",lastLine):
				string_write += "# Cloud Raxak updated next line\n"
			string_write += "PASS_MIN_DAYS\t"+str(PASS_MIN_DAYS)+"\n"
		fout = None
		try:
			fout = open('/etc/login.defs', "w")
			fout.write(string_write)
		finally:
			if (fout is not None):
				fout.close()
		runOnShell('pwunconv;pwconv')
	else:
		runOnShell('pwunconv;pwconv')

def checkRule38478():
	logging("Checking the installation of rhnsd service.")
	if os.path.exists('/usr/sbin/rhnsd') == False:
		logging("The Red Hat Network Service (rhnsd) is not installed.")
		return True

	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		service_status = runOnShell('systemctl is-active rhnsd.service').replace('\n','')
		if service_status in ["inactive", "unknown","failed"]:
			return True
		service_at_runlevel = runOnShell("systemctl is-enabled rhnsd.service").replace('\n','')
		if service_status == "active" or service_at_runlevel == "enabled":
			logging("The Red Hat Network Service (rhnsd) service is running.")
			return False
	else:
		if OsName.lower() == "ubuntu":
			service_at_level = 'sysv-rc-conf --list rhnsd'
			token_match = "rhnsd is not running"
		else:
			service_at_level = 'chkconfig --list rhnsd'
			token_match = "stopped"

		service_check_flag = True	
		logging("Checking the status of Red Hat Network Service (rhnsd).")
		service_status = runOnShell('service rhnsd status').translate(string.maketrans("\n\t\r", "   "))
		if service_status == "":
			logging("rhnsd service is not running.")
			service_check_flag = True
		elif not tokenMatchIC(token_match, service_status):
			service_check_flag = False

		logging("Checking the status of Red Hat Network Service (rhnsd) at runlevel.")
		service_at_level = runOnShell(service_at_level).translate(string.maketrans("\n\t\r", "   "))
		if OsName.lower() == "ubuntu":
			service_at_level_repl = service_at_level.replace(" ",'')
			if len(service_at_level_repl) == len("rhnsd") and tokenMatchIC("rhnsd",service_at_level):
				logging("Red Hat Network Service (rhnsd) is off at all runlevel.")
				return True
			if "on" in service_at_level_repl:
				logging("Red Hat Network Service (rhnsd) is on at runlevel.")
				service_check_flag = False
		else:
			if not(tokenMatchIC("rhnsd 0:off 1:off 2:off 3:off 4:off 5:off 6:off", service_at_level)):
				service_check_flag = False

	      	if not service_check_flag:
			logging("Checking if the system is using RHN or RHN Satellite.")
			check_rhn_satellite = runOnShell('rhn_check -v')
			if check_rhn_satellite == "":
				logging("System is using RHN or an RHN Satellite, hence need manual intervention to fix this.")
				return None
			else:
				logging("System is not using RHN or an RHN Satellite.")
				return False

	return True


def fixRule38478():
	if (( OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
            runOnShell("systemctl disable rhnsd.service; systemctl stop rhnsd.service")
	else:
	    logging("Disabling the rhnsd service at all runlevel and in current session")
	    if OsName.lower() == "ubuntu":
            	runOnShell('sysv-rc-conf --level 0123456S rhnsd off; service rhnsd stop')
	    else:
            	runOnShell('chkconfig --level 0123456 rhnsd off')
		if "stopped" not in runOnShell('service rhnsd status'):
			runOnShell('service rhnsd stop')


#ASG:Made the necessary code changes to fetch element's value
#and validate the rule based on element's value.
def checkRule38479():
	if not os.path.exists('/etc/login.defs'):
		logging("The file /etc/login.defs sets the maximum password age for users, but this file does not exist. Please fix this manually.")
		return None

	logging("Checking if maximum age of password is configured correctly for all user.")
	res = runOnShell('grep -w PASS_MAX_DAYS /etc/login.defs | grep -v "^#"')
	res = res.translate(string.maketrans("\n\t\r", "   "))
	if not res:
		logging("The maximum age of password is not defined.")
		return False
	res = res.split()
	if len(res) != 2:
		logging("The maximum age of password is either not defined or not configured correctly for all users.")
		return False
	try:
		if int(res[1]) <= PASS_MAX_DAYS and int(res[1]) > 0:
			if CheckPasswdAge(int(res[1]), "Maximum number of days between password change"):
				logging("The maximum age of password is configured correctly for all users.")
				return True
			else:
				logging("The maximum age of password is not configured correctly for all users.")
				return False
		else:
			logging("The maximum age of password is not configured correctly for all users.")
			return False
	except (ValueError, IndexError):
		logging("The maximum age of password is not configured correctly for all users.")
		return False

def fixRule38479():
    if not os.path.exists('/etc/login.defs'):
        logging("The file /etc/login.defs sets the maximum password age for users, but this file does not exist. Please fix this manually.")
        return None

    res = runOnShell('grep -w PASS_MAX_DAYS /etc/login.defs | grep -v "^#"')
    res = res.translate(string.maketrans("\n\t\r", "   "))
    res = res.split()

    # Fix PASS_MAX_DAYS only if it is not configured correctly, other wise just apply changes in /etc/login.defs for existing users.
    if len(res) != 2 or not(res[1].isdigit()) or int(res[1]) > PASS_MAX_DAYS or int(res[1]) <= 0:
        lastLine = ""
        changeline = ""
        flag_pass_max_days = False
        fileSplit = open("/etc/login.defs").readlines()
        logging("Updating the maximum age of password.")
        for line in fileSplit:
            if isL(line) and "PASS_MAX_DAYS" in line:
                # Preventing multiple entries of 'PASS_MAX_DAYS' written to file '/etc/login.defs'.
                if not (flag_pass_max_days):
	            if not tokenMatch("Cloud Raxak updated next line",lastLine):
                        changeline += "# Cloud Raxak updated next line\n"
                    changeline += "PASS_MAX_DAYS\t"+str(PASS_MAX_DAYS)+"\n"
                    flag_pass_max_days = True
            else:
                changeline += line
                lastLine=line
        if not(flag_pass_max_days):
            logging("Adding the maximum age of password.")
            if not tokenMatch("Cloud Raxak updated next line",lastLine):
                changeline += "# Cloud Raxak updated next line\n"
            changeline += "PASS_MAX_DAYS\t"+str(PASS_MAX_DAYS)+"\n"
        fout = None
        try:
            fout = open('/etc/login.defs', "w")
            fout.write(changeline)
        finally:
            if (fout is not None):
                fout.close()

    runOnShell('pwunconv;pwconv')

    # Fix the password expiration of the Raxak Protect userid to not expire
    runOnShell('chage -M -1 ' + username)
    runOnShell('chage -l ' + username)

def checkRule38480():
        if os.path.exists('/etc/login.defs'):
		logging("Checking for no of days prior to password expiration.")
                pass_warn = runOnShell('grep -w PASS_WARN_AGE /etc/login.defs | grep -v "^#" | awk -F" " \'{ print $2 }\'')
                pass_max = runOnShell('grep -w PASS_MAX_DAYS /etc/login.defs | grep -v "^#" | awk -F" " \'{ print $2 }\'')
		try:
			pass_max = int(pass_max)
			if pass_max <= 0:
				logging("The maximum password age for all users is not configured correctly. Please remediate rule V-38479 first.")
				return None
			else:
				pass
		except ValueError:
			logging("The maximum age of password is either not defined or not configured correctly for all users. Please remediate rule V-38479 first.")
			return None
		try:
			pass_warn = int(pass_warn)
		except ValueError:
			logging("The password warning age is either not defined or not configured correctly for all users.")
			return False
		if pass_max > PASS_WARN_AGE:
			if pass_warn >= PASS_WARN_AGE and pass_warn <= pass_max:
				if CheckPasswdAge(pass_warn, "Number of days of warning before password expires"):
					logging("The password warning age is configured correctly for all users.")
					return True
				else:
					logging("The password warning age is not configured correctly for all users.")
					return False
			else:
				logging("The password warning age is not configured correctly for all users.")
				return False
		else:
			if pass_warn <= pass_max:
				if CheckPasswdAge(pass_warn, "Number of days of warning before password expires"):
					logging("The password warning age is configured correctly.")
					return True
				else:
					logging("The password warning age is not configured correctly for all users.")
					return False
			else:
				logging("The password warning age is not configured correctly for all users.")
				return False
	else:
		logging("The file /etc/login.defs sets the warning age of password for users, but the file does not exist. Please fix this manually.")
		return None

def fixRule38480():
	if not os.path.exists('/etc/login.defs'):
		logging("The file /etc/login.defs sets the warning age of password for users, but the file does not exist. Please fix this manually.")
		return None
        lastLine = ""
        string_write = ""
        flag = False
	count_line = 0
        fileSplit = open("/etc/login.defs").readlines()
	pass_max = runOnShell('grep -w PASS_MAX_DAYS /etc/login.defs | grep -v "^#" | awk -F" " \'{ print $2 }\'')
	try:
		pass_max = int(pass_max)
		if pass_max <= 0:
			logging("The maximum password age for all users is not configured correctly. Please remediate rule V-38479 first.")
			return None
		else:
			pass
	except ValueError:
		logging("The maximum age of password is either not defined or not configured correctly for all users. Please remediate rule V-38479 first.")
		return None

	pass_warn = runOnShell('grep -w PASS_WARN_AGE /etc/login.defs | grep -v "^#"')
	pass_warn = pass_warn.split()
	if len(pass_warn) != 2 or not(pass_warn[1].isdigit()) or int(pass_warn[1]) < PASS_WARN_AGE or int(pass_warn[1]) > pass_max:
		for line in fileSplit:
		    if isL(line) and "PASS_WARN_AGE" in line:
			if not flag:
				logging("Updating the password warning age.")
				if not tokenMatch("Cloud Raxak updated next line", lastLine):
					string_write += "# Cloud Raxak updated next line\n"
				if pass_max > PASS_WARN_AGE:
					string_write += "PASS_WARN_AGE\t"+str(PASS_WARN_AGE)+"\n"
				else:
					string_write += "PASS_WARN_AGE\t"+str(pass_max)+"\n"
				flag = True
		    else:
			string_write += line
			lastLine = line

		if not flag:
			logging("Adding the password warning age.")
			if not tokenMatch("Cloud Raxak updated next line",lastLine):
				string_write += "# Cloud Raxak updated next line\n"
			if pass_max > PASS_WARN_AGE:
				string_write += "PASS_WARN_AGE\t"+str(PASS_WARN_AGE)+"\n"
			else:
				string_write += "PASS_WARN_AGE\t"+str(pass_max)+"\n"

		fout = open("/etc/login.defs", "w")
		if fout != None:
			fout.write(string_write)
			fout.close()
		runOnShell('pwunconv;pwconv')
	else:
		runOnShell('pwunconv;pwconv')

def checkRule38481():
    returnFlag = False
    if (OsName.lower() == "ubuntu"):
        sysUpdateCommand = "/usr/lib/update-notifier/apt-check -p"
        logMessage = "apt-get update; apt-get upgrade <individual-pkg>"
        runOnShell("/usr/lib/update-notifier/apt-check -p 2> /tmp/test.txt", False)
        systemUpdatePackages = runOnShell("cat /tmp/test.txt", False)

        if systemUpdatePackages.strip() == "":
            returnFlag = True
    else:
        sysUpdateCommand = "yum check-update"
        sysUpdateCheck = runOnShell("yum check-update > /tmp/test.txt 2>&1; echo $?", False)
        logMessage = "yum update"
        systemUpdatePackages = runOnShell("cat /tmp/test.txt", False)

        if systemUpdatePackages.strip() == "0":
            returnFlag = True

    # Handling all types of system related errors, and showing the exact error message on the console.
    if "error:" in systemUpdatePackages.lower():
        sysUpdateCheck = systemUpdatePackages.splitlines()
        showSystemError = filter(lambda errorEle: "error" in errorEle.lower(), sysUpdateCheck)
        logging("The system has the below issue. Please fix it manually.\n" + "".join(showSystemError))
        return None

    # Removing the temp log file.
    runOnShell("rm /tmp/test.txt", False)

    if returnFlag:
        logging ("System security patches and updates are up-to-date.")
        return True
    else:
        logging ("System security patches and updates are not up-to-date. Please use '" + logMessage + "' to update the system patches. \
Please refer the command '" + sysUpdateCommand + "' to get the affected packages. Please fix it manually.")
        return None

def fixRule38481():
    logging("At present, We are not providing fix for this rule because our fix solution will effect the user's software verisons which will be upgraded/updated. So, recommending user to execute this rule manually.")
    return None

    """
        # I am not removing this part of code as it will be useful in the future.
	global g_rule38481FailAndMnual
	if (OsName.lower() == "ubuntu"):
	    #For effecting check rule
	    g_rule38481FailAndMnual = True

	    logging ("Checking if apt-get command is installed on the system.")
	    checkAPT_GETAndInstall()
	    logging ("Updating all packages on the system.")
	    updatesRes = runOnShell ("apt-get update > /dev/null")
	    if "dpkg was interrupted" in updatesRes:
		logging ("Since there is a problem with dpkg, not able to update the system packages. \
Execute manually 'dpkg --configure -a' command to properly configuring dpkg.")
		return None
	    elif "Resource temporarily unavailable" in updatesRes:
		logging ("The apt-get is temporarily unavailable on the system. Hence, need manual intervention to fix.")
		return None
	    else:
		pass

	    #Redirecting the output to /dev/null to avoid GUI screen 
	    #while executing the below command
	    logging ("Listing the packages which are need to be upgraded.")
	    res = runOnShell ("/usr/lib/update-notifier/apt-check -p").split('\n')
	    logging ("Upgrading packages which are need to be upgraded.")
	    for package in res[:-1]:
		if "Error" in package:
		    continue
		runOnShell("apt-get -y upgrade {0} > /dev/null".format(package))
	else:
	    logging ("Upgrading the system.")
            runOnShell("yum -y update")
    """

def checkRule38482(min_val=-1):
	qualityCheck = False # flag to check if dcredit exist in pwquality.conf
	grepModule = "pam_cracklib.so"
        if OsName.lower() == "ubuntu":
	    if not CheckPackage("libpam-cracklib"):
		return False
            filePath = "/etc/pam.d/common-password"
        else:
            filePath = "/etc/pam.d/system-auth"
            if OsVersion >= (7,0):
                grepModule = 'pam_pwquality.so'
		# Checking the dcredit in the /etc/security/pwquality.conf file
		logging("Checking for how many digits are required in a password in the password quality \
configuration file.")
		checkPwQuality = runOnShell('grep -w dcredit /etc/security/pwquality.conf | grep -v "^#"')
		checkDigit = re.match(r'.*\s*(\bdcredit\s*=\s*-?\d\b)\s*', checkPwQuality)
	        if checkDigit != None:
	            parameter = checkDigit.group(1)
	            actualParamDigit,paramValueDigit =  parameter.split("=")
	            actualParamDigit = actualParamDigit.replace(" ","")
	            paramValueDigit = paramValueDigit.replace(" ","")
	            qualityCheck = True

	logging("Checking for how many digits are required in a password, the DoD requires at least one digit in a password.")
	checkResult = runOnShell('grep -w '+ grepModule + " " + filePath +' | grep -w requisite | grep -v "^#"')
	checkResult = checkResult.translate(string.maketrans("\n\t\r", "   ")).strip()
	matchObj = re.match(r'.*\s*(\bdcredit=-?\w*\b)\s*', checkResult)
	if matchObj:
	    parameter = matchObj.group(1)
	    actualParam,paramValue =  parameter.split("=")
	    if paramValue != "":
		try:
		    validValue = False
		    if qualityCheck:
			if int(paramValue) <= min_val and int(paramValue) <= int(paramValueDigit):
				validValue = True
		    else:
			if int(paramValue) <= min_val:
				validValue = True
		    if validValue:
		    	logging("The minimum digits requirement in a password is configured correctly.")
			return True
		except:
		    logging("The minimum digits required in a password is not specified correctly.")
		    return False
	logging("The parameter for minimum digits is not specified correctly.")
	return False

def fixRule38482(min_val=-1):
	paramValue = -1
	qualityCheck = False # flag to check if dcredit exist in pwquality.conf
	grepModule = 'pam_cracklib.so'
	if OsName.lower() == "ubuntu":
	    if not CheckPackage("libpam-cracklib"):
                InstallPackage("libpam-cracklib")
	    filePath = "/etc/pam.d/common-password"
	else:
	    filePath = "/etc/pam.d/system-auth"
            if OsVersion >= (7,0):
                grepModule = 'pam_pwquality.so'
		checkPwQuality = runOnShell('grep -w dcredit /etc/security/pwquality.conf | grep -v "^#"')
		checkDigit = re.match(r'.*\s*(\bdcredit\s*=\s*-?\d\b)\s*', checkPwQuality)
		if checkDigit != None:
		    parameter = checkDigit.group(1)
		    actualParamDigit,paramValueDigit =  parameter.split("=")
		    actualParamDigit = actualParamDigit.replace(" ","")
		    paramValueDigit = paramValueDigit.replace(" ","")
		    qualityCheck = True
	checkResult = runOnShell('grep -w '+ grepModule + " " + filePath +' | grep -w requisite | grep -v "^#"')
	with open(filePath, "r") as file_content:
            fileString = ""
	    lastLine = ""
	    logging("Updating the digits requirement in a password, the DoD requires at least one digit in a password.")
            for line in file_content:
	        updateValue = False
		moduleSearchObj = re.search('^password\s*requisite\s*'+ grepModule,line,re.M|re.I)
		if moduleSearchObj != None and checkResult != "":
			checkValue = False
			if isL(line) and "dcredit" in line:
			    line = line.translate(string.maketrans("\n\t\r", "   ")).strip()
			    matchObjs = re.match(r'.*\s*(\bdcredit=-?\w\b)\s*', checkResult)
			    resultTranslate = checkResult.translate(string.maketrans("\n\t\r", "   "))
			    if tokenMatchIC("dcredit", resultTranslate) or tokenMatchIC("dcredit=", resultTranslate):
				checkValue = True
			    elif matchObjs != None:
				parameter = matchObjs.group(1)
				actualParam,paramValue =  parameter.split("=")
				try:
				    if qualityCheck:
					if int(paramValue) > int(paramValueDigit):
						checkValue = True
				    elif (int(paramValue) > min_val):
						checkValue = True
				    else:
					pass
				except:
				    checkValue = True
			    else:
				updateValue = True
			else:
			    updateValue = True
			if qualityCheck:
			    if int(paramValue) > int(paramValueDigit):
				newValue = paramValueDigit
			    else:
				newValue = paramValue
			else:
				newValue = min_val
			if checkValue:
			    start = line.index("dcredit")
			    new = line[start:]
			    try:
			        end = new.index(" ")
			        line = line[0:start] + "dcredit="+str(newValue) + line[start+end:]
			    except:
			        end = 10
			        line = line[0:start] + "dcredit="+str(newValue) + line[start+end:len(line[start:])]

			if updateValue:
			    line = line.translate(string.maketrans("\n", " ")).strip()
			    line = line+' dcredit='+str(newValue)
			if "Cloud Raxak updated next line" not in lastLine:
                            fileString += "# Cloud Raxak updated next line\n"
			fileString += line + '\n'
		elif checkResult == "":
		    if OsName.lower() == "ubuntu":
		        if re.search('^password\s*\[success\=1\sdefault=ignore\]\s*pam_unix.so', line):
                            if "Cloud Raxak updated next line" not in lastLine:
                                fileString += "# Cloud Raxak updated next line\n"
		            fileString += "password       requisite       pam_cracklib.so dcredit=-1\n"
	    	    else:
		        if re.search('^password\s*sufficient\s*pam_unix.so',line):
                            if "Cloud Raxak updated next line" not in lastLine:
                                fileString += "# Cloud Raxak updated next line\n"
			    if qualityCheck:
				if (int(paramValueDigit)) < min_val:
					fileString += "password     requisite     "+ grepModule + " dcredit="+paramValueDigit +"\n"
				else:
					fileString += "password     requisite     "+ grepModule + " dcredit=-1\n"
			    else:
				fileString += "password     requisite     "+ grepModule + " dcredit=-1\n"
		    fileString += line
		else:
		    fileString += line
		lastLine = line
	fout = None
        fout = open(filePath, 'wt')
        if fout != None:
            fout.write(fileString)
            fout.close()

def checkRule38483():
	if OsName.lower() == 'ubuntu':
	    logging("Checking if /etc/apt directory exists.")
	    if os.path.isdir("/etc/apt/"):
		logging("Checking if the Unauthenticated package(s) are allowed for installation in the system.")
		result = runOnShell('grep -rwi AllowUnauthenticated /etc/apt/* | grep -v ":\s*#"')
		if result != "":
                        logging("Unauthenticated package(s) are allowed for installation. Hence authenticity of \
system software packages during installation will not be cryptographically verified.")
			return False
		logging("Unauthenticated package(s) are not allowed for installation. Hence authenticity of \
system software packages during installation will be cryptographically verified.") 
		return True
	    else:
		logging("The unauthenticated package(s) cryptographic signatures directory does not exist. \
Please fix it manually.")
		return None
	else:
	    logging("Checking if System Package Management tool is configured for verifying the authenticity of \
system software packages during installation.")
            gpgCheck = runOnShell('grep -w gpgcheck /etc/yum.conf | grep -v "^#"')
	    flag = False
	    with open("/etc/yum.conf", "r") as fileContent:
		for line in fileContent:
			matchObj = re.match(r'.*(\[.*\])',line)
			if matchObj != None:
				if tokenMatchIC("[main]", matchObj.group(1)):
					flag = True
				else:
					flag = False
			if flag:
				if "gpgcheck" in line and isL(line):
					gpgCheckSplit = gpgCheck.splitlines()
					for element in gpgCheckSplit:
					    if keyValEqMatch("gpgcheck", '1', element):
						logging("System Package Management tool is configured for \
verifying the authenticity of system software packages during installation.")
						return True
	logging("System Package Management tool is not configured in the [main] section for verifying the \
authenticity of system software packages during installation.")
	return False

def fixRule38483():
    if OsName.lower() == 'ubuntu':
	if os.path.isdir("/etc/apt/"):
	    result = runOnShell('grep -rwi AllowUnauthenticated /etc/apt/* | grep -v ":\s*#"')
	    result = result.splitlines()
	    for line in result:
		resultFile = line.split(":")[0]
		if os.path.exists(resultFile) == True:
		    with open(resultFile, "r") as fileData:
			fileString = ""
			logging("Removing the unauthenticated entries from the /etc/apt/ directory.")
                        for line in fileData:
			    if "AllowUnauthenticated" in line:
				continue
			    else:
				fileString += line
		    fout = None
		    try:
		        fout = open(resultFile, "wt")
		        fout.write(fileString)
		    finally:
		        if (fout is not None):
		    	    fout.close()
        else:
	    logging("The unauthenticated package(s) cryptographic signatures directory does not exist. Please fix it manually.")
            return None
    else:
		res = runOnShell('grep -w gpgcheck /etc/yum.conf | grep -v "^#"')
		if os.path.exists('/etc/yum.conf'):
			fileString = ""
	    		with open("/etc/yum.conf", "r") as fileContent:
				for line in fileContent:
				    if "gpgcheck" in line:
					continue
				    elif re.search('^\[main\]\s',line,re.M|re.I):
					logging("Updating the gpgcheck system settings, for verifying the authenticity of system software packages during installation.")
					fileString += line +"gpgcheck=1\n"
					continue
				    fileString += line
			fout = None
		        try:
				fout = open("/etc/yum.conf", "wt")
				fout.write(fileString)
		        finally:
		                if (fout is not None):
		                    fout.close()

def checkRule38484():
	#Checking ssh configuration file validity
	#If there are any errors, not restarting ssh
	if checkSSHDSyntax() == None:
	    return None

        #ASG: Search the word PrintLastLog and ignore the line that begins with "#"
	logging("Checking whether the operating system displays date and time of last successful logon or access via ssh.")
        res = runOnShell('grep -iw PrintLastLog /etc/ssh/sshd_config | grep -v "^#"')
        if not res:
            #ASG - As per my observation if no PrintLastLog configured
	    #then by default it displays the last logon user's information.
	    logging("The operating system is configured to display successful logon message to the user for date and time of the last\
 logon or access via ssh, since the default action for the SSH daemon is to print the last logon date and time.")
            return True
        else:
            if "yes" in res.lower():
		logging("The operating system is configured to display successful logon message to the user for date and time of the last\
 logon or access via ssh.")
                return True
            else:
		logging("The operating system is not configured to display successful logon message to the user for date and time of the\
 last logon or access via ssh.")
                return False

def fixRule38484():
	if checkSSHDSyntax() == None:
            return None

	lastLine = ""
	s = ""
	flag = False

	fileSplit = open("/etc/ssh/sshd_config").readlines()
	logging("Updating settings for displaying date and time of last successful logon.")
	for line in fileSplit:
	    if isL(line) and tokenMatchIC("PrintLastLog", line):
	        if not tokenMatch("Cloud Raxak updated next line",lastLine):
	            s += "# Cloud Raxak updated next line\n"
	        s += "PrintLastLog yes\n"
	        flag = True
	    else:
	        s += line
	        lastLine=line
	if not(flag):
	    logging("Adding settings for displaying date and time of last successful logon.")
	    s += "\n# Cloud Raxak updated next line\n"
	    s += "PrintLastLog yes\n"
	fout = None
	try:
	    fout = open("/etc/ssh/sshd_config", 'w')
	    fout.write(s)
	finally:
	    if fout is not None:
	        fout.close()

	#Enabling ssh service and run leves
	RunService("ssh")

def checkRule38485():
	updated_list = []
	#check flag for the hushlogins in the /etc directory.
	flag = False
	if os.path.exists('/etc/hushlogins'):
		flag = True
	if os.path.exists('/root/.hushlogin'):
		updated_list.append('root')
	logging("Checking 'hushlogin' file inside users home directory.")
        uid_min = runOnShell('awk \'{ if($1 == "UID_MIN") print $2;}\' /etc/login.defs')
        uid_max = runOnShell('awk \'{ if($1 == "UID_MAX") print $2;}\' /etc/login.defs')

	user_list_cmd = 'awk -F\':\' -v "min='+uid_min.strip()+'" -v "max='+uid_max.strip()+'" \'{ if ( $3 >= min && $3 <= max ) print $1}\' /etc/passwd'
	user_list_cmd_result = runOnShell(user_list_cmd)
	user_list = filter(None,user_list_cmd_result.split("\n"))
	if(user_list):
		for user in user_list:
			user_path = os.path.expanduser("~%s/.hushlogin" % user)
			if os.path.exists(user_path):
				updated_list.append(user)
				continue
	if len(updated_list) != 0 and flag:
		user_list = ','.join(updated_list)
	    	logging ("There is 'hushlogin' file active on the system under /etc folder, following list of user have .hushlogin file under their home directory: " + "'" + user_list + "'")
		return False
	elif len(updated_list) != 0:
		user_list = ','.join(updated_list)
	    	logging ("There are 'hushlogin' files in user's home directory, following list of user have .hushlogin file under their home directory: " + "'" + user_list + "'")
		return False
	elif flag:
		logging("There is 'hushlogins' file active inside /etc directory." )
		return False
	
	logging("There is no 'hushlogins' file active inside /etc directory and no '.hushlogin' files in user's home directory.")
	return True

def fixRule38485():
	logging("Removing all 'hushlogin' active files from the system")
	if os.path.exists( '/etc/hushlogins'):
		runOnShell("rm -f /etc/hushlogins")
	if os.path.exists( '/root/.hushlogin'):
		runOnShell("rm -f /root/.hushlogin")
        uid_min = runOnShell('awk \'{ if($1 == "UID_MIN") print $2;}\' /etc/login.defs')
        uid_max = runOnShell('awk \'{ if($1 == "UID_MAX") print $2;}\' /etc/login.defs')

	user_list_cmd = 'awk -F\':\' -v "min='+uid_min.strip()+'" -v "max='+uid_max.strip()+'" \'{ if ( $3 >= min && $3 <= max ) print $1}\' /etc/passwd'
	user_list_cmd_result = runOnShell(user_list_cmd)
	user_list = filter(None,user_list_cmd_result.split("\n"))
	if(user_list):
		for user in user_list:
			user_path = os.path.expanduser("~%s/.hushlogin" % user)
			if os.path.exists(user_path):
				list_user_path = runOnShell("ls -l ~%s/.hushlogin" % user)
				if not(list_user_path == "" or tokenMatchIC("No such file", list_user_path)):
					runOnShell("rm -f ~%s/.hushlogin" % user)

def checkRule38486():
	logging("Please ask an administrator if a process exists to backup OS data from the system, including configuration data.\nThe operating system provides utilities for automating such a process. Please manually schedule a process to backup OS data of the system.")
	return None


def fixRule38486():
	logging("Schedule a process wherein OS data is backed up from the system in accordance with local policies.")
	return None


# Note os.listdir does not return a fully qualified filename (PGM)
def checkRule38487():
	if OsName.lower() == 'ubuntu':
	    logging("Checking if /etc/apt directory exists.")
	    if os.path.isdir("/etc/apt/"):
		logging("Checking if the Unauthenticated package(s) are allowed for installation in the system.")
		result = runOnShell('grep -rwi AllowUnauthenticated /etc/apt/* | grep -v ":\s*#"')
		if result != "":
			logging("Unauthenticated package(s) are allowed for installation. Hence authenticity of all \
software packages during installation will not be cryptographically verified.")
			return False
	    else:
		logging("The unauthenticated package(s) cryptographic signatures directory does not exist. Please fix it manually.")
		return None
	else:
		logging("Checking if the Unauthenticated package(s) are allowed for installation in the system.")
		flag = True
		for filename in os.listdir('/etc/yum.repos.d/'):
			if not filename.startswith('.'):
				with open('/etc/yum.repos.d/' + filename, "r") as data:
					for line in data:
						if isL(line) and "gpgcheck" in line:
							if not(re.search(r'.*\s*(\bgpgcheck\s*=\s*1\b)\s*', line)):
								flag = False
						else:
							continue
		if not flag:
			logging("The authenticity of all software packages during installation will not be cryptographically verified.")
			return flag
	logging("Unauthenticated package(s) are not allowed for installation. Hence authenticity of all \
software packages during installation will be cryptographically verified.") 
	return True

def fixRule38487():
    if OsName.lower() == 'ubuntu':
        if os.path.isdir("/etc/apt/"):
	    result = runOnShell('grep -rwi AllowUnauthenticated /etc/apt/* | grep -v ":\s*#"')
	    result = result.splitlines()
	    for line in result:
		resultFile = line.split(":")[0]
		if os.path.exists(resultFile) == True:
		    with open(resultFile, "r") as file_data:
			fileString = ""
			logging("Removing the unauthenticated entries from the /etc/apt/ directory.")
            	        for line in file_data:
			    if "AllowUnauthenticated" in line:
				continue;
			    else:
				fileString += line
			fout = None
			try:
			    fout = open(resultFile, "wt")
			    fout.write(fileString)
			finally:
			    if (fout is not None):
				fout.close()
        else:
            logging("The unauthenticated package(s) cryptographic signatures directory does not exist.\
 Please fix it manually.")
            return None
    else:
		logging("Removing the unauthenticated entries from the /etc/yum.repos.d directory.")
		for filename in os.listdir('/etc/yum.repos.d/'):
			with open('/etc/yum.repos.d/' + filename, "r") as f:
				fileString = ""
				for line in f:
					if isL(line) and "gpgcheck" in line:
						if not re.search(r'.*\s*(\bgpgcheck\s*=\s*1\b)\s*', line):
							fileString += "gpgcheck=1\n"
							continue
					else:
						fileString += line
				fout = None
				try:
					fout = open('/etc/yum.repos.d/' + filename, "wt")
					fout.write(fileString)
				finally:
					if (fout is not None):
						fout.close()

def checkRule38488():
	logging("Please ask an administrator to manually schedule backup policy as per organisation requirement, since the OS must backup user-level information periodically for recover point objectives.")
	return None


def fixRule38488():
	logging("The operating system must conduct backups of user-level information contained in the operating system as per organization defined frequency to conduct backups consistent with recovery time and recovery point objectives. Procedures to back up user data from the system must be established and executed.")
	return None

def checkRule38489():
    if not CheckPackage ("aide"):
        return False

    return True

def fixRule38489():
    ''' Purpose: It will install aide package. '''

    if not InstallPackage ("aide"):
        return None

def checkRule38490():
	logging('Checking if the system is configured to prevent the loading of the "usb-storage" kernel module.')
	# check for any entry for module blocking in /etc/modprobe.conf and modprobe.d directory.
	cmd = 'grep -wr usb-storage /etc/modprobe.conf /etc/modprobe.d | grep -v "#"'
	if not os.path.exists('/etc/modprobe.conf'):
	     logging("modprobe.conf file does not exists on system.")
	     cmd = 'grep -wr usb-storage /etc/modprobe.d | grep -v "#"'
	grep_usb_block_module = runOnShell(cmd)
	usb_block_module_list = grep_usb_block_module.split("\n")
	#iterate all grep entries for different files.
	for usb_block_module in usb_block_module_list:
	     # Checking for usb_storage module present in grep result.
	     if re.match(r'.*\s*(\busb-storage\b)\s*', usb_block_module):
		  blacklist_usb = usb_block_module.split(":")[1]
		  blacklist_usb = blacklist_usb.replace(" ","")
		  if (blacklist_usb == "installusb-storage/bin/false") or (blacklist_usb == "installusb-storage/bin/true") or (blacklist_usb == "blacklistusb-storage"):
		      logging("Checking whether 'usb-storage' kernel module is active.")
		      res = runOnShell("lsmod | grep usb_storage")
	              if re.match(r'.*\s*(\busb_storage\b)\s*', res):
		          logging("Remove the 'usb_storage' kernel module or reboot the system to disable 'usb_storage' kernel module.")
		          return None
		      else:
		          logging("System is configured properly to prevent loading of 'usb-storage' kernel module.")
		          return True
	logging("Configuration to prevent loading of 'usb-storage' kernel module was not found.")
	return False

def fixRule38490():
            if OsName.lower() == "ubuntu":
                 addLine = "blacklist uas\n"
                 addline1 = "blacklist usb-storage\n"
                 filePath = "/etc/modprobe.d/blacklist.conf"
            else:
                 addLine = "install usb-storage /bin/true\n"
                 filePath = "/etc/modprobe.d/cloudraxak.conf"
            logging("Checking if the system is configured to prevent the loading of the 'usb-storage' kernel module.")

            if os.path.exists(filePath):
                file_content = open(filePath, "r+")
            else:
                file_content = open(filePath, "w+")
            flag = False
            newLine = ""
            lastLine = ""
            for line in file_content:
                if isL(line) and "usb-storage" in line:
                    if not tokenMatch('Cloud Raxak updated next line',lastLine):
                        newLine += "# Cloud Raxak updated next line\n"
                    newLine += addLine
                    if OsName.lower() == "ubuntu":
                        newLine += addline1
                    flag = True
                else:
                    newLine += line
                    lastLine = line
            if not(flag):
                newLine += "# Cloud Raxak updated next line\n"
                newLine += addLine
                if OsName.lower() == "ubuntu":
                        newLine += addline1
            fout = None
            try:
                fout = open(filePath, 'wt')
                fout.write(newLine)
            finally:
                if fout is not None:
                    fout.close()
            logging("Preventing USB storage devices from being used.")
            runOnShell("rmmod uas")
            runOnShell("rmmod usb-storage")

def checkRule38491():
	logging("Checking .rhosts and hosts.equiv files on system.")
	res = runOnShell('find /root /home -iname ".rhosts" -type f')
	res1 = runOnShell('find /etc -iname "hosts.equiv" -type f')
	if res !="" or res1 !="":
	    logging("File '/etc/hosts.equiv' or file named '.rhosts' exists on system. Please delete the file '/etc/hosts.equiv' and '.rhosts' file from the system.")
	    return False
	logging("File '/etc/hosts.equiv' or file named '.rhosts' does not exist on system.")
	return True

def fixRule38491():
            logging("Deleting file 'hosts.equiv' and '.rhosts' from the system.")
            runOnShell('find /root /home -iname ".rhosts" -type f | xargs rm {} 2>/dev/null')
            runOnShell('find /etc -iname "hosts.equiv" -type f | xargs rm {} 2>/dev/null')

def checkRule38492():
    if not os.path.exists("/etc/securetty"):
	logging ("Since virtual console entry file path is not available, need manual intervention to fix.")
	return None

    logging ("Checking virtual console entry in /etc/securetty file.")
    #res = runOnShell("egrep '^tty[0-9]$|^vc/[0-9]' /etc/securetty | grep -v '^#'")
    res = runOnShell("grep '^vc/[0-9]' /etc/securetty | grep -v '^#'")

    if res == "":
	logging ("There are no deprecated virtual entries in /etc/securetty file.")
	return True
    else:
	logging ("There are deprecated virtual entries in /etc/securetty file.")
	return False

def fixRule38492():
    logging ("Removing all deprecated virtual console entries from /etc/securetty file to prevent the root account from \
logging in from virtual consoles.")
    #runOnShell("sed -i '/^tty[0-9]$/d; /vc/d ' /etc/securetty")
    runOnShell("sed -i '/vc/d' /etc/securetty")

def checkRule38493(val=755):
	if os.path.exists('/etc/audit/auditd.conf'):
		audit_log_dir = runOnShell('grep "^log_file" /etc/audit/auditd.conf|sed \'s/^[^/]*//; s/[^/]*$//\'')
		audit_log_dir = audit_log_dir.strip("\n")
		if os.path.exists(audit_log_dir) == False:
			logging("Audit log directory does not exist.")
			return True
	else:
		logging("Audit configuration file does not exist.")
		return True

	logging("Checking the mode of the system audit directories.")
	res = runOnShell('grep "^log_file" /etc/audit/auditd.conf|sed \'s/^[^/]*//; s/[^/]*$//\'|xargs stat -c %a')
	try:
		tmpOct = int(res,8)
		for line in res.splitlines():
			# 07022 is an octal number which binary ands with tmpOct, it's result is used to decide if permissions are set correctly or not.
                        # why 7022? Because when 7022 converted to binary gives 111 000 010 010
                        # Linux file permissions                                ugs      w   w     u=set uid , g=set gid, s=set sticky bit
                        # permsissions above are the ones which we don't want the owner,group and others to have.
			if tmpOct & 07022:
				logging("Permissions of audit log directory are not configured properly.")
				return False
	except Exception as err:
		logging("Audit is not configured properly. Please configure audit manually.")
		return None
	logging("Audit log directory permissions are configured properly.")
	return True

def fixRule38493():
        if not InstallPackage("audit"):
            return None

	res = runOnShell('grep "^log_file" /etc/audit/auditd.conf|sed \'s/^[^/]*//; s/[^/]*$//\'|xargs stat -c %n')
	#if log_file have worng parameter then above command will give error message.
	if "Error" in res:
		logging("Audit is not configured properly. Please configure audit manually.")
		return None
	for line in res.split("\n"):
		if not line == "":
			logging("Changing the mode of the audit log directories.")
			runOnShell('chmod ugo-t %s' % line)
			runOnShell('chmod ugo-s %s' % line)
			runOnShell('chmod go-w %s' % line)

def checkRule38494():
    logging ("Checking serial console entry in /etc/securetty file.")
    res =  runOnShell("grep '^ttyS[0-9]' /etc/securetty")
    if res == "":
	logging ("The system will prevent the root login from serial consoles.")
        return True
    else:
	logging ("The system will allow the root login from serial consoles.")
	return False

def fixRule38494():
    logging ("Removing serial console entries from /etc/securetty file to prevent the root account from logging in from serial consoles.")
    runOnShell("sed -i '/ttyS/d' /etc/securetty")

def fixRule29():
        runOnShell('awk -F: \'{print $1 ":" $2}\' /etc/shadow')

def checkRule38495():
	if os.path.exists('/etc/audit/auditd.conf'):
		check_auditd_file = runOnShell("sed -ie 's/^[ \t]*//;s/[ \t]*=/ =/;s/=[ \t]*/= /' /etc/audit/auditd.conf")
		audit_log_file = runOnShell('grep "^log_file" /etc/audit/auditd.conf|sed s/^[^\/]*//')
		audit_log_file = audit_log_file.strip("\n")
		if os.path.exists(audit_log_file) == False:
			logging("Audit log file does not exist.")
			return True
		logging("Checking the owner of the system audit logs file(s).")
		audit_res = runOnShell('find '+ audit_log_file +'* -type f |sed s/^[^\/]*//|xargs stat -c %U:%n 2>/dev/null')
	        for owner in audit_res.split("\n"):
	            if owner != '':
			owner = owner.split(":")[0]
	                if not(strcmp(owner, "root")):
			    logging("Audit log file is not owned by root.")
	                    return False
		logging("Audit log file(s) is owned by root.")
	        return True
	else:
		logging("Audit configuration file does not exist.")
		return True

def fixRule38495():
	check_auditd_file = runOnShell("sed -ie 's/^[ \t]*//;s/[ \t]*=/ =/;s/=[ \t]*/= /' /etc/audit/auditd.conf")
	audit_log_file = runOnShell('grep "^log_file" /etc/audit/auditd.conf|sed s/^[^\/]*//')
	audit_log_file = audit_log_file.strip("\n")
	if os.path.exists(audit_log_file):
		audit_res = runOnShell('find '+ audit_log_file +'* -type f |sed s/^[^\/]*//|xargs stat -c %U:%n 2>/dev/null')
		logging("Changing the owner of the system Audit logs file(s).")
	        for owner_path in audit_res.split("\n")[:-1]:
			owner = owner_path.split(":")[0]
	                if not(strcmp(owner, "root")):
				runOnShell('chown root %s' % owner_path.split(":")[1])


def checkRule38496():
	# Getting the UID_MIN value from  /etc/login.defs file.
	uidMin = runOnShell('awk \'{ if($1 == "UID_MIN") print $2;}\' /etc/login.defs', False).strip()
	usersinPasswd = runOnShell("awk -F: '{print $1}' /etc/passwd", False).splitlines()
	userList = []

	for uname in usersinPasswd:
		uid = runOnShell("/usr/bin/id -u " + uname, False)

		try:
			if (1< int(uid) < int(uidMin)):
				# Checking if the syetem accounts are locked.
				if OsName.lower() == "ubuntu":
					lockPasswd = runOnShell("passwd -S " + uname + "|grep -v L", False)
				else:
					lockPasswd = runOnShell("passwd -S " + uname + "|grep -v LK", False)

				if lockPasswd:
					userList.append(uname)
		except (ValueError, TypeError):
			logging("The normal system users UID_MIN value is not in proper format in /etc/login.defs file, or invalid format of UID in password file. So check it manually.")
			return None

	unlockedAcc = ', '.join(userList)
	if unlockedAcc:
		logging("The system account(s) " + unlockedAcc + "  unlocked.")
		return False

	logging("Login access is disabled for all system account's other than root.")
	return True

def fixRule38496():
	# Getting the UID_MIN value from  /etc/login.defs file.
	uidMin = runOnShell('awk \'{ if($1 == "UID_MIN") print $2;}\' /etc/login.defs', False).strip()
	usersinPasswd = runOnShell("awk -F: '{print $1}' /etc/passwd", False).splitlines()

	for uname in usersinPasswd:
		# getting the UID based on username.
		uid = runOnShell("/usr/bin/id -u " + uname, False)
		try:
			if (1< int(uid) < int(uidMin)):
				# Checking if the system accounts are locked.
				if OsName.lower() == "ubuntu":
					lockPasswd = runOnShell("passwd -S " + uname + "|grep -v L", False)
				else:
					lockPasswd = runOnShell("passwd -S " + uname + "|grep -v LK", False)

				if lockPasswd:
					runOnShell("passwd -l " + uname)
		except (ValueError, TypeError):
			logging("The normal system users UID_MIN value is not in proper format in /etc/login.defs file, or invalid format of UID in /etc/passwd file. So check it manually.")
			return None


def checkRule38497():
	if OsName.lower() == "ubuntu":
	    logging("Checking that null passwords cannot be used.")
	    res = runOnShell('grep nullok /etc/pam.d/common-auth | grep -v "^#"')
	else:
	    logging("Checking that null passwords cannot be used.")
            res = runOnShell('grep nullok /etc/pam.d/system-auth | grep -v "^#"')
	if res == "":
	    logging("Null password is not in use.")
	    return True
	logging("Null password is in use, so need to remove the null password configuration for password authentication.")
	return False

def fixRule38497():
	if OsName.lower() == "ubuntu":
	    filePath = "/etc/pam.d/common-auth"
	else:
	    filePath = "/etc/pam.d/system-auth"
        with open(filePath, "r") as f:
            s = ""
	    logging("Removing null password setting.")
            for line in f:
		if isL(line) and "nullok_secure" in line:
		    s += line.replace("nullok_secure", "")
		else:
		    s += line.replace("nullok", "")
            fout = None
            try:
                fout = open(filePath, "wt")
                fout.write(s)
            finally:
                if (fout is not None):
                    fout.close()

def checkRule38498():
	wrongPermission = ""
	if os.path.exists('/etc/audit/auditd.conf'):
		checkAuditdFile = runOnShell("sed -ie 's/^[ \t]*//;s/[ \t]*=/ =/;s/=[ \t]*/= /' /etc/audit/auditd.conf")
		auditLogFile = runOnShell('grep "^log_file" /etc/audit/auditd.conf|sed s/^[^\/]*//')
		auditLogFile = auditLogFile.strip("\n")
		if not os.path.exists(auditLogFile):
			logging("Audit log file does not exist.")
			return True
		logging("Checking the permission of the system audit logs file(s).")
		auditResult = runOnShell('find '+ auditLogFile +'* -type f |sed s/^[^\/]*//|xargs stat -c %a:%n 2>/dev/null', False)
	        for element in auditResult.splitlines():
			element = element.split(":")
			tmpOct = int(element[0],8)
			if tmpOct & 07137:
				wrongPermission += element[1] + "\n"
	if wrongPermission:
		logging("Permission of the following file(s) are not set properly:\n{0}".format(wrongPermission))
		return False
	logging("Permissions for audit log file are configured properly.")
	return True

def fixRule38498():
	wrongPermission = ""
	checkAuditdFile = runOnShell("sed -ie 's/^[ \t]*//;s/[ \t]*=/ =/;s/=[ \t]*/= /' /etc/audit/auditd.conf")
	auditLogFile = runOnShell('grep "^log_file" /etc/audit/auditd.conf|sed s/^[^\/]*//')
	auditLogFile = auditLogFile.strip("\n")
	audit_res = runOnShell('find '+ auditLogFile +'* -type f |sed s/^[^\/]*//|xargs stat -c %a:%n 2>/dev/null', False)
	logging("Changing the permission of the system Audit logs file(s).")
	for element in audit_res.splitlines():
		element = element.split(":")
		tmpOct = int(element[0],8)
		if tmpOct & 07137:
			runOnShell('chmod 0640 %s' % element[1])
			wrongPermission += element[1] + "\n"
	if wrongPermission:
		logging("Updated permission of the following file(s):\n{0}".format(wrongPermission))

def checkRule38499():
	logging ("Checking if the password hashes are stored in \"/etc/passwd\".")
        hashUser = runOnShell('awk -F: \'($2 != "x") {print}\' /etc/passwd')
	if hashUser == "":
		logging("Password hash is not stored in \"/etc/passwd\".")
		return True
	else:
		logging("Password hash is stored in \"/etc/passwd\".")
		return False

def fixRule38499():
	accounts = runOnShell('awk -F: \'($2 != "x") {print}\' /etc/passwd')
	hashList = accounts.split("\n")
	with open("/etc/shadow", "r") as shadowFile:
		hashList = filter (lambda ele: ele !='', hashList)
		shadowFileLine = ""
		for line in shadowFile:
			if isL(line):
				updatedLine = ""
				for hashUser in hashList:
					shadowLine = line.split(":")
					hashUserlist = hashUser.split(":")
					try:
						# Comparing the account names form password and shadow file.
						if shadowLine[0].strip() == hashUserlist[0] and shadowLine[1].strip() == "":
							if hashUserlist[1].strip() == "":
								break
							logging ("Updating hash password of " + shadowLine[0] + "  in '/etc/passwd' \
 to '/etc/shadow' file if the password field is empty.")
							# Adding hash password to shadow file.
							shadowLine[1] = hashUserlist[1]
							updatedLine = ":".join(shadowLine)
					except IndexError:
						logging("The below mentioned entry in /etc/shadow file is not properly configured. \
please fix it manually.\n{0}".format(line))
						return None
				if updatedLine:
					shadowFileLine += updatedLine
				else:
					shadowFileLine += line

	fout = open("/etc/shadow", "wr")
	if fout != None:
		fout.write(shadowFileLine)
		fout.close()

	with open("/etc/passwd", "r") as passwdFile:
		pwdline = ""
		logging("Removing hash password from password file and inserting 'x' instead of hash password.")
		for line in passwdFile:
			if isL(line):
				hashLine = line.split(":")
				try:
					hashLinepass = line.split(":")[1]
				except IndexError:
					logging("The below mentioned entry in /etc/passwd file is not properly configured. \
Please fix it manually.\n{0}".format(line))
					return None

				if hashLinepass != "x":
					hashLine[1] = "x"
					hashLinepass = hashLine[1]
					pwdline += ":".join(hashLine)
				else:
					pwdline += line

	fout = open("/etc/passwd", "wr")
	if fout != None:
		fout.write(pwdline)
		fout.close()

def checkRule38500():
	logging("Checking if any account other than root has a UID of 0.")
        UID0accounts = runOnShell("awk -F: \'($3 == '0') {print}\' /etc/passwd | grep -v '^#' ")
        if len(UID0accounts.splitlines()) == 1:
		logging("No account other than root has a UID of 0.")
		return True

	logging("Account(s) other than root is having  UID of 0.")
	return False

def fixRule38500():
	uid_min = runOnShell('awk \'{ if($1 == "UID_MIN") print $2;}\' /etc/login.defs').strip()
	uid_max = runOnShell('awk \'{ if($1 == "UID_MAX") print $2;}\' /etc/login.defs').strip()
	logging ("Checking the next available uid")
	nextUid = runOnShell("awk -F: '$3>="+str(uid_min)+"&&$3<="+str(uid_max)+"{print $3}' /etc/passwd | sort -n | tail -1 | awk '{print $1+1}'").strip()

	#This flag is used to existance of nextUid value.
	uidFlag = False
	try:
		nextUid = int(nextUid)
	except Exception:
		uidFlag = True

	# Listing the uid's and gid List.
	uidList = runOnShell("awk -F: '{print $3}' /etc/passwd", False).splitlines()
	gidList = runOnShell("awk -F: '{print $4}' /etc/passwd", False).splitlines()
	with open("/etc/passwd", "r") as pwdFile:
		paswdLine = ""
		for line in pwdFile:
			if isL(line):
				try:
					userList = line.split(":")
					userName = userList[0]
					userUid  = userList[2]
					userGid  = userList[3]
				except IndexError:
					logging ("The below mentioned entry in /etc/passwd file is not properly configured. \
Please fix it manually.\n{0}".format(line))
					return None

				if (userUid == "0") and (userGid == "0") and userName != "root":
					if uidFlag:
						logging ("The next possible uid is not available, hence fix it manually.")
						return None

					userList[2] = str (nextUid)
					userUid = userList[2]
					userList[3] = str (nextUid)
					useGid = userList[3]
					logging ("Changing the " + userName + " user uid, gid '0' to '"+ userList[2] + "'.")
					paswdLine += ":".join(userList)
					nextUid += 1

				elif (userUid == "0") and userGid != "0" and userName != "root":
					gidFlag = False
					if any((userGid == usedUid) for usedUid in uidList):
						gidFlag = True
					if any((userGid == usedGid) for usedGid in gidList):
						gidFlag = True
					if gidFlag:
						if uidFlag:
							logging("The next possible uid is not available, hence fix it manually.")
							return None

						userList[2] = str(nextUid)
						logging ("Changing the " + userName + " user uid '0' to '"+ userList[2] + "'.")
						userUid = userList[2]
						nextUid += 1
					else:
						logging ("Changing the " + userName + " user uid '0' to '"+ userList[3] + "'.")
						userList[2] = userList[3]
						userUid = userList[2]
					paswdLine += ":".join(userList)

				else:
					paswdLine += line

	fout = open("/etc/passwd", "wr")
	if fout != None:
		fout.write(paswdLine)
		fout.close()

def checkRule38501(val=900):
    if OsName.lower() == "ubuntu":
        logging("V-38501 is not applicable for Ubuntu as the pam_tally2 module is not containing \
the option for the length of the interval, during which the consecutive authentication failures \
must happen for the user account lock.")
        return 3
    else:
        listPath = ['/etc/pam.d/system-auth','/etc/pam.d/password-auth']
    logging("Checking the failed password attempt policy is configured correctly, the DoD requirement is '900' or more.")
    returnFlag = True
    for fileName in listPath:
	# Checking for the auth and account lines in the systen-auth and pawword-auth files.
	systemAuthReq = runOnShell('grep "auth\s*required\s*pam_faillock.so" '+ fileName + ' | grep -v "^#"')
	systemAuthDefault = runOnShell('grep "auth\s*\[default\=die\]\s*pam_faillock.so" '+ fileName + ' | grep -v "^#"') 
	systemAccReq = runOnShell('grep "account\s*required\s*pam_faillock.so" '+ fileName + ' | grep -v "^#"')
	if (systemAuthReq == "") or (systemAccReq == "") or (systemAuthDefault == ""):
	    logging("Failed password attempt policy is not configured correctly.")
            return False
	# Checking the parameter 'fail_interval' with value in file.
	data = [systemAuthReq, systemAuthDefault]
	for line in data:
            if re.match(r'.*\s*(\bauth\s*required\s*pam_faillock.so\b)\s*', line) or \
		re.match(r'.*\s*(\bauth\s*\[default\=die\]\s*pam_faillock.so\b)\s*', line):
		line = line.translate(string.maketrans("\n\t\r", "   "))
		matchObjs = re.match(r'.*\s*(\bfail_interval=\w*\b)\s*', line)
		if matchObjs != None:
		    parameter = matchObjs.group(1)
		    actualParam,paramValue =  parameter.split("=")
		    try:
		        if int(paramValue) < val:
				returnFlag = False
		    except:
		        returnFlag = False
		        break
		else:
		    returnFlag = False
		    break
	if not returnFlag:
	    logging("Failed password attempt policy is not configured correctly.")
	    return False
    logging("Failed password attempt policy is configured correctly.")
    return True

def fixRule38501(val=900):
    if OsName.lower() == "ubuntu":
        logging("V-38501 is not applicable for Ubuntu as the pam_tally2 module is not containing \
the option for the length of the interval, during which the consecutive authentication failures \
must happen for the user account lock.")
	return 3
    else:
        listPath = ['/etc/pam.d/system-auth','/etc/pam.d/password-auth']
        logging("Modifying the failed password attempt policy configuration, the DoD requirement is '900' or more.")
        for fileName in listPath:
	    systemAuthReq = runOnShell('grep "auth\s*required\s*pam_faillock.so" '+ fileName + ' | grep -v "^#"')

	    systemAuthDefault = runOnShell('grep "auth\s*\[default\=die\]\s*pam_faillock.so" '+ fileName + ' | grep -v "^#"') 
	    systemAccReq = runOnShell('grep "account\s*required\s*pam_faillock.so" '+ fileName + ' | grep -v "^#"')
            with open(fileName, "r") as fileData:
                fileString = ""
		lastLine = ""
		updateValue = False
                for line in fileData:
		    updateValue = False
		    moduleSearchAuthReq = re.search('auth\s*required\s*pam_faillock.so',line)
		    moduleSearchAuthDefault = re.search('auth\s*\[default\=die\]\s*pam_faillock.so',line)
		    moduleSearchAccReq = re.search('account\s*required\s*pam_faillock.so',line)
		    if (moduleSearchAuthReq != None and systemAuthReq != "") or (moduleSearchAuthDefault != None and systemAuthDefault != ""):
			checkValue = False
			# Updating the fail-interval parameter if not configured properly.
			if isL(line) and "fail_interval" in line:
			    line = line.translate(string.maketrans("\n\t\r", "   ")).strip()
			    matchObjs = re.match(r'.*\s*(\bfail_interval=\w*\b)\s*', line)
			    systemAuthReq = systemAuthReq.translate(string.maketrans("\n\t\r", "   "))
			    systemAuthDefault = systemAuthDefault.translate(string.maketrans("\n\t\r", "   "))
			    if tokenMatchIC("fail_interval", systemAuthReq) or tokenMatchIC("fail_interval=", systemAuthReq):
				checkValue = True
			    elif tokenMatchIC("fail_interval", systemAuthDefault) or tokenMatchIC("fail_interval=", systemAuthDefault):
				checkValue = True
			    elif matchObjs != None:
				parameter = matchObjs.group(1)
				actualParam,paramValue = parameter.split("=")
				try:
				    if not int(paramValue) >= val:
					checkValue = True
				    else:
					pass
				except:
				    checkValue = True
			    else:
				updateValue = True
			else:
			    updateValue = True
			if checkValue:
			    start = line.index("fail_interval")
			    new = line[start:]
			    try:
			        end = new.index(" ")
			        line = line[0:start] + "fail_interval=900" + line[start+end:]
			    except:
			        end = 17
			        line = line[0:start] + "fail_interval=900" + line[start+end:len(line[start:])]

			if updateValue:
			    line = line.translate(string.maketrans("\n", " ")).strip()
			    line = line+' fail_interval=900'
			fileString += line + '\n'
		    # Adding the auth and account lines.
		    elif systemAuthReq == "" or systemAuthDefault == "" or systemAccReq == "":
			if systemAuthReq == "":
                            if re.search('^auth\s*sufficient\s*pam_unix.so',line):
                                if not tokenMatch('Cloud Raxak updated next line', lastLine):
                                    fileString += "# Cloud Raxak updated next line\n"
                                fileString += "auth required pam_faillock.so preauth silent fail_interval=900" +"\n"
			if systemAuthDefault == "":
                            if re.search('^auth\s*sufficient\s*pam_unix.so',line):
                                fileString += line + "# Cloud Raxak updated next line\nauth [default=die] pam_faillock.so authfail fail_interval=900" +"\n"
                                continue
			if systemAccReq == "":
                            if re.search('^account\s*required\s*pam_unix.so',line):
                                if not tokenMatch('Cloud Raxak updated next line', lastLine):
                                    fileString += "# Cloud Raxak updated next line\n"
                                fileString += "account required pam_faillock.so" +"\n"
			fileString += line
		    else:
		        fileString += line
		    lastLine = line
	    fout = None
            fout = open(fileName, 'wt')
            if fout != None:
                fout.write(fileString)
                fout.close()

def checkRule38502():
	if os.path.exists('/etc/shadow') == False:
		logging('/etc/shadow file does not exist.')
		return True
	logging("Checking the ownership of file '/etc/shadow'.")
	own_value = runOnShell('ls -l /etc/shadow')
	own_value = own_value.split(" ")[2] == "root"
	if own_value:
		logging("File '/etc/shadow' is owned by root.")
		return True
	else:
		logging("File '/etc/shadow' is not owned by root.")
		return False


def fixRule38502():
	logging("Changing the owner of file '/etc/shadow'.")
        runOnShell('chown root /etc/shadow')

def checkRule38503():
	if os.path.exists('/etc/shadow') == False:
		logging('/etc/shadow file does not exist.')
		return True
	logging("Checking the group ownership of '/etc/shadow'.")
	own_value = runOnShell('ls -l /etc/shadow')
	own_value = own_value.split(" ")[3] == "root"
	if own_value:
		logging("File '/etc/shadow' is group-owned by root.")
		return True
	else:
		logging("File '/etc/shadow' is not group-owned by root.")
		return False


def fixRule38503():
	logging("Changing the group owner of '/etc/shadow'.")
        runOnShell('chgrp root /etc/shadow')

def checkRule38504():
	if os.path.exists('/etc/shadow'):
		logging("Checking the permissions of file '/etc/shadow'.")
		check_file = runOnShell('ls -l /etc/shadow')
		check_perm = check_file.split(" ")[0][0:10]
		if check_perm != "----------":
			logging("The permissions of '/etc/shadow' file is not correct.")
			return False
		else:
			logging("The permissions of '/etc/shadow' file is correct.")
			return True
	logging("The '/etc/shadow' file does not exist.")
	return True

def fixRule38504():
	logging("Changing the permissions of file '/etc/shadow'.")
        runOnShell('chmod 0000 /etc/shadow')

def checkRule38511(val = 0):
        ip_forwarding_value = runOnShell("sysctl net.ipv4.ip_forward")
	try:
		setting = ip_forwarding_value.split()[2]
	except IndexError:
		logging("IP forwarding for IPv4 is not configured in the system.")
		return False
        if atoi(setting) == 1:
 		logging("IP forwarding permits the kernel to forward packets from one network interface to another.\
Please do not enable IP forwarding for IPv4 unless the system acting as routers. Please check it manually.")
		return None
        if atoi(setting) != val:
		logging("IP forwarding for IPv4 is not configured correctly in the system.")
		return False
	logging("Loading the setting defined during system boot to verify the IP forwarding for IPv4 during system reboot.")
	ip_forwarding_boot = runOnShell("grep -w net.ipv4.ip_forward /etc/sysctl.conf| grep -v '^#'")
        ip_forwarding_boot = ip_forwarding_boot.translate(string.maketrans("\n\t\r", "   "))
	if ip_forwarding_boot == "":
		logging("IP forwarding for IPv4 is not configured in the system.")
                return False
		
	if keyValEqMatch_new("net.ipv4.ip_forward","0",ip_forwarding_boot):
		logging("IP forwarding for IPv4 is disabled in the system.")
		return True
	else:
		logging("IP forwarding for IPv4 is not configured correctly in the system.")
		return False
			
def fixRule38511():
        runOnShell("sysctl -w net.ipv4.ip_forward=0")
        with open("/etc/sysctl.conf", "r") as file_read:
            flag = False
            file_string = ""
            lastLine = ""
            for line in file_read:
                if isL(line) and "net.ipv4.ip_forward" in line:
                    if not tokenMatch('Cloud Raxak updated next line',lastLine):
                       file_string += "# Cloud Raxak updated next line\n"
                    file_string += "net.ipv4.ip_forward = 0\n"
                    flag = True
                else:
                    file_string += line
                    lastLine = line
            if not(flag):
                file_string += "# Cloud Raxak updated next line\n"
                file_string += "net.ipv4.ip_forward = 0\n"
        fout = open("/etc/sysctl.conf", 'wt')
        if fout != None:
            fout.write(file_string)
            fout.close()


def checkRule38512():
	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		#If firewall is running and iptables is running/not running -> firewall.
		#If firewall is not running and iptables is not running -> Manual.
		firewall_status = runOnShell("systemctl is-active firewalld").replace('\n','')
		iptables_status = runOnShell("systemctl is-active iptables").replace('\n','')
		if (firewall_status == "active" and iptables_status == "active"):
		    logging("Firewalld and iptables both are running which should not be used at a time.\
Please fix it manually by turning off one of them.In CentOS 7 the default firewall is `firewalld` so it is recommended to use firewalld.")	
		    return None
		elif firewall_status == "active": 
			if runOnShell("systemctl is-enabled firewalld").replace('\n','') == "enabled":
				return True
		elif iptables_status == "active":
			if runOnShell("systemctl is-enabled iptables").replace('\n','') == "enabled":
				return True

		logging("Firewall is not active/running on the system, hence it is recommended to fix it manually.")

	elif OsName.lower() == "ubuntu":
		logging("Checking the status of Firewall.")	
		res = runOnShell("ufw status verbose")
		match_object = res.split('\n')[0]
		match_object1 = match_object.split(':')[1]
		if tokenMatch('active',match_object1):
			logging("Checking the service status of Firewall.")	
			service_status = runOnShell("service ufw status")
			service_status = service_status.split('\n')[0]
			if "start/running" in service_status:
				return True
		logging("Firewall is not active/running on the system, hence it is recommended to fix it manually.")
	else:
    		if CheckService("iptables"):
			logging("Firewall is active/running on the system.")
			return True
		logging("Firewall is not active/running on the system, hence it is recommended to fix it manually. \
The 'iptables' service can be enabled with the following command \n    chkconfig iptables on and service iptables start")
		
	return None


def fixRule38512():
	logging("Please fix it manually.")
	return None
	if OsName.lower() == "ubuntu":
		runOnShell("echo 'y'|ufw enable")
		runOnShell("ufw allow 22")
		runOnShell("ufw reload")
		runOnShell("sysv-rc-conf --level 0123456 ip6tables on")
	else:
		if OsVersion >= (7,0):
			flag_firewal_install = True
			flag_iptable_install = True
			if 'No such file or directory' in runOnShell("systemctl status firewalld"):
				flag_firewal_install = False
			if 'No such file or directory' in runOnShell("systemctl status iptables.service"):
				flag_iptable_install = False
			if not flag_firewal_install and not flag_iptable_install :
				runOnShell("yum install firewalld -y")	
				runOnShell("systemctl enable  firewalld")
				runOnShell("systemctl start  firewalld")
		        elif flag_firewal_install and not flag_iptable_install:
				runOnShell("systemctl enable  firewalld")
				runOnShell("systemctl start  firewalld")
			else: 
				runOnShell("systemctl enable  iptables.service")
				runOnShell("systemctl start  iptables.service")
		else:
			runOnShell("chkconfig --level 0123456 iptables on")
			runOnShell("service iptables start")

def checkRule38513():
	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		firewall_status = runOnShell("systemctl is-active firewalld").replace('\n','')
		iptables_status = runOnShell("systemctl is-active iptables").replace('\n','')
		if (firewall_status == "active" and iptables_status == "active"):
		    logging("Firewalld and iptables both are running which should not be used at a time.\
Please fix it manually by turning off one of them.In CentOS 7 the default firewall is `firewalld` so it is recommended to use firewalld.")	
		    return None
		elif firewall_status == "active": 
			enabled_token = runOnShell("systemctl is-enabled firewalld").replace('\n','')
			ipv4_rule = runOnShell("firewall-cmd --permanent --direct --get-rules ipv4 filter INPUT")
			if enabled_token == "enabled" and "DROP" in ipv4_rule:
				logging("The systems local IPv4 firewall is implemented with a deny-all,\
allow-by-exception policy for inbound packets.")
				return True
		elif iptables_status == "active":
			enabled_token = runOnShell("systemctl is-enabled iptables").replace('\n','')
			drop_policy = runOnShell("grep -w :INPUT /etc/sysconfig/iptables | grep -v '^#'")
			if enabled_token == "enabled" and "DROP" in drop_policy:
				logging("The systems local IPv4 firewall is implemented with a deny-all,\
allow-by-exception policy for inbound packets.")
				return True

		logging("Firewall is not active/running OR default input policy is not set to drop, hence it is recommended to fix it manually.")
	elif OsName.lower() == "ubuntu":
		logging("Checking the status of Firewall")
		ufw_status_res = runOnShell('ufw status verbose').split('\n')[0].split(':')[1]
		if tokenMatch('active',ufw_status_res):
			logging("Checking the service status of Firewall")
			service_ufw_status_res = runOnShell("service ufw status").split('\n')[0]
			if "start/running" in service_ufw_status_res:
             			default_policy_value = runOnShell('grep DEFAULT_INPUT_POLICY /etc/default/ufw | grep -v "^#"')
             			if tokenMatch('DEFAULT_INPUT_POLICY="DROP"',default_policy_value):
					return True
		logging("Firewall is not active/running OR default input policy is not set to drop, hence it is recommended to fix it manually.")
	else:
    		if CheckService("iptables"):
			logging("Checking the default policy for Firewall.")
			if "DROP" in runOnShell('grep :INPUT /etc/sysconfig/iptables | grep -v "^#"'):
				logging("Firewall is running.")
				return True
		logging("Firewall is not active/running, hence it is recommended to fix it manually.To set the default policy to DROP (instead of ACCEPT) for the built-in INPUT chain which processes incoming packets, add or correct the following line in '/etc/sysconfig/iptables':\n     :INPUT DROP [0:0]")

	return None 		


def fixRule38513():
	logging("Please fix it manually.")
	return None
	if OsName.lower() == "ubuntu":
		#Setting the policy
		#The systems local IPv4 firewall must implement a deny-all,
		# allow-by-exception policy for inbound packets.
		runOnShell('ufw default deny incoming')
		runOnShell('ufw default allow outgoing')
		runOnShell('ufw disable')
		runOnShell("echo 'y'|ufw enable")
		runOnShell("ufw allow 22")
		runOnShell("ufw reload")
	else:
		with open('/etc/sysconfig/iptables', 'r') as fileHandler:
			file_data = ""
			for line in fileHandler:
				if ":INPUT" in line and isL(line):
					file_data += "# Cloud Raxak updated next line\n"
					file_data += ":INPUT DROP [0:0]\n"
				else:
					file_data += line
			fout = None
			try:
				fout = open('/etc/sysconfig/iptables', 'wt')
				fout.write(file_data)
			finally:
				if (fout is not None):
					fout.close()


def checkRule38514():
	logging("Checking if the system is configured to prevent the loading of the 'dccp' kernel module.")
	blacklist_dccp_list = ["installdccp/bin/false", "installdccp/bin/true", "blacklistdccp"]
	# check for any entry for module blocking in /etc/modprobe.conf and modprobe.d directory.
	cmd = 'grep -wr dccp /etc/modprobe.conf /etc/modprobe.d | grep -v "^#"'
	if not os.path.exists('/etc/modprobe.conf'):
	    logging("modprobe.conf file does not exists on system.")
	    cmd = 'grep -wr dccp /etc/modprobe.d | grep -v "^#"'
	grep_dccp_block_module = runOnShell(cmd)
	dccp_block_module_list = grep_dccp_block_module.splitlines()

	#iterate all grep entries for different files.
	flag = False
	for dccp_block_module in dccp_block_module_list:
	    # Checking for dccp module present in grep result.
	    if re.match(r'.*\s*(\bdccp\b)\s*', dccp_block_module):
	        blacklist_dccp = dccp_block_module.split(":")[1]
	        blacklist_dccp = blacklist_dccp.replace(" ","")
	        if blacklist_dccp in blacklist_dccp_list:
	            flag = True

	logging("Checking whether 'dccp' kernel module is active.")
	res = runOnShell("lsmod | grep dccp")
	if re.match(r'.*\s*(\bdccp\b)\s*', res) and flag:
	    logging("Remove the 'dccp' kernel module or reboot the system to disable 'dccp' kernel module.")
	    return None
	elif re.match(r'.*\s*(\bdccp\b)\s*', res) and not flag:
	    logging("System is not configured properly to prevent loading of 'dccp' kernal module but the module is running. \
Hence 'dccp' kernal module is in use. Remove this kernal module manually.")
	    return None
	elif flag:
	    logging("System is configured properly to prevent loading of 'dccp' kernel module.")
	    return True
	else:
	    logging("System is not configured properly to prevent loading of 'dccp' kernel module.")
	    return False

def fixRule38514():
            addLine = "install dccp /bin/true\n"
            logging("Checking if the system is configured to prevent the loading of the 'dccp' kernel module.")
            if os.path.exists("/etc/modprobe.d/cloudraxak.conf"):
                file_content = open("/etc/modprobe.d/cloudraxak.conf", "r+")
            else:
                file_content = open("/etc/modprobe.d/cloudraxak.conf", "w+")

            flag = False
            newLine = ""
            lastLine = ""
            for line in file_content:
                if isL(line) and "dccp" in line:
                    if not tokenMatch('Cloud Raxak updated next line',lastLine):
                        newLine += "# Cloud Raxak updated next line\n"
                    newLine += addLine
                    flag = True
                else:
                    newLine += line
                    lastLine = line
            if not(flag):
                newLine += "# Cloud Raxak updated next line\n"
                newLine += addLine

            fout = None
            try:
                fout = open("/etc/modprobe.d/cloudraxak.conf", 'wt')
                fout.write(newLine)
            finally:
                if fout is not None:
                    fout.close()

            logging("Checking whether 'dccp' kernel module is active.")
            res = runOnShell("lsmod | grep dccp")
            if "dccp" in res:
                logging("Disabling 'dccp' kernel module.")
                runOnShell("rmmod dccp")

def checkRule38515():
	logging("Checking if the system is configured to prevent the loading of the 'sctp' kernel module.")
	blacklist_sctp_list = ["installsctp/bin/false", "installsctp/bin/true", "blacklistsctp"]
	# check for any entry for module blocking in /etc/modprobe.conf and modprobe.d directory.
	cmd = 'grep -wr sctp /etc/modprobe.conf /etc/modprobe.d | grep -v "^#"'
	if not os.path.exists('/etc/modprobe.conf'):
	    logging("modprobe.conf file does not exists on system.")
	    cmd = 'grep -wr sctp /etc/modprobe.d | grep -v "^#"'
	grep_sctp_block_module = runOnShell(cmd)
	sctp_block_module_list = grep_sctp_block_module.splitlines()

	#iterate all grep entries for different files.
	flag = False
	for sctp_block_module in sctp_block_module_list:
	    # Checking for SCTP module present in grep result.
	    if re.match(r'.*\s*(\bsctp\b)\s*', sctp_block_module):
                blacklist_sctp = sctp_block_module.split(":")[1]
                blacklist_sctp = blacklist_sctp.replace(" ","")
                if blacklist_sctp in blacklist_sctp_list:
	            flag = True

	logging("Checking whether 'sctp' kernel module is active.")
	res = runOnShell("lsmod | grep sctp")
	if re.match(r'.*\s*(\bsctp\b)\s*', res) and flag:
	    logging("Remove the 'sctp' kernel module or reboot the system to disable 'sctp' kernel module.")
	    return None
	elif re.match(r'.*\s*(\bsctp\b)\s*', res) and not flag:
	    logging("System is not configured properly to prevent loading of 'sctp' kernal module but the module is running. \
Hence 'sctp' kernal module is in use. Remove this kernal module manually.")
	    return None
	elif flag:
	    logging("System is configured properly to prevent loading of 'sctp' kernel module.")
	    return True
        else:
            logging("System is not configured properly to prevent loading of 'sctp' kernel module.")
            return False

def fixRule38515():
            addLine = "install sctp /bin/true\n"
            logging('Checking if the system is configured to prevent the loading of the "sctp" kernel module.')
            if os.path.exists("/etc/modprobe.d/cloudraxak.conf"):
                file_content = open("/etc/modprobe.d/cloudraxak.conf", "r+")
            else:
                file_content = open("/etc/modprobe.d/cloudraxak.conf", "w+")

            flag = False
            newLine = ""
            lastLine = ""
            for line in file_content:
                if isL(line) and "sctp" in line:
                    if not tokenMatch('Cloud Raxak updated next line',lastLine):
                        newLine += "# Cloud Raxak updated next line\n"
                    newLine += addLine
                    flag = True
                else:
                    newLine += line
                    lastLine = line
            if not(flag):
                newLine += "# Cloud Raxak updated next line\n"
                newLine += addLine

            fout = None
            try:
                fout = open("/etc/modprobe.d/cloudraxak.conf", 'wt')
                fout.write(newLine)
            finally:
                if fout is not None:
                    fout.close()

            logging("Checking whether 'sctp' kernel module is active.")
            res = runOnShell("lsmod | grep sctp")
            if "sctp" in res:
                logging("Reboot the system to disable 'sctp' kernel module.")
                if OsName.lower() == "ubuntu":
                     runOnShell("update-initramfs -u")
                else:
                     runOnShell("modprobe -r sctp")

def checkRule38516():
	logging("Checking if the system is configured to prevent the loading of the 'rds' kernel module.")
	blacklist_rds_list = ["installrds/bin/false", "installrds/bin/true", "blacklistrds"]
	# check for any entry for module blocking in /etc/modprobe.conf and modprobe.d directory.
	cmd = 'grep -wr rds /etc/modprobe.conf /etc/modprobe.d | grep -v "^#"'
	if not  os.path.exists('/etc/modprobe.conf'):
	    logging("modprobe.conf file does not exists on system.")
	    cmd = 'grep -wr rds /etc/modprobe.d | grep -v "^#"'
	grep_rds_block_module = runOnShell(cmd)
	rds_block_module_list = grep_rds_block_module.splitlines()

	#iterate all grep entries for different files.
	flag = False
	for rds_block_module in rds_block_module_list:
	    # Checking for rds module present in grep result.
	    if re.match(r'.*\s*(\brds\b)\s*', rds_block_module):
	        blacklist_rds = rds_block_module.split(":")[1]
	        blacklist_rds = blacklist_rds.replace(" ","")
	        if blacklist_rds in blacklist_rds_list:
	            flag = True

	logging("Checking whether 'rds' kernel module is active.")
	res = runOnShell("lsmod | grep rds")
	if re.match(r'.*\s*(\brds\b)\s*', res) and flag:
	    logging("Remove the 'rds' kernel module or reboot the system to disable 'rds' kernel module.")
	    return None
	elif re.match(r'.*\s*(\brds\b)\s*', res) and not flag:
	    logging("System is not configured properly to prevent loading of 'rds' kernal module but the module is running. \
Hence 'rds' kernal module is in use. Remove this kernal module manually.")
	    return None
	elif flag:
	    logging("System is configured properly to prevent loading of 'rds' kernel module.")
	    return True
	else:
	    logging("System is not configured properly to prevent loading of 'rds' kernel module.")
	    return False

def fixRule38516():
            addLine = "install rds /bin/true\n"
            logging('Checking if the system is configured to prevent the loading of the "rds" kernel module.')
            if os.path.exists("/etc/modprobe.d/cloudraxak.conf"):
                file_content = open("/etc/modprobe.d/cloudraxak.conf", "r+")
            else:
                file_content = open("/etc/modprobe.d/cloudraxak.conf", "w+")

            flag = False
            newLine = ""
            lastLine = ""
            for line in file_content:
                if isL(line) and "rds" in line:
                    if not tokenMatch('Cloud Raxak updated next line',lastLine):
                        newLine += "# Cloud Raxak updated next line\n"
                    newLine += addLine
                    flag = True
                else:
                    newLine += line
                    lastLine = line
            if not(flag):
                newLine += "# Cloud Raxak updated next line\n"
                newLine += addLine

            fout = None
            try:
                fout = open("/etc/modprobe.d/cloudraxak.conf", 'wt')
                fout.write(newLine)
            finally:
                if fout is not None:
                    fout.close()

            logging("Checking whether 'rds' kernel module is active.")
            res = runOnShell("lsmod | grep rds")
            if "rds" in res:
                logging("Reboot the system to disable 'rds' kernel module.")
                if OsName.lower() == "ubuntu":
                     runOnShell("update-initramfs -u")
                else:
                     runOnShell("modprobe -r rds")

def checkRule38517():
	logging("Checking if the system is configured to prevent the loading of the 'tipc' kernel module.")
	blacklist_tipc_list = ["installtipc/bin/false", "installtipc/bin/true", "blacklisttipc"]
	# check for any entry for module blocking in /etc/modprobe.conf and modprobe.d directory.
	cmd = 'grep -wr tipc /etc/modprobe.conf /etc/modprobe.d | grep -v "^#"'
	if not os.path.exists('/etc/modprobe.conf'):
	    logging("modprobe.conf file does not exists on system.")
	    cmd = 'grep -wr tipc /etc/modprobe.d | grep -v "^#"'
	grep_tipc_block_module = runOnShell(cmd)
	tipc_block_module_list = grep_tipc_block_module.splitlines()

	#iterate all grep entries for different files.
	flag = False
	for tipc_block_module in tipc_block_module_list:
	    # Checking for tipc module present in grep result.
	    if re.match(r'.*\s*(\btipc\b)\s*', tipc_block_module):
		blacklist_tipc = tipc_block_module.split(":")[1]
		blacklist_tipc = blacklist_tipc.replace(" ","")
		if blacklist_tipc in blacklist_tipc_list:
	            flag = True

	logging("Checking whether 'tipc' kernel module is active.")
	res = runOnShell("lsmod | grep tipc")
	if re.match(r'.*\s*(\btipc\b)\s*', res) and flag:
	    logging("Remove the 'tipc' kernel module or reboot the system to disable 'tipc' kernel module.")
	    return None
	elif re.match(r'.*\s*(\btipc\b)\s*', res) and not flag:
	    logging("System is not configured properly to prevent loading of 'tipc' kernal module but the module is running. \
Hence 'tipc' kernal module is in use. Remove this kernal module manually.")
	    return None
	elif flag:
	    logging("System is configured properly to prevent loading of 'tipc' kernel module.")
	    return True
	else:
	    logging("System is not configured properly to prevent loading of 'tipc' kernel module.")
	    return False

def fixRule38517():
            addLine = "install tipc /bin/true\n"
            logging('Checking if the system is configured to prevent the loading of the "tipc" kernel module.')
            if os.path.exists("/etc/modprobe.d/cloudraxak.conf"):
                file_content = open("/etc/modprobe.d/cloudraxak.conf", "r+")
            else:
                file_content = open("/etc/modprobe.d/cloudraxak.conf", "w+")

            flag = False
            newLine = ""
            lastLine = ""
            for line in file_content:
                if isL(line) and "tipc" in line:
                    if not tokenMatch('Cloud Raxak updated next line',lastLine):
                        newLine += "# Cloud Raxak updated next line\n"
                    newLine += addLine
                    flag = True
                else:
                    newLine += line
                    lastLine = line
            if not(flag):
                newLine += "# Cloud Raxak updated next line\n"
                newLine += addLine

            fout = None
            try:
                fout = open("/etc/modprobe.d/cloudraxak.conf", 'wt')
                fout.write(newLine)
            finally:
                if fout is not None:
                    fout.close()

            logging("Checking whether 'tipc' kernel module is active.")
            res = runOnShell("lsmod | grep tipc")
            if "tipc" in res:
                logging("Reboot the system to disable 'tipc' kernel module.")
                if OsName.lower() == "ubuntu":
                     runOnShell("update-initramfs -u")

def checkRule38518():
	other_owner_file = ""
	logging("Checking the ownerhip of all rsyslog-generated log files.")
	if OsName.lower() == "ubuntu":
	    if os.path.isdir('/etc/rsyslog.d/'):
		list_file_path = [os.path.join('/etc/rsyslog.d/', content_file) for content_file in os.listdir('/etc/rsyslog.d/')]
		for file_path in list_file_path:
			res = runOnShell('cat '+ file_path +' | grep /var/log | grep -v "#"')
			for line in res.splitlines():
				if isL(line):
					match_object = re.search( r'.*(/var/log/.*)', line, re.M|re.I)
					if match_object != None:
						var_log_file = match_object.group(1)
						if os.path.isfile(var_log_file):
							var_log_file_owner = runOnShell('ls -l '+ var_log_file)
							try:
				        	            if not(var_log_file_owner.split(" ")[2] == "root"):
								other_owner_file = other_owner_file + var_log_file +'\n\n'
				        	        except:
				        	            continue
	else:
	    if os.path.exists('/etc/rsyslog.conf'):
		res = runOnShell('cat /etc/rsyslog.conf | grep /var/log | grep -v "#"')
		res = res.splitlines()
		for line in res:
		    if isL(line):
			var_log_file = line.split(" ", 1)[1].lstrip(" -")
			if os.path.isfile(var_log_file):
			    var_log_file_owner = runOnShell('ls -l ' + var_log_file)
			    try:
				if not(var_log_file_owner.split(" ")[2] == "root"):
				    other_owner_file = other_owner_file + var_log_file +'\n\n'
			    except:
				continue
	if other_owner_file != "":
		logging("There are some rsyslog-generated log file(s) which don't have their ownership set to the right owner.")
		return False
	logging("All rsyslog-generated log file(s) have their ownership set to the right owner.")
	return True

def fixRule38518():
	if OsName.lower() == "ubuntu":
	   if os.path.isdir('/etc/rsyslog.d/'):
		list_file_path = [os.path.join('/etc/rsyslog.d/', content_file) for content_file in os.listdir('/etc/rsyslog.d/')]
		for file_path in list_file_path:
			res = runOnShell('cat '+file_path+' | grep /var/log | grep -v "#"')    
			for line in res.splitlines():
				if isL(line):
					match_object = re.search( r'.*(/var/log/.*)', line, re.M|re.I)
					if match_object != None:
						var_log_file = match_object.group(1)
						if os.path.isfile(var_log_file):
							var_log_file_owner = runOnShell('ls -l '+var_log_file)
							try:
								if not(var_log_file_owner.split(" ")[2] == "root"):
									logging("Changing the ownership of all rsyslog generated log files.")
									runOnShell('chown root ' + var_log_file)
							except:
								continue
	else:
	    if os.path.exists('/etc/rsyslog.conf'):
	        res = runOnShell('cat /etc/rsyslog.conf | grep /var/log | grep -v "#" ')
		res = res.splitlines()
		for line in res:
		    if isL(line):
		        var_log_file = line.split(" ", 1)[1].lstrip(" -")
		        if os.path.isfile(var_log_file):
				var_log_file_owner = runOnShell('ls -l '+ var_log_file)
				try:
				    if not(var_log_file_owner.split(" ")[2] == "root"):
					logging("Changing the ownership of all rsyslog generated log files.")
					runOnShell('chown root ' + var_log_file)
				except:
				    continue

def checkRule38519():
	logging("Checking the group-owner of all rsyslog generated log files.")
	other_owner_file =  ""
	if OsName.lower() == "ubuntu":
	    if os.path.isdir('/etc/rsyslog.d/'):
		list_file_path = [os.path.join('/etc/rsyslog.d/', content_file) for content_file in os.listdir('/etc/rsyslog.d/')]
		for file_path in list_file_path:
        		res = runOnShell('cat '+ file_path +' | grep /var/log | grep -v "#"')    
			for line in res.splitlines():
				if isL(line):
					match_object = re.search( r'.*(/var/log/.*)', line, re.M|re.I)
					if match_object != None:
						var_log_file = match_object.group(1)
						if os.path.isfile(var_log_file):
							var_log_file_owner = runOnShell('ls -l '+ var_log_file)
							try:
				        	            if not(var_log_file_owner.split(" ")[3] == "root"):
								other_owner_file = other_owner_file + var_log_file+'\n\n'
				        	        except:
				        	            continue
	else:
	    if os.path.exists('/etc/rsyslog.conf'):
		res = runOnShell('cat /etc/rsyslog.conf | grep /var/log | grep -v "#"')
		res = res.splitlines()
		for line in res:
		    if isL(line):
			var_log_file = line.split(" ", 1)[1].lstrip(" -")
			if os.path.isfile(var_log_file):
			    var_log_file_owner = runOnShell('ls -l ' + var_log_file)
			    try:
				if not(var_log_file_owner.split(" ")[3] == "root"):
				    other_owner_file = other_owner_file + var_log_file +'\n\n'
			    except:
				continue
	if other_owner_file != "":
		logging("There are some rsyslog-generated log file(s) which don't have their group-ownership set to the right group-owner.")
		return False
	logging("All rsyslog-generated log file(s) have their group-ownership set to the right group-owner.\n")
	return True

def fixRule38519():
	other_owner_file =  ""
	if OsName.lower() == "ubuntu":
	    if os.path.isdir('/etc/rsyslog.d/'):
		list_file_path = [os.path.join('/etc/rsyslog.d/', content_file) for content_file in os.listdir('/etc/rsyslog.d/')]
		for file_path in list_file_path:
			res = runOnShell('cat '+ file_path +' | grep /var/log | grep -v "#"')    
			for line in res.splitlines():
				if isL(line):
					match_object = re.search( r'.*(/var/log/.*)', line, re.M|re.I)
					if match_object != None:
						var_log_file = match_object.group(1)
						if os.path.isfile(var_log_file):
							var_log_file_owner = runOnShell('ls -l '+var_log_file)
							try:
								if not(var_log_file_owner.split(" ")[3] == "root"):
									logging("Changing the group owner of all rsyslog generated log files.")
									runOnShell('chgrp root ' + var_log_file)
							except:
								continue
	else:
	    if os.path.exists('/etc/rsyslog.conf'):
	        res = runOnShell('cat /etc/rsyslog.conf | grep /var/log | grep -v "#"')
		res = res.splitlines()
		for line in res:
		    if isL(line):
		        var_log_file = line.split(" ", 1)[1].lstrip(" -")
		        if os.path.isfile(var_log_file):
				var_log_file_owner = runOnShell('ls -l '+ var_log_file)
				try:
				    if not(var_log_file_owner.split(" ")[3] == "root"):
					logging("Changing the group owner of all rsyslog generated log files.")
					runOnShell('chgrp root ' + var_log_file)
				except:
				    continue

def checkRule38520():
    logging ("Checking if the system is configured to store backups of audit logs on a remote loghost.")
    if not check_rsyslog_config():
        logging("The system is not configured to store backups of audit logs on a remote loghost correctly, please fix this manually.")
        return None
    else:
        logging("The system is configured to store backups of audit logs on a remote loghost.")
        return True

def fixRule38520():
	logging("The choice of protocol depends on the system environment, although TCP and RELP provide more reliable message delivery \
they may not be supported in all environments. RELP is much more relaible than TCP and UDP. Please check configuration file of \
rsyslog(/etc/rsyslog.conf) and make sure you have imported the necessary modules for system logging, the protocol used for forwarding \
logs to remote loghost and it's configuration. Please fix this manually.")
        return None

def checkRule38521():
    logging ("Checking whether system is configured to support the requirement to centrally manage the content of audit records \
generated by organization defined information system components.")
    if not check_rsyslog_config():
        logging("The system is not configured to support the requirement to centrally manage the content of audit records \
generated by organization defined information system components. Please fix this manually.")
        return None
    else:
        logging("The system is configured to support the requirement to centrally manage the content of audit records \
generated by organization defined information system components.")
        return True

def fixRule38521():
	logging("The choice of protocol depends on the system environment, although TCP and RELP provide more reliable message delivery \
they may not be supported in all environments. RELP is much more relaible than TCP and UDP. Please check configuration file of \
rsyslog(/etc/rsyslog.conf) and make sure you have imported the necessary modules for system logging, the protocol used for forwarding \
logs to remote loghost and it's configuration. Please fix this manually.")
        return None

def checkRule38522():
    if not CheckService("auditd"):
	return False

    file_path = '/etc/audit/audit.rules'
    if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
	file_path = '/etc/audit/rules.d/audit.rules'

    #Checking for keyword never,task.
    logging("Checking if system call auditing is disabled.")
    if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
        return False

    #Checking for any error in file.
    if "error" in runOnShell('auditctl -R '+file_path):
	logging("There is an error in "+file_path+", please fix it manually before remediating the rule.")
	return None

    if runOnShell("grep -w settimeofday " + file_path + "| grep -v '^#'") == "":
	logging("System is not configured to audit time changes.")
	return False

    logging("System is configured to audit time changes.")
    return True	

def fixRule38522():
    if not InstallPackage("audit"):
        return None

    file_path = '/etc/audit/audit.rules'
    if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
	file_path = '/etc/audit/rules.d/audit.rules'

    #Checking for keyword never,task
    if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        logging(" Disabling the system call auditing to audit the events properly.")
        runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /' "+file_path)

    #Obtaining the data from file_path	
    audit_handler = open(file_path, "r")
    audit_file_rules = audit_handler.readlines()
    audit_handler.close()
    ##Removing redundant entries from data
    filter_unique_audit_rule_list = []	
    for line in list(set(audit_file_rules)):
        line1 = line.strip('\n')
    	if (('-b 320' in line1) or ('-D' in line1) or ('#' in line1)):
		continue
	final_line = re.sub("\s+" , " ", line1)
	filter_unique_audit_rule_list.append(final_line.strip())

    startup_line = "# This file contains the auditctl rules that are loaded\n # whenever the audit daemon is started via the initscripts.\n # The rules are simply the parameters that would be passed\n# to auditctl.\n # First rule - delete all\n-D\n\n # Increase the buffers to survive stress events.\n # Make this bigger for busy systems\n -b 320\n"
    
    with open(file_path, "w") as fhandler:
    	res = runOnShell("uname -m")
       	if "64" in res:
            rule = "-a always,exit -F arch=b64 -S settimeofday -k audit_time_rules"
       	else:
            rule = "-a always,exit -F arch=b32 -S settimeofday -k audit_time_rules"

    	logging("Configuring the system to audit all attempts to alter system time.")	
    	fhandler.write(startup_line)
	unique_data = '\n'.join(filter_unique_audit_rule_list)
	fhandler.write(unique_data)
	if rule not in filter_unique_audit_rule_list:
		fhandler.write("\n"+rule+"\n")

    fhandler.close()  					
    runOnShell("auditctl -R "+file_path)
    RunService("auditd")

def checkRule38523():
        source_route_val = runOnShell("sysctl net.ipv4.conf.all.accept_source_route")
	try:
	        setting = source_route_val.split()[2]
	except IndexError:
                logging("System is not configured to accept IPv4 source-routed packets on any interface.")
                return False
        if atoi(setting) != 0:
                logging("System is configured to accept source-routed packets.\nAccepting source-routed packets in the IPv4 protocol has few legitimate uses.\
It should be disabled unless the system is a Network Device.") 
                return False
        logging("Loading the setting defined during boot to verify the acceptance of the source-routed packets after system reboot.")
        reboot_value = runOnShell("grep -w net.ipv4.conf.all.accept_source_route /etc/sysctl.conf | grep -v '^#'")
        reboot_value = reboot_value.translate(string.maketrans("\n\t\r", "   "))
	if reboot_value == "":
                logging("System is not configured to accept IPv4 source-routed packets on any interface.")
                return False
		
	if keyValEqMatch_new("net.ipv4.conf.all.accept_source_route","0",reboot_value):
                logging("System is configured to accept IPv4 source-routed packets on any interface.")
		return True
	else:
		logging("'/etc/sysctl.conf' file doesn't contain setting to reject source-routed packets.\nAccepting source-routed packets in the IPv4 protocol has few legitimate uses.\
It should be disabled unless the system is a Network Device.")
		return False


def fixRule38523():
        runOnShell("sysctl -w net.ipv4.conf.all.accept_source_route=0")
        with open("/etc/sysctl.conf", "r") as f:
            flag = False
            file_string = ""
            lastLine = ""
            for line in f:
                if isL(line) and "all.accept_source_route" in line:
                    if not tokenMatch('Cloud Raxak updated next line',lastLine):
                        file_string += "# Cloud Raxak updated next line\n"
                    file_string += "net.ipv4.conf.all.accept_source_route = 0\n"
                    flag = True
                else:
                    file_string += line
                    lastLine = line
            if not(flag):
                file_string += "# Cloud Raxak updated next line\n"
                file_string += "net.ipv4.conf.all.accept_source_route = 0\n"
            fout = None
            fout = open("/etc/sysctl.conf", 'wt')
            if fout != None:
                fout.write(file_string)
                fout.close()

def checkRule38524():
        icmp_value = runOnShell("sysctl net.ipv4.conf.all.accept_redirects")
	try:
		setting = icmp_value.split()[2]
	except IndexError:
		logging("ICMP redirects rejection setting is not configured.")
        if atoi(setting) == 1:
		logging("Accepting ICMP redirects has few legitimate uses. It should be disabled unless system is a Network Device.")
		return False
        if atoi(setting) != 0:
		logging("System is configured to accept ICMPv4 redirect packets on any interface.")
		return False
	logging("Loading the setting defined during boot time to verify the ICMP redirects acceptance after system reboot.") 
	icmp_setting = runOnShell("grep -w net.ipv4.conf.all.accept_redirects /etc/sysctl.conf| grep -v '^#'")
        icmp_setting = icmp_setting.translate(string.maketrans("\n\t\r", "   "))
	if icmp_setting == "":
		logging("System is configured to accept ICMPv4 redirect packets on any interface.")
                return False
		
	if keyValEqMatch_new("net.ipv4.conf.all.accept_redirects","0",icmp_setting):
		logging("System is configured to reject ICMPv4 redirect packets on any interface.")
		return True
	else:
		logging("System is configured to accept ICMPv4 redirect packets on any interface.")
		return False

 
def fixRule38524():
        runOnShell("sysctl -w net.ipv4.conf.all.accept_redirects=0")
        with open("/etc/sysctl.conf", "r") as file_read:
            flag = False
            file_string = ""
            lastLine = ""
            for line in file_read:
                if isL(line) and "all.accept_redirects" in line:
                    if not tokenMatch('Cloud Raxak updated next line',lastLine):
                        file_string += "# Cloud Raxak updated next line\n"
                    file_string += "net.ipv4.conf.all.accept_redirects = 0\n"
                    flag = True
                else:
                    file_string += line
                    lastLine = line
            if not(flag):
                file_string += "# Cloud Raxak updated next line\n"
                file_string += "net.ipv4.conf.all.accept_redirects = 0\n"
            fout = None
            fout = open("/etc/sysctl.conf", 'wt')
            if fout != None:
            	fout.write(file_string)
            	fout.close()

def checkRule38525():
    #Reason for adding the check for Centos-6.6 in case of audit rules.
    # RHEL 6.5
    #>> ---------
    #>> auditctl -l | grep syscall | grep adjtimex
    #>> LIST_RULES: exit,always arch=1073741827 (0x40000003) key=audit_time_rules
    #>> syscall=adjtimex
    #>> LIST_RULES: exit,always arch=3221225534 (0xc000003e) key=audit_time_rules
    #>> syscall=adjtimex
    #>> RHEL 6.6
    #>> --------
    #>> auditctl -l | grep syscall | grep adjtimex
    #>>   <==  No output
    #>>  auditctl -l | grep adjtimex | grep audit_time_rule
    #>> -a always,exit -F arch=i386 -S stime,settimeofday,adjtimex -F
    #>> key=audit_time_rules
    #>> -a always,exit -F arch=x86_64 -S adjtimex,settimeofday,clock_settime -F
    #>> key=audit_time_rules
    #>> As you can see the "auditctl -l" command in RHEL 6.5 worked as expected for
    #>> the STIG. This same check didn't work for systems running RHEL 6.6. The
    #>> information above shows why. The output of "auditctl -l" in RHEL 6.6 now
    #>> just shows the contents of the audit.rules file.
    #>> (5) The below STIG checks are affected by this change. All tools that
    #>> directly use checks indentified in the Red Hat 6 STIG--this includes the
    #>> SCAP. The following checks are affected (there may be others, I just
    #>> looked for checks that had 'grep syscall' in them):
    #>>

    machine_arch = runOnShell("uname -m")
    if "64" in machine_arch:
	logging("The audit rule is not applicable to 64 bit machine.")
	return True

    if not CheckService("auditd"):
        return False

    file_path = '/etc/audit/audit.rules'
    if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
	file_path = '/etc/audit/rules.d/audit.rules'

    #Checking for keyword never,task.
    logging("Checking if system call auditing is disabled.")
    if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
        return False

    #Checking for any error in file.
    if "error" in runOnShell('auditctl -R '+file_path):
	logging("There is an error in "+file_path+", please fix it manually before remediating the rule.")
	return None

    if runOnShell("grep -w stime "+file_path + "| grep -v '^#'") == "":
	logging("System is not configured to audit system time changes")
	return False

    logging("System is configured to audit system time changes")
    return True			
	

def fixRule38525():
    res = runOnShell("uname -m")
    if "64" in res:
	logging("The audit rule is not applicable to 64 bit machine.")
	return True

    if not InstallPackage("audit"):
        return None

    file_path = '/etc/audit/audit.rules'
    if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
	file_path = '/etc/audit/rules.d/audit.rules'

    #Removing keyword never,task
    if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        logging(" Disabling the system call auditing to audit the events properly.")
        runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /' "+file_path)

    #Clear previous rules set. 
    runOnShell("auditctl -D")
    #Obtaining the data from file_path	
    audit_handler = open(file_path, "r")
    audit_file_rules = audit_handler.readlines()
    audit_handler.close()
    #Removing redundant entries	from data
    #Removing comments	
    filter_unique_audit_rule_list = []	
    for line in list(set(audit_file_rules)):
        line1 = line.strip('\n')
    	if (('-b 320' in line1) or ('-D' in line1) or ('#' in line1)):
		continue

	final_line = re.sub("\s\s+" , " ", line1)
	filter_unique_audit_rule_list.append(final_line.strip())

    startup_line = "# This file contains the auditctl rules that are loaded\n # whenever the audit daemon is started via the initscripts.\n # The rules are simply the parameters that would be passed\n# to auditctl.\n # First rule - delete all\n-D\n\n # Increase the buffers to survive stress events.\n # Make this bigger for busy systems\n -b 320\n"
    
    with open(file_path, "w") as fhandler:
	rule = "-a always,exit -F arch=b32 -S stime -k audit_time_rules"	
    	fhandler.write(startup_line)
	unique_data = '\n'.join(filter_unique_audit_rule_list)
	fhandler.write(unique_data)
	if rule not in filter_unique_audit_rule_list:
		logging("Configuring the system to audit all attempts to alter system time through stime")	
		fhandler.write("\n"+rule+"\n")

    fhandler.close()  					
    runOnShell("auditctl -R "+file_path)
    RunService("auditd")


def checkRule38526(default = 0):
        icmp_secure_value = runOnShell("sysctl net.ipv4.conf.all.secure_redirects")
	try:
		setting = icmp_secure_value.split()[2]
	except IndexError:
		logging("System is configured to accept ICMPv4 secure redirect packets on any interface.")
		return False
	if atoi(setting) == 1:
		logging("Accepting 'secure' ICMP redirects has few legitimate uses. It should be disabled unless system is a Network Device.")
		return False
        if atoi(setting) != 0:
		logging("System is configured to accept ICMPv4 secure redirect packets on any interface.")
		return False
	logging("Loading the setting defined during boot time to verify the 'secure' ICMP redirects acceptance after system reboot.")
        icmp_setting = runOnShell("grep -w net.ipv4.conf.all.secure_redirects /etc/sysctl.conf | grep -v '^#'")
        icmp_setting = icmp_setting.translate(string.maketrans("\n\t\r", "   "))
	if icmp_setting == "":
		logging("System is configured to accept ICMPv4 secure redirect packets on any interface.")
                return False
		
	if keyValEqMatch_new("net.ipv4.conf.all.secure_redirects","0",icmp_setting):
		logging("System is configured to reject ICMPv4 secure redirect packets on any interface.")
		return True
	else:
		logging("System is configured to accept ICMPv4 secure redirect packets on any interface.")
		return False


def fixRule38526():
        runOnShell("sysctl -w net.ipv4.conf.all.secure_redirects=0")
        with open("/etc/sysctl.conf", "r") as file_read:
            flag = False
            file_string = ""
            lastLine = ""
            for line in file_read:
                if isL(line) and "all.secure_redirects" in line:
                    if not tokenMatch('Cloud Raxak updated next line',lastLine):
                        file_string += "# Cloud Raxak updated next line\n"
                    file_string += "net.ipv4.conf.all.secure_redirects = 0\n"
                    flag = True
                else:
                    file_string += line
                    lastLine = line
            if not(flag):
                file_string += "# Cloud Raxak updated next line\n"
                file_string += "net.ipv4.conf.all.secure_redirects = 0\n"
            fout = None
            fout = open("/etc/sysctl.conf", 'wt')
            if fout != None:
                fout.write(file_string)
                fout.close()
        
def checkRule38527():
    if not CheckService("auditd"):
	return False

    file_path = '/etc/audit/audit.rules'
    if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    	file_path = '/etc/audit/rules.d/audit.rules'

    #Checking for keyword never,task.
    logging("Checking if system call auditing is disabled.")
    if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
        return False

    #Checking for any error in file.
    if "error" in runOnShell('auditctl -R '+file_path):
	logging("There is an error in "+file_path+", please fix it manually before remediating the rule.")
	return None

    if runOnShell("grep -w clock_settime "+file_path + "| grep -v '^#'") == "":
	logging("System is not configured to audit all attempts to alter system time through clock_settime.")
	return False

    logging("System is configured to audit all attempts to alter system time through clock_settime.")
    return True

def fixRule38527():
    if not InstallPackage("audit"):
        return None

    file_path = '/etc/audit/audit.rules'
    if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    	file_path = '/etc/audit/rules.d/audit.rules'

    #Checking for keyword never,task
    if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        logging(" Disabling the system call auditing to audit the events properly.")
        runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /' "+file_path)

    #Clear previous rules set. 
    runOnShell("auditctl -D")
    #Obtaining the data from file_path	
    audit_handler = open(file_path, "r")
    audit_file_rules = audit_handler.readlines()
    audit_handler.close()
    #Removing comments	
    #Removing redundant entries	from data
    filter_unique_audit_rule_list = []	
    for line in list(set(audit_file_rules)):
        line1 = line.strip('\n')
    	if (('-b 320' in line1) or ('-D' in line1) or ('#' in line1)):
		continue
    	
	final_line = re.sub("\s+" , " ", line1)
	filter_unique_audit_rule_list.append(final_line.strip())
    startup_line = "# This file contains the auditctl rules that are loaded\n # whenever the audit daemon is started via the initscripts.\n # The rules are simply the parameters that would be passed\n# to auditctl.\n # First rule - delete all\n-D\n\n # Increase the buffers to survive stress events.\n # Make this bigger for busy systems\n -b 320\n"
    
    with open(file_path, "w") as fhandler:
    	res = runOnShell("uname -m")
       	if "64" in res:
	    rule = "-a always,exit -F arch=b64 -S clock_settime -k audit_time_rules"
       	else:
	    rule = "-a always,exit -F arch=b32 -S clock_settime -k audit_time_rules"	
    	fhandler.write(startup_line)
	unique_data = '\n'.join(filter_unique_audit_rule_list)
	fhandler.write(unique_data)
	if rule not in filter_unique_audit_rule_list:
		fhandler.write("\n"+rule+"\n")
		
    fhandler.close()  					
    runOnShell("auditctl -R "+file_path)
    RunService("auditd")

def checkRule38528():
        log_value = runOnShell("sysctl net.ipv4.conf.all.log_martians")
	try:
	        value = log_value.split()[2]
	except IndexError:
                logging("System is not configured correctly to log Martian packets.")
		return False
	if atoi(value) == 0:
		logging("The presence of 'martian' packets as well as spoofed packets, source-routed packets,\
 and redirects could be dangerous for Network activity. Logging these packets enables this activity to be detected.")
		return False
        if atoi(value) != 1:
                logging("System is not configured correctly to log Martian packets.")
		return False
	logging("Loading the setting defined during boot time to verify the ICMP redirects acceptance after system reboot.")
        log_boot = runOnShell("grep -w net.ipv4.conf.all.log_martians /etc/sysctl.conf | grep -v '^#'")
        log_boot = log_boot.translate(string.maketrans("\n\t\r", "   "))
	if log_boot == "":
                logging("System is not configured correctly to log Martian packets.")
                return False
		
	if keyValEqMatch_new("net.ipv4.conf.all.log_martians","1",log_boot):
		logging("System is configured correctly to log Martian packets.")
		return True
	else:
                logging("System is not configured correctly to log Martian packets.")
		return False


def fixRule38528():
        runOnShell("sysctl -w net.ipv4.conf.all.log_martians=1")
        with open("/etc/sysctl.conf", "r") as file_read:
            flag = False
            file_string = ""
            lastLine = ""
            for line in file_read:
                if isL(line) and "log_martians" in line:
                    if not tokenMatch('Cloud Raxak updated next line',lastLine):
                        file_string += "# Cloud Raxak updated next line\n"
                    file_string += "net.ipv4.conf.all.log_martians = 1\n"
                    flag = True
                else:
                    file_string += line
                    lastLine = line
            if not(flag):
                if not tokenMatch('Cloud Raxak updated next line',lastLine):
                	file_string += "# Cloud Raxak updated next line\n"
                file_string += "net.ipv4.conf.all.log_martians = 1\n"
	fout = open("/etc/sysctl.conf", 'wt')
	if fout is not None:
	    fout.write(file_string)
	    fout.close()


def checkRule38529(default = 0):
        def_source_route = runOnShell("sysctl net.ipv4.conf.default.accept_source_route")
	try:
		value = def_source_route.split()[2]
	except IndexError:
		logging("Setting to reject default souce routed packets is not configured.")
	if atoi(value) == 1:
		logging("Do not allow source routed packets unless system is a Network Device.")
		return False
        if atoi(value) != default:
		logging("System is configured to accept IPv4 source-routed packets by default.")
		return False
	logging("Loading the setting defined during boot time to verify the default source route rejection after system reboot.")
        def_boot = runOnShell("grep -w net.ipv4.conf.default.accept_source_route /etc/sysctl.conf | grep -v '^#' ")
        def_boot = def_boot.translate(string.maketrans("\n\t\r", "   "))
	if def_boot == "":
		logging("System is configured to accept IPv4 source-routed packets by default.")
                return False
		
	if keyValEqMatch_new("net.ipv4.conf.default.accept_source_route","0",def_boot):
		logging("System is configured to reject IPv4 source-routed packets by default.")
		return True
	else:
		logging("System is configured to accept IPv4 source-routed packets by default.")
		return False

		
def fixRule38529():
        runOnShell("sysctl -w net.ipv4.conf.default.accept_source_route=0")
        with open("/etc/sysctl.conf", "r") as file_read:
            flag = False
            file_string = ""
            lastLine = ""
            for line in file_read:
                if isL(line) and "default.accept_source_route" in line:
                    if not tokenMatch('Cloud Raxak updated next line',lastLine):
                        file_string += "# Cloud Raxak updated next line\n"
                    file_string += "net.ipv4.conf.default.accept_source_route = 0\n"
                    flag = True
                else:
                    file_string += line
                    lastLine = line
            if not(flag):
                file_string += "# Cloud Raxak updated next line\n"
                file_string += "net.ipv4.conf.default.accept_source_route = 0\n"
            fout = None
            fout = open("/etc/sysctl.conf", 'wt')
            if fout != None:
                fout.write(file_string)
                fout.close()

def checkRule38530():
    if not CheckService("auditd"):
        return False

    file_path = '/etc/audit/audit.rules'
    if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    	file_path = '/etc/audit/rules.d/audit.rules'

    #Checking for keyword never,task.
    logging("Checking if system call auditing is disabled.")
    if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
        return False

    #Checking for any error in file.
    if "error" in runOnShell('auditctl -R '+file_path):
	logging("There is an error in "+file_path+", please fix it manually before remediating the rule.")
	return None


    if runOnShell("grep -w '/etc/localtime' "+file_path + "| grep -v '^#'") == "":
    	logging("System is not configured to audit all attempts to alter system time through /etc/localtime.")	
	return False

    logging("System is configured to audit all attempts to alter system time through /etc/localtime.")	
    return True


def fixRule38530():
        if not InstallPackage("audit"):
            return None

	if OsName.lower() == 'ubuntu':
		file_path = '/etc/audit/audit.rules'
	elif OsVersion >= (7,0):
		file_path = '/etc/audit/rules.d/audit.rules'
	else:
		file_path = '/etc/audit/audit.rules'

    	#Removing keyword never,task
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging(" Disabling the system call auditing to audit the events properly.")
        	runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /' "+file_path)

	#Clear previous rules set. 
	runOnShell("auditctl -D")
	#Obtaining the data from file_path	
	audit_handler = open(file_path, "r")
	audit_file_rules = audit_handler.readlines()
	audit_handler.close()
	#Removing redundant entries from data
	filter_unique_audit_rule_list = []	
	for line in list(set(audit_file_rules)):
		line1 = line.strip('\n')
		if (('-b 320' in line1) or ('-D' in line1) or ('#' in line1)):
			continue
		final_line = re.sub("\s+" , " ", line1)
		filter_unique_audit_rule_list.append(final_line.strip())

	startup_line = "# This file contains the auditctl rules that are loaded\n # whenever the audit daemon is started via the initscripts.\n # The rules are simply the parameters that would be passed\n# to auditctl.\n # First rule - delete all\n-D\n\n # Increase the buffers to survive stress events.\n # Make this bigger for busy systems\n -b 320\n"


	fhandler = open(file_path, "w")
	if fhandler != None:
		machine_bit = runOnShell("uname -m")
		if "64" in machine_bit:
			arch_variable = "arch=b64" 
		else:
			arch_variable = "arch=b32" 

		fhandler.write(startup_line)
		rule_1 = "-w /etc/localtime -p wa -k audit_time_rules"
		unique_data = '\n'.join(filter_unique_audit_rule_list)
		fhandler.write(unique_data)
		if rule_1 not in filter_unique_audit_rule_list:
			fhandler.write("\n"+rule_1+"\n")
		
	logging("Adding the audit account changes related rule to audit file "+file_path)
	fhandler.close()
	runOnShell("auditctl -R "+file_path)
    	RunService("auditd")


def checkRule38531():
    if not CheckService("auditd"):
        return False

    file_path = '/etc/audit/audit.rules'
    if (( OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    	file_path = '/etc/audit/rules.d/audit.rules'

    #Checking for keyword never,task.
    logging("Checking if system call auditing is disabled.")
    if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
        return False

    #Checking for any error in file.
    if "error" in runOnShell('auditctl -R '+file_path):
	logging("There is an error in "+file_path+", please fix it manually before remediating the rule.")
	return None

    res1 = runOnShell("auditctl -l | egrep '(/etc/passwd)' | grep -v '^#' ")
    res2 = runOnShell("auditctl -l | egrep '(/etc/shadow)' | grep -v '^#' ")
    res3 = runOnShell("auditctl -l | egrep '(/etc/group)'| grep -v '^#' ")
    res4 = runOnShell("auditctl -l | egrep '(/etc/gshadow)'| grep -v '^#' ")
    res5 = runOnShell("auditctl -l | egrep '(/etc/security/opasswd)'| grep -v '^#' ")
    if (res1 == "") or (res2 == "") or (res3 == "") or (res4 == "") or (res5 == ""):
	logging("System is not configured to audit account creation.")
	return False

    logging("System is configured to audit account creation.")
    return True	

def fixRule38531():
        if not InstallPackage("audit"):
            return None

	file_path = '/etc/audit/audit.rules'
	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		file_path = '/etc/audit/rules.d/audit.rules'

    	#Removing for keyword never,task
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging(" Disabling the system call auditing to audit the events properly.")
        	runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /' "+file_path)

	#Clear previous rules set. 
	runOnShell("auditctl -D")
	audit_handler = open(file_path, "r")
	audit_file_rules = audit_handler.readlines()
	audit_handler.close()
	#Removing redundant entries from data
	filter_unique_audit_rule_list = []	
	for line in list(set(audit_file_rules)):
		line1 = line.strip('\n')
		if (('-b 320' in line1) or ('-D' in line1) or ('#' in line1)):
			continue
		final_line = re.sub("\s+" , " ", line1)
		filter_unique_audit_rule_list.append(final_line.strip())

	startup_line = "# This file contains the auditctl rules that are loaded\n # whenever the audit daemon is started via the initscripts.\n # The rules are simply the parameters that would be passed\n# to auditctl.\n # First rule - delete all\n-D\n\n # Increase the buffers to survive stress events.\n # Make this bigger for busy systems\n -b 320\n"

	with open(file_path, "w") as fhandler:
		res = runOnShell("uname -m")
		if "64" in res:
			arch_variable = "arch=b64" 
		else:
			arch_variable = "arch=b32" 

		fhandler.write(startup_line)
		rule_1 ="-w /etc/group -p wa -k audit_account_changes"
		rule_2 = "-w /etc/passwd -p wa -k audit_account_changes"
		rule_3 = "-w /etc/gshadow -p wa -k audit_account_changes"
		rule_4 = "-w /etc/shadow -p wa -k audit_account_changes"
		rule_5 = "-w /etc/security/opasswd -p wa -k audit_account_changes"
		unique_data = '\n'.join(filter_unique_audit_rule_list)
		fhandler.write(unique_data)
		for rule in [rule_1,rule_2,rule_3,rule_4,rule_5]:
			if rule not in filter_unique_audit_rule_list:
				fhandler.write("\n"+rule+"\n")
			
	logging("Configuring the system to audit account changes.")	
	fhandler.close()
	runOnShell("auditctl -R "+file_path)
    	RunService("auditd")

def checkRule38532(default = 0):
        def_secure_value = runOnShell("sysctl net.ipv4.conf.default.secure_redirects")
	try:
		setting = def_secure_value.split()[2]
	except IndexError:
		logging("System is configured to accept ICMPv4 secure redirect packets by default.")
		return False
	if atoi(setting) == 1:
		logging("Accepting 'secure' ICMP redirects  has few legitimate uses. It should be disabled unless system is a Network Device.")
		return False
        if atoi(setting) != default:
		logging("System is configured to accept ICMPv4 secure redirect packets by default.")
		return False

	logging("Loading the setting defined during boot time to verify the default 'secure' ICMP redirects rejection after system reboot.")
        def_boot = runOnShell("grep -w net.ipv4.conf.default.secure_redirects /etc/sysctl.conf | grep -v '^#'")
        def_boot = def_boot.translate(string.maketrans("\n\t\r", "   "))
	if def_boot == "":
		logging("System is configured to accept ICMPv4 secure redirect packets by default.")
                return False
		
	if keyValEqMatch_new("net.ipv4.conf.default.secure_redirects","0",def_boot):
		logging("System is configured to reject ICMPv4 secure redirect packets by default.")
		return True
	else:
		logging("System is configured to accept ICMPv4 secure redirect packets by default.")
		return False


def fixRule38532():
        runOnShell("sysctl -w net.ipv4.conf.default.secure_redirects=0")
        with open("/etc/sysctl.conf", "r") as file_read:
            flag = False
            file_string = ""
            lastLine = ""
            for line in file_read:
                if isL(line) and "default.secure_redirects" in line:
                    if not tokenMatch('Cloud Raxak updated next line',lastLine):
                        file_string += "# Cloud Raxak updated next line\n"
                    file_string += "net.ipv4.conf.default.secure_redirects = 0\n"
                    flag = True
                else:
                    file_string += line
                    lastLine = line
            if not(flag):
                file_string += "# Cloud Raxak updated next line\n"
                file_string += "net.ipv4.conf.default.secure_redirects = 0\n"
            fout = None
            fout = open("/etc/sysctl.conf", 'wt')
            if fout != None:
                fout.write(file_string)
                fout.close()

def checkRule38533():
	def_redirect_value = runOnShell("sysctl net.ipv4.conf.default.accept_redirects")
	try:
		setting = def_redirect_value.split()[2]
	except IndexError:
		logging("System is not configured to ignore ICMPv4 redirect messages by default.")
		return False
        if atoi(setting) == 1:
		logging("Accepting ICMP redirects has few legitimate uses. It should be disabled unless system is a Network Device.")
		return False
        if atoi(setting) != 0:
		logging("System is not configured to ignore ICMPv4 redirect messages by default.")
		return False
	logging("Loading the setting defined during boot time to verify the default ICMP redirects rejection after system reboot.")
        def_boot = runOnShell("grep net.ipv4.conf.default.accept_redirects /etc/sysctl.conf")
        if "net.ipv4.conf.default.accept_redirects" not in def_boot:
		logging("System is not configured to ignore ICMPv4 redirect messages by default.")
                return False
        if "net.ipv4.conf.default.accept_redirects = 0" in def_boot:
		logging("System is configured to ignore ICMPv4 redirect messages by default.")
                return True
        else:
		logging("System is not configured to ignore ICMPv4 redirect messages by default.")
                return False


def fixRule38533():
        runOnShell("sysctl net.ipv4.conf.default.accept_redirects=0")
        with open("/etc/sysctl.conf", "r") as file_read:
            flag = False
            file_string = ""
            lastLine = ""
            for line in file_read:
                if isL(line) and "net.ipv4.conf.default.accept_redirects" in line:
                    if not tokenMatch('Cloud Raxak updated next line',lastLine):
                        file_string += "# Cloud Raxak updated next line\n"
                    file_string += "net.ipv4.conf.default.accept_redirects = 0\n"
                    flag = True
                else:
                    file_string += line
                    lastLine = line
            if not(flag):
                file_string += "# Cloud Raxak updated next line\n"
                file_string += "net.ipv4.conf.default.accept_redirects = 0\n"
            fout = None
            fout = open("/etc/sysctl.conf", 'wt')
            if fout != None:
                fout.write(file_string)
                fout.close()

def checkRule38534():
    	if not CheckService("auditd"):
		return False

    	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Checking for keyword never,task.
    	logging("Checking if system call auditing is disabled.")
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
        	return False

    	#Checking for any error in file.
    	if "error" in runOnShell('auditctl -R '+file_path):
		logging("There is an error in "+file_path+", please fix it manually before remediating the rule.")
		return None

	res1 = runOnShell("auditctl -l | egrep '(/etc/passwd)'| grep -v '^#' ")
    	res2 = runOnShell("auditctl -l | egrep '(/etc/shadow)'| grep -v '^#' ")
    	res3 = runOnShell("auditctl -l | egrep '(/etc/group)'| grep -v '^#' ")
    	res4 = runOnShell("auditctl -l | egrep '(/etc/gshadow)'| grep -v '^#' ")
    	res5 = runOnShell("auditctl -l | egrep '(/etc/security/opasswd)'| grep -v '^#' ")
    	if (res1 == "") or (res2 == "") or (res3 == "") or (res4 == "") or (res5 == ""):
	    logging("System is not configured to audit account modification.")
	    return False

	logging("System is configured to audit account modification.")
    	return True	

def fixRule38534():
        if not InstallPackage("audit"):
            return None

    	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Removing for keyword never,task
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging(" Disabling the system call auditing to audit the events properly.")
        	runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /' "+file_path)

	#Clear previous rules set. 
	runOnShell("auditctl -D")
	#Obtaining the data from file_path	
	audit_handler = open(file_path, "r")
	audit_file_rules = audit_handler.readlines()
	audit_handler.close()
	#Removing redundant entries from data
	filter_unique_audit_rule_list = []	
	for line in list(set(audit_file_rules)):
		line1 = line.strip('\n')
		if (('-b 320' in line1) or ('-D' in line1) or ('#' in line1)):
			continue
		final_line = re.sub("\s+" , " ", line1)
		filter_unique_audit_rule_list.append(final_line.strip())

	startup_line = "# This file contains the auditctl rules that are loaded\n # whenever the audit daemon is started via the initscripts.\n # The rules are simply the parameters that would be passed\n# to auditctl.\n # First rule - delete all\n-D\n\n # Increase the buffers to survive stress events.\n # Make this bigger for busy systems\n -b 320\n"

	with open(file_path, "w") as fhandler:
		res = runOnShell("uname -m")
		if "64" in res:
			arch_variable = "arch=b64" 
		else:
			arch_variable = "arch=b32" 

		fhandler.write(startup_line)
		rule_1 ="-w /etc/group -p wa -k audit_account_changes"
		rule_2 = "-w /etc/passwd -p wa -k audit_account_changes"
		rule_3 = "-w /etc/gshadow -p wa -k audit_account_changes"
		rule_4 = "-w /etc/shadow -p wa -k audit_account_changes"
		rule_5 = "-w /etc/security/opasswd -p wa -k audit_account_changes"
		unique_data = '\n'.join(filter_unique_audit_rule_list)
		fhandler.write(unique_data)
		for rule in [rule_1,rule_2,rule_3,rule_4,rule_5]:
			if rule not in filter_unique_audit_rule_list:
				fhandler.write("\n"+rule+"\n")

	logging("Configuring the system to audit account modifications.")	
	fhandler.close()
	runOnShell("auditctl -R "+file_path)
    	RunService("auditd")

def checkRule38535():
        icmp_echo_value = runOnShell("sysctl net.ipv4.icmp_echo_ignore_broadcasts")
	try:
		setting = icmp_echo_value.split()[2]
	except IndexError:
		logging("System response to ICMP4 send to broadcast address is not configured.")
		logging()
		return False
        if atoi(setting) == 0:
		logging("Ignoring ICMP4 echo requests (pings) sent to broadcast or multicast addresses makes the system slightly more difficult to\
 enumerate on the network and prevent the host from joining a smurf attack.To disable the ping to broadcast or multicast addresses kindly remediate the rule.")
		return False
        if atoi(setting) != 1:
		logging("System response to ICMP4 send to broadcast address is not configured correctly.")
		return False
	logging("Loading the setting defined during boot time to verify the system response to ICMP4 send to broadcast address after system reboot.")
        icmp_boot = runOnShell("grep -w net.ipv4.icmp_echo_ignore_broadcasts /etc/sysctl.conf | grep -v '^#'")
        icmp_boot = icmp_boot.translate(string.maketrans("\n\t\r", "   "))
	if icmp_boot == "":
		logging("System response to ICMP4 send to broadcast address is not configured.")
                return False
		
	if keyValEqMatch_new("net.ipv4.icmp_echo_ignore_broadcasts","1",icmp_boot):
                logging("System response to ICMP4 send to broadcast address is configured correctly.")
		return True
	else:
                logging("System response to ICMP4 send to broadcast address is not configured correctly.")
		return False


def fixRule38535():
        runOnShell("sysctl -w net.ipv4.icmp_echo_ignore_broadcasts=1")
        with open("/etc/sysctl.conf", "r") as file_read:
            flag = False
            file_string = ""
            lastLine = ""
            for line in file_read:
                if isL(line) and "icmp_echo_ignore_broadcasts" in line:
                    if not tokenMatch('Cloud Raxak updated next line',lastLine):
                        file_string += "# Cloud Raxak updated next line\n"
                    file_string += "net.ipv4.icmp_echo_ignore_broadcasts = 1\n"
                    flag = True
                else:
                    file_string += line
                    lastLine = line
            if not(flag):
                file_string += "# Cloud Raxak updated next line\n"
                file_string += "net.ipv4.icmp_echo_ignore_broadcasts = 1\n"
            fout = None
            fout = open("/etc/sysctl.conf", 'wt')
            if fout != None:
                fout.write(file_string)
                fout.close()

def checkRule38536():
    	if not CheckService("auditd"):
		return False

    	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Checking for keyword never,task.
    	logging("Checking if system call auditing is disabled.")
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
        	return False

    	#Checking for any error in file.
    	if "error" in runOnShell('auditctl -R '+file_path):
		logging("There is an error in "+file_path+", please fix it manually before remediating the rule.")
		return None

	runOnShell("auditctl -l")
	res1 = runOnShell("auditctl -l | egrep '(/etc/passwd)'| grep -v '^#' ")
    	res2 = runOnShell("auditctl -l | egrep '(/etc/shadow)'| grep -v '^#' ")
    	res3 = runOnShell("auditctl -l | egrep '(/etc/group)'| grep -v '^#' ")
    	res4 = runOnShell("auditctl -l | egrep '(/etc/gshadow)'| grep -v '^#' ")
    	res5 = runOnShell("auditctl -l | egrep '(/etc/security/opasswd)'| grep -v '^#' ")
    	if (res1 == "") or (res2 == "") or (res3 == "") or (res4 == "") or (res5 == ""):
	    logging("System is not configured to audit account disabling actions.")	
	    return False
	logging("System is configured to audit account disabling actions.")	
    	return True	


def fixRule38536():
        if not InstallPackage("audit"):
            return None

    	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Removing for keyword never,task
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging(" Disabling the system call auditing to audit the events properly.")
        	runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /' "+file_path)

	#Clear previous rules set. 
	runOnShell("auditctl -D")
	#Obtaining the data from file_path	
	audit_handler = open(file_path, "r")
	audit_file_rules = audit_handler.readlines()
	audit_handler.close()
	#Removing redundant entries from data
	filter_unique_audit_rule_list = []	
	for line in list(set(audit_file_rules)):
		line1 = line.strip('\n')
		if (('-b 320' in line1) or ('-D' in line1) or ('#' in line1)):
			continue
		final_line = re.sub("\s+" , " ", line1)
		filter_unique_audit_rule_list.append(final_line.strip())
		#filter_unique_audit_rule_list.append(line)

	startup_line = "# This file contains the auditctl rules that are loaded\n # whenever the audit daemon is started via the initscripts.\n # The rules are simply the parameters that would be passed\n# to auditctl.\n # First rule - delete all\n-D\n\n # Increase the buffers to survive stress events.\n # Make this bigger for busy systems\n -b 320\n"

	with open(file_path, "w") as fhandler:
		res = runOnShell("uname -m")
		if "64" in res:
			arch_variable = "arch=b64" 
		else:
			arch_variable = "arch=b32" 

		fhandler.write(startup_line)
		rule_1 ="-w /etc/group -p wa -k audit_account_changes"
		rule_2 = "-w /etc/passwd -p wa -k audit_account_changes"
		rule_3 = "-w /etc/gshadow -p wa -k audit_account_changes"
		rule_4 = "-w /etc/shadow -p wa -k audit_account_changes"
		rule_5 = "-w /etc/security/opasswd -p wa -k audit_account_changes"
		unique_data = '\n'.join(filter_unique_audit_rule_list)
		fhandler.write(unique_data)
		for rule in [rule_1,rule_2,rule_3,rule_4,rule_5]:
			if rule not in filter_unique_audit_rule_list:
				fhandler.write("\n"+rule+"\n")
		
	logging("Configuring the system to audit account disabling actions.")	
	fhandler.close()
	runOnShell("auditctl -R "+file_path)
	runOnShell("auditctl -l")
    	RunService("auditd")

def checkRule38537():
        icmp_value = runOnShell("sysctl net.ipv4.icmp_ignore_bogus_error_responses")
	try:
		setting = icmp_value.split()[2]
	except IndexError:
		logging("System is not configured to ignore ICMP4 bogus error response.")
		return False
        if atoi(setting) == 0:
		logging("To Protect the system from bad ICMP4 messages kindly remediate the rule.") 
		return False
        if atoi(setting) != 1:
		logging("System is not configured correctly to ignore ICMP4 bogus error response.")
		return False
	logging("Loading the setting defined during boot time to verify the system configuration to ICMP4 bogus error response after system reboot.")
        icmp_boot = runOnShell("grep -w net.ipv4.icmp_ignore_bogus_error_responses /etc/sysctl.conf | grep -v '^#'")
        icmp_boot = icmp_boot.translate(string.maketrans("\n\t\r", "   "))
	if icmp_boot == "":
		logging("System is not configured to ignore ICMP4 bogus error response.")
                return False
		
	if keyValEqMatch_new("net.ipv4.icmp_ignore_bogus_error_responses","1",icmp_boot):
                logging("System is configured correctly to ignore ICMP4 bogus error response.")
		return True
	else:
                logging("System is not configured correctly to ignore ICMP4 bogus error response.")
		return False


def fixRule38537():
    runOnShell("sysctl -w net.ipv4.icmp_ignore_bogus_error_responses=1")

    with open("/etc/sysctl.conf", "r") as file_read:
        flag = False
       	file_string = ""
        lastLine = ""
       	for line in file_read:
            if isL(line) and "icmp_ignore_bogus_error_responses" in line:
                if not tokenMatch('Cloud Raxak updated next line',lastLine):
       	            file_string += "# Cloud Raxak updated next line\n"
               	file_string += "net.ipv4.icmp_ignore_bogus_error_responses = 1\n"
                flag = True
       	    else:
               	file_string += line
                lastLine = line
       	if not(flag):
            file_string += "# Cloud Raxak updated next line\n"
            file_string += "net.ipv4.icmp_ignore_bogus_error_responses = 1\n"
       	fout = None
       	fout = open("/etc/sysctl.conf", 'wt')
       	if fout is not None:
            fout.write(file_string)
            fout.close()

def checkRule38538():
    	if not CheckService("auditd"):
		return False

    	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Checking for keyword never,task.
    	logging("Checking if system call auditing is disabled.")
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
        	return False

    	#Checking for any error in file.
    	if "error" in runOnShell('auditctl -R '+file_path):
		logging("There is an error in "+file_path+", please fix it manually before remediating the rule.")
		return None

	res1 = runOnShell("auditctl -l | egrep '(/etc/passwd)'| grep -v '^#' ")
    	res2 = runOnShell("auditctl -l | egrep '(/etc/shadow)'| grep -v '^#' ")
    	res3 = runOnShell("auditctl -l | egrep '(/etc/group)'| grep -v '^#' ")
    	res4 = runOnShell("auditctl -l | egrep '(/etc/gshadow)'| grep -v '^#' ")
    	res5 = runOnShell("auditctl -l | egrep '(/etc/security/opasswd)'| grep -v '^#' ")
    	if (res1 == "") or (res2 == "") or (res3 == "") or (res4 == "") or (res5 == ""):
	    logging("System is not configured to audit the account termination.")	
	    return False

	logging("System is configured to audit the account termination.")	
    	return True	
	
def fixRule38538():
        if not InstallPackage("audit"):
            return None

    	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Removing for keyword never,task
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging(" Disabling the system call auditing to audit the events properly.")
        	runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /' "+file_path)

	#Clear previous rules set. 
	runOnShell("auditctl -D")
	#Obtaining the data from file_path	
	audit_handler = open(file_path, "r")
	audit_file_rules = audit_handler.readlines()
	audit_handler.close()
	#Removing redundant entries from data
	filter_unique_audit_rule_list = []	
	for line in list(set(audit_file_rules)):
		line1 = line.strip('\n')
		if (('-b 320' in line1) or ('-D' in line1) or ('#' in line1)):
			continue
		final_line = re.sub("\s+" , " ", line1)
		filter_unique_audit_rule_list.append(final_line.strip())

	startup_line = "# This file contains the auditctl rules that are loaded\n # whenever the audit daemon is started via the initscripts.\n # The rules are simply the parameters that would be passed\n# to auditctl.\n # First rule - delete all\n-D\n\n # Increase the buffers to survive stress events.\n # Make this bigger for busy systems\n -b 320\n"

	with open(file_path, "w") as fhandler:
		res = runOnShell("uname -m")
		if "64" in res:
			arch_variable = "arch=b64" 
		else:
			arch_variable = "arch=b32" 
		fhandler.write(startup_line)
		rule_1 ="-w /etc/group -p wa -k audit_account_changes"
		rule_2 = "-w /etc/passwd -p wa -k audit_account_changes"
		rule_3 = "-w /etc/gshadow -p wa -k audit_account_changes"
		rule_4 = "-w /etc/shadow -p wa -k audit_account_changes"
		rule_5 = "-w /etc/security/opasswd -p wa -k audit_account_changes"
		unique_data = '\n'.join(filter_unique_audit_rule_list)
		fhandler.write(unique_data)
		for rule in [rule_1,rule_2,rule_3,rule_4,rule_5]:
			if rule not in filter_unique_audit_rule_list:
				fhandler.write("\n"+rule+"\n")

	logging("Configuring the system to audit account termination.")	
	fhandler.close()
	runOnShell("auditctl -R "+file_path)
    	RunService("auditd")

def checkRule38539():
        tcp_value = runOnShell("sysctl net.ipv4.tcp_syncookies")
	try:
		setting = tcp_value.split()[2]
	except IndexError:
		logging("System is not configured to use TCP syncookies when experiencing a TCP SYN flood.")
		return False
        if atoi(setting) == 0:
		logging("This feature is activated when a flood condition is detected, and enables the system to continue servicing valid connection requests.\
To Enables syncookies for protection against syn flood attacks, kindly remediate the rule.")
		return False
        if atoi(setting) != 1:
		logging("System is not configured correctly to use TCP syncookies when experiencing a TCP SYN flood.")
		return False
	logging("Loading the setting defined during boot time to verify the system configuration to use TCP syncookies during TCP SYNflood after system reboot.")
        tcp_boot = runOnShell("grep -w net.ipv4.tcp_syncookies /etc/sysctl.conf | grep -v '^#'")
        tcp_boot = tcp_boot.translate(string.maketrans("\n\t\r", "   "))
	if tcp_boot == "":
		logging("System is not configured to use TCP syncookies when experiencing a TCP SYN flood.")
                return False
		
	if keyValEqMatch_new("net.ipv4.tcp_syncookies","1",tcp_boot):
		logging("System is configured to use TCP syncookies when experiencing a TCP SYN flood.")
		return True
	else:
		logging("System is not configured correctly to use TCP syncookies when experiencing a TCP SYN flood.")
		return False


def fixRule38539():
    runOnShell("sysctl -w net.ipv4.tcp_syncookies=1")
    with open("/etc/sysctl.conf", "r") as file_read:
        flag = False
        file_string = ""
        lastLine = ""
        for line in file_read:
            if isL(line) and "tcp_syncookies" in line:
                if not tokenMatch('Cloud Raxak updated next line',lastLine):
                    file_string += "# Cloud Raxak updated next line\n"
                file_string += "net.ipv4.tcp_syncookies = 1\n"
                flag = True
            else:
                file_string += line
                lastLine = line
        if not(flag):
            file_string += "# Cloud Raxak updated next line\n"
            file_string += "net.ipv4.tcp_syncookies = 1\n"
        fout = None
        fout = open("/etc/sysctl.conf", 'wt')
        if fout != None:
            fout.write(file_string)
            fout.close()

def checkRule38540():
    	if not CheckService("auditd"):
		return False

    	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Checking for keyword never,task.
    	logging("Checking if system call auditing is disabled.")
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
        	return False

    	#Checking for any error in file.
    	if "error" in runOnShell('auditctl -R '+file_path):
		logging("There is an error in "+file_path+", please fix it manually before remediating the rule.")
		return None

	res1 = runOnShell("auditctl -l | egrep '(sethostname|setdomainname)'| grep -v '^#'")
    	res2 = runOnShell("auditctl -l | egrep '(/etc/issue[^.])'| grep -v '^#'")
    	res3 = runOnShell("auditctl -l | egrep '(/etc/issue.net)'| grep -v '^#'")
    	res4 = runOnShell("auditctl -l | egrep '(/etc/hosts)'| grep -v '^#'")
	if OsName.lower() == "ubuntu":
    		res5 = runOnShell("auditctl -l | egrep '(/etc/network/interfaces)'| grep -v '^#'")
	else:	
    		res5 = runOnShell("auditctl -l | egrep '(/etc/sysconfig/network)'| grep -v '^#'")
    	if (res1 == "") or (res2 == "") or (res3 == "") or (res4 == "") or (res5 == ""):
	    logging("System is not configured to audit modifications to the systems network configuration.")
	    return False

	logging("System is configured to audit modifications to the systems network configuration.")
    	return True	
	
def fixRule38540():
        if not InstallPackage("audit"):
            return None

	rule_add = "-w /etc/sysconfig/network -p wa -k audit_network_modifications"
	if OsName.lower() == 'ubuntu':
		file_path = '/etc/audit/audit.rules'
		rule_add = "-w /etc/network/interfaces -p wa -k audit_network_modifications"
	else:
		if OsVersion >= (7,0):
			file_path = '/etc/audit/rules.d/audit.rules'
		else:
			file_path = '/etc/audit/audit.rules'

    	#Removing for keyword never,task
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging(" Disabling the system call auditing to audit the events properly.")
        	runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /' "+file_path)

	#Clear previous rules set. 
	runOnShell("auditctl -D")
	#Obtaining the data from file_path	
	audit_handler = open(file_path, "r")
	audit_file_rules = audit_handler.readlines()
	audit_handler.close()
	#Removing redundant entries from data
	filter_unique_audit_rule_list = []	
	for line in list(set(audit_file_rules)):
		line1 = line.strip('\n')
		if (('-b 320' in line1) or ('-D' in line1) or ('#' in line1)):
			continue
		final_line = re.sub("\s+" , " ", line1)
		filter_unique_audit_rule_list.append(final_line.strip())

	startup_line = "# This file contains the auditctl rules that are loaded\n # whenever the audit daemon is started via the initscripts.\n # The rules are simply the parameters that would be passed\n# to auditctl.\n # First rule - delete all\n-D\n\n # Increase the buffers to survive stress events.\n # Make this bigger for busy systems\n -b 320\n"

	with open(file_path, "w") as fhandler:
		res = runOnShell("uname -m")
		if "64" in res:
			arch_variable = "arch=b64" 
		else:
			arch_variable = "arch=b32" 

		fhandler.write(startup_line)
		rule_1 ="-a always,exit -F "+arch_variable+" -S sethostname -S setdomainname -k audit_network_modifications"
		rule_2 = "-w /etc/issue -p wa -k audit_network_modifications"
		rule_3 = "-w /etc/issue.net -p wa -k audit_network_modifications"
		rule_4 = "-w /etc/hosts -p wa -k audit_network_modifications"
		rule_5 = rule_add
		unique_data = '\n'.join(filter_unique_audit_rule_list)
		fhandler.write(unique_data)
		for rule in [rule_1,rule_2,rule_3,rule_4,rule_5]:
			if rule not in filter_unique_audit_rule_list:
				fhandler.write("\n"+rule+"\n")
			
	logging("Configuring the system to audit modifications to the systems network configuration.")
	fhandler.close()
	runOnShell("auditctl -R "+file_path)
    	RunService("auditd")

def checkRule38541():
    	if not CheckService("auditd"):
		return False
    	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Checking for keyword never,task.
    	logging("Checking if system call auditing is disabled.")
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
        	return False

    	#Checking for any error in file.
    	if "error" in runOnShell('auditctl -R '+file_path):
		logging("There is an error in "+file_path+", please fix it manually before remediating the rule.")
		return None

	if runOnShell("grep -w '/etc/selinux' "+file_path + "| grep -v '^#'") == "":
		logging("System is not configured to audit modifications to the systems Mandatory Access Control (MAC) configuration (SELinux).")
		return False
	logging("System is configured to audit modifications to the systems Mandatory Access Control (MAC) configuration (SELinux).")
	return True 


def fixRule38541():
        if not InstallPackage("audit"):
            return None

	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Removing for keyword never,task
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging(" Disabling the system call auditing to audit the events properly.")
        	runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /' "+file_path)

	#Clear previous rules set. 
	runOnShell("auditctl -D")
	#Obtaining the data from file_path	
	audit_handler = open(file_path, "r")
	audit_file_rules = audit_handler.readlines()
	audit_handler.close()
	#Removing redundant entries	from data
	filter_unique_audit_rule_list = []	
	for line in list(set(audit_file_rules)):
		line1 = line.strip('\n')
		if (('-b 320' in line1) or ('-D' in line1) or ('#' in line1)):
			continue
		final_line = re.sub("\s+" , " ", line1)
		filter_unique_audit_rule_list.append(final_line.strip())

	startup_line = "# This file contains the auditctl rules that are loaded\n # whenever the audit daemon is started via the initscripts.\n # The rules are simply the parameters that would be passed\n# to auditctl.\n # First rule - delete all\n-D\n\n # Increase the buffers to survive stress events.\n # Make this bigger for busy systems\n -b 320\n"

	with open(file_path, "w") as fhandler:
		res = runOnShell("uname -m")
		if "64" in res:
			arch_variable = "arch=b64" 
		else:
			arch_variable = "arch=b32" 
		fhandler.write(startup_line)
		rule_1 = "-w /etc/selinux/ -p wa -k MAC-policy"
		unique_data = '\n'.join(filter_unique_audit_rule_list)
		fhandler.write(unique_data)
		if rule_1 not in filter_unique_audit_rule_list:
			fhandler.write("\n"+rule_1+"\n")

	logging("Configuring the system to audit modifications to the systems Mandatory Access Control (MAC) configuration (SELinux).")
	fhandler.close()
	runOnShell("auditctl -R "+file_path)
    	RunService("auditd")

def checkRule38542():
        reverse_path_value = runOnShell("sysctl net.ipv4.conf.all.rp_filter")
	try:
		setting = reverse_path_value.split()[2]
	except IndexError:
		logging("Reverse path filter for IPv4 network is not configured.")
		return False
        if atoi(setting) != 1:
		logging("Reverse path filter for IPv4 network is not configured correctly.")
	        return False
        logging("Loading the setting defined during boot time to verify \
the system configuration for reverse path filter of IPv4 network after system reboot.")
        reverse_boot = runOnShell("grep -w net.ipv4.conf.all.rp_filter /etc/sysctl.conf | grep -v '^#'")
        reverse_boot = reverse_boot.translate(string.maketrans("\n\t\r", "   "))
	if reverse_boot == "":
       		logging("Reverse path filter for IPv4 network is not configured.")
                return False
		
	if keyValEqMatch_new("net.ipv4.conf.all.rp_filter","1",reverse_boot):
                logging("Reverse path filter for IPv4 network is configured correctly.")
		return True
	else:
                logging("Reverse path filter for IPv4 network is not configured correctly.")
		return False

def fixRule38542():
    logging("Updating the runtime status of the 'reverse path filter for IPv4 network' kernel.")
    runOnShell("sysctl -w net.ipv4.conf.all.rp_filter=1")
    with open("/etc/sysctl.conf", "r") as file_read:
        flag = False
        file_string = ""
        lastLine = ""
        for line in file_read:
            if isL(line) and "all.rp_filter" in line:
                if not tokenMatch('Cloud Raxak updated next line',lastLine):
                    file_string += "# Cloud Raxak updated next line\n"
                file_string += "net.ipv4.conf.all.rp_filter = 1\n"
                flag = True
            else:
                file_string += line
                lastLine = line
        if not(flag):
            if not tokenMatch('Cloud Raxak updated next line',lastLine):
            	file_string += "# Cloud Raxak updated next line\n"
            file_string += "net.ipv4.conf.all.rp_filter = 1\n"
    fout = open("/etc/sysctl.conf", 'wt')
    if fout != None:
	fout.write(file_string)
	fout.close()

def checkRule38543():
    	if not CheckService("auditd"):
		return False

	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'
	
    	#Checking for keyword never,task.
    	logging("Checking if system call auditing is disabled.")
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
       		return False

	if "error" in runOnShell('auditctl -R '+file_path):
		logging("There is an error in "+file_path+", please fix it manually before remediating the rule.")
		return None

	return_flag = True
	uid_out_user = runOnShell("grep -w chmod "+ file_path + "| grep " + "'auid>="+uid_value+ "' | grep -v '^#' ")
	if uid_out_user == "":
		logging("System is not configured to audit all discretionary access control permission modifications for user using chmod.")	
		return_flag = False

	uid_out_root = runOnShell("grep -w chmod " + file_path + "| grep 'auid=0' | grep -v '^#'")
	if uid_out_root == "":
		logging("System is not configured to audit all discretionary access control permission modifications for root user using chmod.")	
		return_flag = False

	if not return_flag:
		return False

	logging("System is configured to audit all discretionary access control permission modifications using chmod.")	
	return True

def fixRule38543():
        if not InstallPackage("audit"):
            return None

	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Removing for keyword never,task
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging(" Disabling the system call auditing to audit the events properly.")
        	runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /' "+file_path)

	#Clear previous rules set. 
	runOnShell("auditctl -D")
	#Obtaining the data from file_path	
	audit_handler = open(file_path, "r")
	audit_file_rules = audit_handler.readlines()
	audit_handler.close()
	#Removing redundant entries from data
	filter_unique_audit_rule_list = []	
	for line in list(set(audit_file_rules)):
		line1 = line.strip('\n')
		if (('-b 320' in line1) or ('-D' in line1) or ('#' in line1)):
			continue
		#final_line = re.sub("\s\s+" , " ", line1)
		final_line = re.sub("\s+" , " ", line1)
		filter_unique_audit_rule_list.append(final_line.strip())
	startup_line = "# This file contains the auditctl rules that are loaded\n # whenever the audit daemon is started via the initscripts.\n # The rules are simply the parameters that would be passed\n# to auditctl.\n # First rule - delete all\n-D\n\n # Increase the buffers to survive stress events.\n # Make this bigger for busy systems\n -b 320\n"

	with open(file_path, "w") as fhandler:
		res = runOnShell("uname -m")
		if "64" in res:
			arch_variable = "arch=b64" 
		else:
			arch_variable = "arch=b32" 
		fhandler.write(startup_line)
		rule_1 = "-a always,exit -F " + arch_variable + " -S chmod -F auid>="+uid_value+" -F auid!=4294967295 -k perm_mod"
		rule_2 = "-a always,exit -F "+arch_variable+" -S chmod -F auid=0 -k perm_mod"
		unique_data = '\n'.join(filter_unique_audit_rule_list)
		fhandler.write(unique_data)
		for rule in [rule_1,rule_2]:
			if rule not in filter_unique_audit_rule_list:
				fhandler.write("\n"+rule+"\n")

	logging("Configuring the system to audit all discretionary access control permission modifications using chmod.")
	fhandler.close()
	runOnShell("auditctl -R "+file_path)
    	RunService("auditd")


def checkRule38544():
        conf_default_value = runOnShell("sysctl net.ipv4.conf.default.rp_filter")
	try:
		setting = conf_default_value.split()[2]
	except IndexError:
		logging("Reserve-path filter for IPv4 network traffic by default is not configured.")
		return False
        if atoi(setting) == 0:
		logging("Unless this host serves as a network device, use reserve-path filter for IPv4. \
To disable the all redirects in case system is not a network device, please remediate the rule.")
		return False
        if atoi(setting) != 1:
		logging("Reserve-path filter for IPv4 network traffic by default is not configured correctly.")
		return False
        logging("Loading the setting defined during boot time to verify the system configuration for reverse path filter of IPv4 network by default after system reboot.")
        reverse_boot = runOnShell("grep -w net.ipv4.conf.default.rp_filter /etc/sysctl.conf | grep -v '^#'")
        reverse_boot = reverse_boot.translate(string.maketrans("\n\t\r", "   "))
	if reverse_boot == "":
        	logging("Reverse path filter for IPv4 network traffic by default is not configured.")
                return False
		
	if keyValEqMatch_new("net.ipv4.conf.default.rp_filter","1",reverse_boot):
                logging("Reverse path filter for IPv4 network traffic by default is configured correctly.")
		return True
	else:
                logging("Reverse path filter for IPv4 network traffic by default is not configured correctly.")
		return False


def fixRule38544():
    runOnShell("sysctl -w net.ipv4.conf.default.rp_filter=1")
    with open("/etc/sysctl.conf", "r") as file_read:
        flag = False
        file_string = ""
        lastLine = ""
        for line in file_read:
            if isL(line) and "default.rp_filter" in line:
                if not tokenMatch('Cloud Raxak updated next line',lastLine):
                    file_string += "# Cloud Raxak updated next line\n"
                file_string += "net.ipv4.conf.default.rp_filter = 1\n"
                flag = True
            else:
                file_string += line
                lastLine = line
        if not(flag):
            file_string += "# Cloud Raxak updated next line\n"
            file_string += "net.ipv4.conf.default.rp_filter = 1\n"
        fout = None
        fout = open("/etc/sysctl.conf", 'wt')
        if fout != None:
            fout.write(file_string)
            fout.close()

def checkRule38545():
    	if not CheckService("auditd"):
		return False

	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Checking for keyword never,task.
    	logging("Checking if system call auditing is disabled.")
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
        	return False

    	#Checking for any error in file.
    	if "error" in runOnShell('auditctl -R '+file_path):
		logging("There is an error in "+file_path+", please fix it manually before remediating the rule.")
		return None

	return_flag = True
	uid_out_user = runOnShell("grep -w chown "+ file_path + "| grep " + "'auid>="+uid_value+ "' | grep -v '^#' ")
	if uid_out_user == "":
		logging("System is not configured to audit all discretionary access control permission modifications for user using chown.")	
		return_flag = False

	uid_out_root = runOnShell("grep -w chown " + file_path + "| grep 'auid=0' | grep -v '^#'")
	if uid_out_root == "":
		logging("System is not configured to audit all discretionary access control permission modifications for root user using chown.")	
		return_flag = False

	if not return_flag:
		return False

	logging("System is configured to audit all discretionary access control permission modifications using chown")
	return True

def fixRule38545():
        if not InstallPackage("audit"):
            return None

	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Removing for keyword never,task
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging(" Disabling the system call auditing to audit the events properly.")
        	runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /' "+file_path)

	#Clear previous rules set. 
	runOnShell("auditctl -D")
	#Obtaining the data from file_path	
	audit_handler = open(file_path, "r")
	audit_file_rules = audit_handler.readlines()
	audit_handler.close()
	 #Removing redundant entries from data
	filter_unique_audit_rule_list = []	
	for line in list(set(audit_file_rules)):
		line1 = line.strip('\n')
		if (('-b 320' in line1) or ('-D' in line1) or ('#' in line1)):
			continue
		final_line = re.sub("\s+" , " ", line1)
		filter_unique_audit_rule_list.append(final_line.strip())

	startup_line = "# This file contains the auditctl rules that are loaded\n # whenever the audit daemon is started via the initscripts.\n # The rules are simply the parameters that would be passed\n# to auditctl.\n # First rule - delete all\n-D\n\n # Increase the buffers to survive stress events.\n # Make this bigger for busy systems\n -b 320\n"
		
	with open(file_path, "w") as fhandler:
		res = runOnShell("uname -m")
		if "64" in res:
			arch_variable = "arch=b64" 
		else:
			arch_variable = "arch=b32" 
		
		fhandler.write(startup_line)
		rule_1 = "-a always,exit -F " + arch_variable + " -S chown -F auid>="+uid_value+" -F auid!=4294967295 -k perm_mod"
		rule_2 = "-a always,exit -F "+arch_variable+" -S chown -F auid=0 -k perm_mod"
		unique_data = '\n'.join(filter_unique_audit_rule_list)
		fhandler.write(unique_data)
		for rule in [rule_1,rule_2]:
			if rule not in filter_unique_audit_rule_list:
				fhandler.write("\n"+rule+"\n")
	logging("Configuring the system to audit all discretionary access control permission modifications using chown.")
	fhandler.close()
	runOnShell("auditctl -R "+file_path)
    	RunService("auditd")

def checkRule38546():
	logging("Checking if IPv6 kernel module is enabled.")
	res_enable = runOnShell('ip -6 addr show')
	# flag for  checking IPv6 in /etc/hosts.
	flag_ipv6 = True
	if res_enable != "":
	    flag_ipv6 = False
	    logging("Checking if IPv6 kernel module is in use.")
	    if (( OsVersion >= (7,0) ) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		check_connection = runOnShell("ss -6taupn | grep ESTAB")
	    else:
		#Dispaly the ESTABLISHED connections for Inet6 (address family for IPv6)
		check_connection = runOnShell("netstat -tauplnA inet6 | grep ESTABLISHED")
	    if check_connection != "":
		logging("The system uses IPv6, so the rule is not applicable.")
		return None
	    else:
		logging("IPv6 kernel module is not disabled.")
		return False
	if flag_ipv6:
		check_ipv6 = runOnShell("cat /etc/hosts | grep :: | grep -v '#'")
		if check_ipv6 != "":
			logging("IPv6 kernel module is not disabled.")
			return False 
		logging("IPv6 kernel module is disabled.")
		return True 
	
def fixRule38546():
	logging("Disabling the IPv6 protocol")
	runOnShell("sysctl -w net.ipv6.conf.all.disable_ipv6=1")
	runOnShell("sysctl -w net.ipv6.conf.default.disable_ipv6=1")
	runOnShell("sysctl -w net.ipv6.conf.lo.disable_ipv6=1")
	#Commenting out the IPv6 line in /etc/hosts file.
	with open("/etc/hosts", "r") as file_content:
		file_string = ""
		for line in file_content:
		    if isL(line) and re.match(r'.*::.*', line):
			file_string += "#" + line
		    else:
			file_string += line 
	fout = None
	try:
	    fout = open("/etc/hosts", 'wt')
	    fout.write(file_string)
	except:
		pass
	finally:
	    if fout is not None:
	        fout.close()
	# Disabling IPv6 in /etc/sysctl.conf file.
        with open("/etc/sysctl.conf", "r") as file_handler:
            all_disable_ip_flag = False
            def_disable_ip_flag = False
            lo_disable_ip_flag = False

            file_data = ""
            lastLine = ""
            for line in file_handler:
                if isL(line) and "net.ipv6.conf.all.disable_ipv6" in line:
                    if not tokenMatch('Cloud Raxak updated next line',lastLine):
                        file_data += "# Cloud Raxak updated next line\n"
                    file_data += "net.ipv6.conf.all.disable_ipv6 = 1\n"
                    all_disable_ip_flag = True
                elif isL(line) and "net.ipv6.conf.default.disable_ipv6" in line:
                    if not tokenMatch('Cloud Raxak updated next line',lastLine):
                        file_data += "# Cloud Raxak updated next line\n"
                    file_data += "net.ipv6.conf.default.disable_ipv6 = 1\n"
                    def_disable_ip_flag = True
                elif isL(line) and "net.ipv6.conf.lo.disable_ipv6" in line:
                    if not tokenMatch('Cloud Raxak updated next line',lastLine):
                        file_data += "# Cloud Raxak updated next line\n"
                    file_data += "net.ipv6.conf.lo.disable_ipv6 = 1\n"
                    lo_disable_ip_flag = True
                else:
                    file_data += line
                    lastLine = line

            if not(all_disable_ip_flag):
                if not tokenMatch('Cloud Raxak updated next line',lastLine):
                	file_data += "# Cloud Raxak updated next line\n"
                file_data += "net.ipv6.conf.all.disable_ipv6 = 1\n"
            if not(def_disable_ip_flag):
                if not tokenMatch('Cloud Raxak updated next line',lastLine):
                	file_data += "# Cloud Raxak updated next line\n"
                file_data += "net.ipv6.conf.default.disable_ipv6 = 1\n"
            if not(lo_disable_ip_flag):
                if not tokenMatch('Cloud Raxak updated next line',lastLine):
                	file_data += "# Cloud Raxak updated next line\n"
                file_data += "net.ipv6.conf.lo.disable_ipv6 = 1\n"
            fout = None
            try:
                fout = open("/etc/sysctl.conf", 'wt')
                fout.write(file_data)
            finally:
                if fout is not None:
                    fout.close()

	if (( OsVersion >= (7,0)) and (OsName.lower() == 'centos')):
		logging("IPv6 is disabled in present state, but sysctl configuration file may not have effect which may cause of changing the present state of IPv6 after rebooting.")

def checkRule38547():
    	if not CheckService("auditd"):
		return False

	res = ""
	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Checking for keyword never,task.
    	logging("Checking if system call auditing is disabled.")
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
        	return False

    	#Checking for any error in file.
    	if "error" in runOnShell('auditctl -R '+file_path):
		logging("There is an error in "+file_path+", please fix it manually before remediating the rule.")
		return None

	return_flag = True
	uid_out_user = runOnShell("grep -w fchmod "+ file_path + "| grep " + "'auid>="+uid_value+ "' | grep -v '^#' ")
	if uid_out_user == "":
		logging("System is not configured to audit all discretionary access control permission modifications for user using fchmod.")	
		return_flag = False

	uid_out_root = runOnShell("grep -w fchmod " + file_path + "| grep 'auid=0' | grep -v '^#'")
	if uid_out_root == "":
		logging("System is not configured to audit all discretionary access control permission modifications for root user using fchmod.")	
		return_flag = False

	if not return_flag:
		return False

	logging("System is configured to audit all discretionary access control permission modifications using fchmod.")
	return True

def fixRule38547():
        if not InstallPackage("audit"):
            return None

	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Removing for keyword never,task
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging(" Disabling the system call auditing to audit the events properly.")
        	runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /' "+file_path)

	#Clear previous rules set. 
	runOnShell("auditctl -D")
	#Obtaining the data from file_path	
	audit_handler = open(file_path, "r")
	audit_file_rules = audit_handler.readlines()
	audit_handler.close()
	#Removing redundant entries	from data
	filter_unique_audit_rule_list = []	
	for line in list(set(audit_file_rules)):
		line1 = line.strip('\n')
		if (('-b 320' in line1) or ('-D' in line1) or ('#' in line1)):
			continue
		final_line = re.sub("\s+" , " ", line1)
		filter_unique_audit_rule_list.append(final_line.strip())

	startup_line = "# This file contains the auditctl rules that are loaded\n # whenever the audit daemon is started via the initscripts.\n # The rules are simply the parameters that would be passed\n# to auditctl.\n # First rule - delete all\n-D\n\n # Increase the buffers to survive stress events.\n # Make this bigger for busy systems\n -b 320\n"
	
	with open(file_path, "w") as fhandler:
		res = runOnShell("uname -m")
		if "64" in res:
			arch_variable = "arch=b64" 
		else:
			arch_variable = "arch=b32" 
	
		fhandler.write(startup_line)
		rule_1 = "-a always,exit -F " + arch_variable + " -S fchmod -F auid>="+uid_value+" -F auid!=4294967295 -k perm_mod"
		rule_2 = "-a always,exit -F "+arch_variable+" -S fchmod -F auid=0 -k perm_mod"
		unique_data = '\n'.join(filter_unique_audit_rule_list)
		fhandler.write(unique_data)
		for rule in [rule_1,rule_2]:
			if rule not in filter_unique_audit_rule_list:
				fhandler.write("\n"+rule+"\n")

	logging("Configuring the system to audit all discretionary access control permission modifications using fchmod.")
	fhandler.close()
	runOnShell("auditctl -R "+file_path)
    	RunService("auditd")

def checkRule38548():
	logging("Checking if IPv6 is enabled.")
        ipv6_output = runOnShell('grep -w net.ipv6.conf.all.disable_ipv6 /etc/sysctl.conf | grep -v "^#"')
        ipv6_output = ipv6_output.translate(string.maketrans("\n\t\r", "   "))
	if ipv6_output == "":
		if os.path.exists('/proc/sys/net/ipv6/conf/all/disable_ipv6'):
			runtime_ipv6_status = runOnShell("cat /proc/sys/net/ipv6/conf/all/disable_ipv6")
			runtime_ipv6_status = runtime_ipv6_status.translate(string.maketrans("\n\t\r", "   "))
			if atoi(runtime_ipv6_status) == 1:
				logging("IPv6 is disabled, hence it is not applicable.")
				return True
		else:
	    		logging("IPV6 does not exist in file.")
	    		return True  	
        elif keyValEqMatch_new("net.ipv6.conf.all.disable_ipv6" ,"1",ipv6_output):
		logging("IPv6 is disabled, hence it is not applicable.")
		return True

        def_accept_value = runOnShell("sysctl net.ipv6.conf.default.accept_redirects")
	try:
		setting = def_accept_value.split()[2]
	except IndexError:
		logging("System is not configured to ignore ICMPv6 redirect by default.")
		return False
        if atoi(setting) != 0:
		logging("System is not configured correctly to ignore ICMPv6 redirect by default.")
		return False
	logging("Loading the setting defined during boot time to verify the system configuration\
 for ignoring ICMPv6 redirects by default after system reboot.")
        reverse_boot = runOnShell("grep -w net.ipv6.conf.default.accept_redirects /etc/sysctl.conf | grep -v '^#'")
        reverse_boot = reverse_boot.translate(string.maketrans("\n\t\r", "   "))
	if reverse_boot == "":
                return False
		
	if keyValEqMatch_new("net.ipv6.conf.default.accept_redirects","0",reverse_boot):
                logging("System is configured correctly to ignore ICMPv6 redirect by default.")
		return True
	else:
                logging("System is not configured correctly to ignore ICMPv6 redirect by default.")
		return False


def fixRule38548():
    runOnShell("sysctl -w net.ipv6.conf.default.accept_redirects=0")
    with open("/etc/sysctl.conf", "r") as file_read:
        flag = False
        fileString = ""
        lastLine = ""
        for line in file_read:
            if isL(line) and "net.ipv6.conf.default.accept_redirects" in line:
                if not tokenMatch('Cloud Raxak updated next line',lastLine):
                    fileString += "# Cloud Raxak updated next line\n"
                fileString += "net.ipv6.conf.default.accept_redirects = 0\n"
                flag = True
            else:
                fileString += line
                lastLine = line
        if not(flag):
            fileString += "# Cloud Raxak updated next line\n"
            fileString += "net.ipv6.conf.default.accept_redirects = 0\n"
    fout = None
    fout = open("/etc/sysctl.conf", 'wt')
    if fout != None:
        fout.write(fileString)
        fout.close()

def checkRule38549():
	logging("Checking if IPv6 is enabled.")
        ipv6_output = runOnShell('grep -w net.ipv6.conf.all.disable_ipv6 /etc/sysctl.conf  | grep -v "^#" ')
        ipv6_output = ipv6_output.translate(string.maketrans("\n\t\r", "   "))
	if ipv6_output == "":
		if os.path.exists('/proc/sys/net/ipv6/conf/all/disable_ipv6'):
			runtime_ipv6_status = runOnShell("cat /proc/sys/net/ipv6/conf/all/disable_ipv6")
			runtime_ipv6_status = runtime_ipv6_status.translate(string.maketrans("\n\t\r", "   "))
			if atoi(runtime_ipv6_status) == 1:
				logging("IPv6 is disabled, hence it is not applicable.")
				return True
		else:
	    		logging("IPV6 does not exist in file.")
	    		return True  	
        elif keyValEqMatch_new("net.ipv6.conf.all.disable_ipv6" ,"1",ipv6_output):
		logging("IPv6 is disabled, hence it is not applicable.")
		return True

	if OsName.lower() == "ubuntu":
		logging("Checking the status of Firewall")
		match_object = runOnShell("ufw status verbose").split('\n')[0]
		match_object1 = match_object.split(':')[1]
		if tokenMatch('active',match_object1):
			logging("Checking the service status of Firewall")
			service_status = runOnShell("service ufw status")
			service_status = service_status.split('\n')[0]
			if "start/running" in service_status:
             			ipv6_status = runOnShell('grep IPV6=yes /etc/default/ufw | grep -v "^#" ')
             			if tokenMatch("IPV6=yes", ipv6_status):
					return True
	elif OsVersion >= (7,0):
		firewall_status = runOnShell("systemctl is-active firewalld").replace('\n','')
		iptables_status = runOnShell("systemctl is-active ip6tables").replace('\n','')
		if (firewall_status == "active" and iptables_status == "active"):
		    logging("Firewalld and iptables both are running which should not be used at a time.\
Please fix it manually by turning off one of them.In CentOS 7 the default firewall is `firewalld` so it is recommended to use firewalld.")	
		    return None
		elif firewall_status == "active": 
			if runOnShell("systemctl is-enabled firewalld").replace('\n','') == "enabled":
				logging("The system is employed with a local IPv6 firewall.")
				return True
		elif iptables_status == "active":
			if runOnShell("systemctl is-enabled ip6tables").replace('\n','') == "enabled":
				logging("The system is employed with a local IPv6 firewall.")
				return True

	else:
    		if CheckService("ip6tables"):
			return True
	logging("IPv6 firewall is not active/running, hence it is recommended to fix it manually.")
	return None


def fixRule38549():
	logging("Please fix it manually.")
	return None
	if OsName.lower() == "ubuntu":
		runOnShell("echo 'y'|ufw enable")
		runOnShell("ufw allow 22")
		runOnShell("ufw reload")
		runOnShell("sysv-rc-conf --level 0123456 ip6tables on")
	else:
		if OsVersion >= (7,0):
			flag_firewal_install = True
			flag_iptable_install = True
			if 'No such file or directory' in runOnShell("systemctl status firewalld"):
				flag_firewal_install = False
			if 'No such file or directory' in runOnShell("systemctl status iptables.service"):
				flag_iptable_install = False
			if flag_firewal_install == False and flag_iptable_install == False:
				runOnShell("yum install firewalld -y")	
				runOnShell("systemctl enable  firewalld")
				runOnShell("systemctl start  firewalld")
		        elif flag_firewal_install == True and flag_iptable_install == False:
				runOnShell("systemctl enable  firewalld")
				runOnShell("systemctl start  firewalld")
			else: 
				runOnShell("systemctl enable  iptables.service")
				runOnShell("systemctl start  iptables.service")

		else:
			runOnShell("chkconfig ip6tables on")
			runOnShell("service ip6tables start")


#seems to be same as 103...
def checkRule38550():
    	if not CheckService("auditd"):
		return False

	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Checking for keyword never,task.
    	logging("Checking if system call auditing is disabled.")
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
        	return False

    	#Checking for any error in file.
    	if "error" in runOnShell('auditctl -R '+file_path):
		logging("There is an error in "+file_path+", please fix it manually before remediating the rule.")
		return None

	return_flag = True
	uid_out_user = runOnShell("grep -w fchmodat "+ file_path + "| grep " + "'auid>="+uid_value+ "' | grep -v '^#' ")
	if uid_out_user == "":
		logging("System is not configured to audit all discretionary access control permission modifications for user using fchmodat.")	
		return_flag = False

	uid_out_root = runOnShell("grep -w fchmodat " + file_path + "| grep 'auid=0' | grep -v '^#'")
	if uid_out_root == "":
		logging("System is not configured to audit all discretionary access control permission modifications for root user using fchmodat.")	
		return_flag = False

	if not return_flag:
		return False

	logging("System is configured to audit all discretionary access control permission modifications using fchmodat.")	
	return True

def fixRule38550():
        if not InstallPackage("audit"):
            return None

	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Removing for keyword never,task
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging(" Disabling the system call auditing to audit the events properly.")
       		runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /' "+file_path)

	#Clear previous rules set. 
	runOnShell("auditctl -D")
	#Obtaining the data from file_path	
	audit_handler = open(file_path, "r")
	audit_file_rules = audit_handler.readlines()
	audit_handler.close()
	#Removing redundant entries	from data
	filter_unique_audit_rule_list = []	
	for line in list(set(audit_file_rules)):
		line1 = line.strip('\n')
		if (('-b 320' in line1) or ('-D' in line1) or ('#' in line1)):
			continue
		final_line = re.sub("\s+" , " ", line1)
		filter_unique_audit_rule_list.append(final_line.strip())

	startup_line = "# This file contains the auditctl rules that are loaded\n # whenever the audit daemon is started via the initscripts.\n # The rules are simply the parameters that would be passed\n# to auditctl.\n # First rule - delete all\n-D\n\n # Increase the buffers to survive stress events.\n # Make this bigger for busy systems\n -b 320\n"
	
	with open(file_path, "w") as fhandler:
		res = runOnShell("uname -m")
		if "64" in res:
			arch_variable = "arch=b64" 
		else:
			arch_variable = "arch=b32" 
		fhandler.write(startup_line)
		rule_1 = "-a always,exit -F " + arch_variable + " -S fchmodat -F auid>="+uid_value+" -F auid!=4294967295 -k perm_mod"
		rule_2 = "-a always,exit -F "+arch_variable+" -S fchmodat -F auid=0 -k perm_mod"
		unique_data = '\n'.join(filter_unique_audit_rule_list)
		fhandler.write(unique_data)
		for rule in [rule_1,rule_2]:
			if rule not in filter_unique_audit_rule_list:
				fhandler.write("\n"+rule+"\n")
			
	logging("Configuring the system to audit all discretionary access control permission modifications using fchmodat.")	
	fhandler.close()
	runOnShell("auditctl -R "+file_path)
    	RunService("auditd")

def checkRule38551():
	logging("Checking if IPv6 is enabled.")
        ipv6_output = runOnShell('grep -w "net.ipv6.conf.all.disable_ipv6" /etc/sysctl.conf  | grep -v "^#" ')
        ipv6_output = ipv6_output.translate(string.maketrans("\n\t\r", "   "))
	if ipv6_output == "":
		if os.path.exists('/proc/sys/net/ipv6/conf/all/disable_ipv6'):
			runtime_ipv6_status = runOnShell("cat /proc/sys/net/ipv6/conf/all/disable_ipv6")
			runtime_ipv6_status = runtime_ipv6_status.translate(string.maketrans("\n\t\r", "   "))
			if atoi(runtime_ipv6_status) == 1:
				logging("IPv6 is disabled, hence it is not applicable.")
				return True
		else:
	    		logging("IPV6 does not exist in file.")
	    		return True  	
        elif keyValEqMatch_new("net.ipv6.conf.all.disable_ipv6" ,"1",ipv6_output):
		logging("IPv6 is disabled, hence it is not applicable.")
		return True

	if OsName.lower() == "ubuntu":
		logging("Checking the status of Firewall")
		res = runOnShell("ufw status verbose")
		match_object = res.split('\n')[0]
		match_object1 = match_object.split(':')[1]
		if tokenMatch('active',match_object1):
			logging("Checking the service status of Firewall")
			service_status = runOnShell("service ufw status")
			service_status = service_status.split('\n')[0]
			if "start/running" in service_status:
             			ipv6_status = runOnShell('grep IPV6=yes /etc/default/ufw | grep -v "^#" ')
             			if tokenMatch("IPV6=yes", ipv6_status):
					return True
	elif OsVersion >= (7,0):
		firewall_status = runOnShell("systemctl is-active firewalld").replace('\n','')
		iptables_status = runOnShell("systemctl is-active ip6tables").replace('\n','')
		if (firewall_status == "active" and iptables_status == "active"):
		    logging("Firewalld and iptables both are running which should not be used at a time.\
Please fix it manually by turning off one of them.In CentOS 7 the default firewall is `firewalld` so it is recommended to use firewalld.")	
		    return None
		elif firewall_status == "active": 
			if runOnShell("systemctl is-enabled firewalld").replace('\n','') == "enabled":
				return True
		elif iptables_status == "active":
			if runOnShell("systemctl is-enabled ip6tables").replace('\n','') == "enabled":
				return True
	else:
    		if CheckService("ip6tables"):
			logging("IPv6 firewall is active/running on the system.")
			return True
	logging("IPv6 firewall is not active/running , hence it is recommended to fix it manually.")	
	return None


def fixRule38551():
	logging("Please fix it manually.")
	return None	
	if OsName.lower() == "ubuntu":
		runOnShell("echo 'y'|ufw enable")
		runOnShell("ufw allow 22")
		runOnShell("ufw reload")
		runOnShell("sysv-rc-conf --level 0123456 ip6tables on")
	else:
		if OsVersion >= (7,0):
			flag_firewal_install = True
			flag_iptable_install = True
			if 'No such file or directory' in runOnShell("systemctl status firewalld"):
				flag_firewal_install = False
			if 'No such file or directory' in runOnShell("systemctl status iptables.service"):
				flag_iptable_install = False
			if flag_firewal_install == False and flag_iptable_install == False:
				runOnShell("yum install firewalld -y")	
				runOnShell("systemctl enable  firewalld")
				runOnShell("systemctl start  firewalld")
		        elif flag_firewal_install == True and flag_iptable_install == False:
				runOnShell("systemctl enable  firewalld")
				runOnShell("systemctl start  firewalld")
			else: 
				runOnShell("systemctl enable  iptables.service")
				runOnShell("systemctl start  iptables.service")
		else:
			runOnShell("chkconfig ip6tables on")
			runOnShell("service ip6tables start")


def checkRule38552():
    	if not CheckService("auditd"):
		return False

	file_path = '/etc/audit/audit.rules'
	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		file_path = '/etc/audit/rules.d/audit.rules'

    	#Checking for keyword never,task.
    	logging("Checking if system call auditing is disabled.")
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
        	return False
	
    	#Checking for any error in file.
    	if "error" in runOnShell('auditctl -R '+file_path):
		logging("There is an error in "+file_path+", please fix it manually before remediating the rule.")
		return None

	return_flag = True
	uid_out_user = runOnShell("grep -w fchown "+ file_path + "| grep " + "'auid>="+uid_value+ "' | grep -v '^#' ")
	if uid_out_user == "":
		logging("System is not configured to audit all discretionary access control permission modifications for user using fchown.")	
		return_flag = False

	uid_out_root = runOnShell("grep -w fchown " + file_path + "| grep 'auid=0' | grep -v '^#'")
	if uid_out_root == "":
		logging("System is not configured to audit all discretionary access control permission modifications for root user using fchown.")	
		return_flag = False

	if not return_flag:
		return False

	logging("System is configured to audit all discretionary access control permission modifications using fchown.")
	return True

def fixRule38552():
        if not InstallPackage("audit"):
            return None

	file_path = '/etc/audit/audit.rules'
	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		file_path = '/etc/audit/rules.d/audit.rules'

    	#Removing for keyword never,task
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging(" Disabling the system call auditing to audit the events properly.")
        	runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /' "+file_path)

	#Clear previous rules set. 
	runOnShell("auditctl -D")
	#Obtaining the data from file_path	
	audit_handler = open(file_path, "r")
	audit_file_rules = audit_handler.readlines()
	audit_handler.close()
	#Removing redundant entries	from data
	filter_unique_audit_rule_list = []	
	for line in list(set(audit_file_rules)):
		line1 = line.strip('\n')
		if (('-b 320' in line1) or ('-D' in line1) or ('#' in line1)):
			continue
		final_line = re.sub("\s+" , " ", line1)
		filter_unique_audit_rule_list.append(final_line.strip())

	startup_line = "# This file contains the auditctl rules that are loaded\n # whenever the audit daemon is started via the initscripts.\n # The rules are simply the parameters that would be passed\n# to auditctl.\n # First rule - delete all\n-D\n\n # Increase the buffers to survive stress events.\n # Make this bigger for busy systems\n -b 320\n"
	
	with open(file_path, "w") as fhandler:
		res = runOnShell("uname -m")
		if "64" in res:
			arch_variable = "arch=b64" 
		else:
			arch_variable = "arch=b32" 
		fhandler.write(startup_line)
		rule_1 = "-a always,exit -F " + arch_variable + " -S fchown -F auid>="+uid_value+" -F auid!=4294967295 -k perm_mod"
		rule_2 = "-a always,exit -F "+arch_variable+" -S fchown -F auid=0 -k perm_mod"
		unique_data = '\n'.join(filter_unique_audit_rule_list)
		fhandler.write(unique_data)
		for rule in [rule_1,rule_2]:
			if rule not in filter_unique_audit_rule_list:
				fhandler.write("\n"+rule+"\n")

	logging("Configuring the system to audit all discretionary access control permission modifications using fchown.")
	fhandler.close()
	runOnShell("auditctl -R "+file_path)
    	RunService("auditd")


def checkRule38553():
	logging("Checking if IPv6 is enabled.")
        ipv6_output = runOnShell('grep -w "net.ipv6.conf.all.disable_ipv6" /etc/sysctl.conf  | grep -v "^#" ')
        ipv6_output = ipv6_output.translate(string.maketrans("\n\t\r", "   "))
	if ipv6_output == "":
		if os.path.exists('/proc/sys/net/ipv6/conf/all/disable_ipv6'):
			runtime_ipv6_status = runOnShell("cat /proc/sys/net/ipv6/conf/all/disable_ipv6")
			runtime_ipv6_status = runtime_ipv6_status.translate(string.maketrans("\n\t\r", "   "))
			if atoi(runtime_ipv6_status) == 1:
				logging("IPv6 is disabled, hence it is not applicable.")
				return True
		else:
	    		logging("IPV6 does not exist in file.")
	    		return True  	
        elif keyValEqMatch_new("net.ipv6.conf.all.disable_ipv6" ,"1",ipv6_output):
		logging("IPv6 is disabled, hence it is not applicable.")
		return True

	if OsName.lower() == "ubuntu":
		logging("Checking the status of Firewall")
		match_object = runOnShell("ufw status verbose").split('\n')[0]
		match_object1 = match_object.split(':')[1]
		if tokenMatch('active',match_object1):
			logging("Checking the service status of Firewall")
			service_status = runOnShell("service ufw status")
			service_status = service_status.split('\n')[0]
			if "start/running" in service_status:
				logging("Checking the status of IPv6 Firewall.")
				ipv6_status = runOnShell('grep IPV6=yes /etc/default/ufw | grep -v "^#" ')
				ipv6_status = ipv6_status.translate(string.maketrans("\n\t\r", "   "))
				if keyValEqMatch("IPv6",'yes',ipv6_status):
					return True
	elif OsVersion >= (7,0):
		firewall_status = runOnShell("systemctl is-active firewalld").replace('\n','')
		iptables_status = runOnShell("systemctl is-active ip6tables").replace('\n','')
		if (firewall_status == "active" and iptables_status == "active"):
		    logging("Firewalld and iptables both are running which should not be used at a time.\
Please fix it manually by turning off one of them.In CentOS 7 the default firewall is `firewalld` so it is recommended to use firewalld.")	
		    return None
		elif firewall_status == "active": 
			if runOnShell("systemctl is-enabled firewalld").replace('\n','') == "enabled":
				return True
		elif iptables_status == "active":
			if runOnShell("systemctl is-enabled ip6tables").replace('\n','') == "enabled":
				return True
	else:
		if CheckService("ip6tables"):
			logging("IPv6 firewall is active/running on the system.")
			return True
	logging("IPv6 firewall is not active/running, hence it is recommended to fix it manually.")	
	return None


def fixRule38553():
	logging("Please fix it manually.")
	return None
	if OsName.lower() == "ubuntu":
		runOnShell("echo 'y'|ufw enable")
		runOnShell("ufw allow 22")
		runOnShell("ufw reload")
		runOnShell("sysv-rc-conf --level 0123456 ip6tables on")
	else:
		if OsVersion >= (7,0):
			flag_firewal_install = True
			flag_iptable_install = True
			if 'No such file or directory' in runOnShell("systemctl status firewalld"):
				flag_firewal_install = False
			if 'No such file or directory' in runOnShell("systemctl status iptables.service"):
				flag_iptable_install = False
			if flag_firewal_install == False and flag_iptable_install == False:
				runOnShell("yum install firewalld -y")	
				runOnShell("systemctl enable  firewalld")
				runOnShell("systemctl start  firewalld")
		        elif flag_firewal_install == True and flag_iptable_install == False:
				runOnShell("systemctl enable  firewalld")
				runOnShell("systemctl start  firewalld")
			else: 
				runOnShell("systemctl enable  iptables.service")
				runOnShell("systemctl start  iptables.service")
		else:
			runOnShell("chkconfig ip6tables on")
			runOnShell("service ip6tables start")
        
def checkRule38554():
   	if not CheckService("auditd"):
		return False

	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Checking for keyword never,task.
    	logging("Checking if system call auditing is disabled.")
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
        	return False

    	#Checking for any error in file.
    	if "error" in runOnShell('auditctl -R '+file_path):
		logging("There is an error in "+file_path+", please fix it manually before remediating the rule.")
		return None

	return_flag = True
	uid_out_user = runOnShell("grep -w fchownat "+ file_path + "| grep " + "'auid>="+uid_value+ "' | grep -v '^#' ")
	if uid_out_user == "":
		logging("System is not configured to audit all discretionary access control\
 permission modifications for user using fchownat.")	
		return_flag = False

	uid_out_root = runOnShell("grep -w fchownat " + file_path + "| grep 'auid=0' | grep -v '^#'")
	if uid_out_root == "":
		logging("System is not configured to audit all discretionary access control\
 permission modifications for root user using fchownat.")	
		return_flag = False

	if not return_flag:
		return False

	logging("System is configured to audit all discretionary access control permission modifications using fchownat.")
	return True


def fixRule38554():
        if not InstallPackage("audit"):
            return None

	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Removing for keyword never,task
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging(" Disabling the system call auditing to audit the events properly.")
        	runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /' "+file_path)

	#Clear previous rules set. 
	runOnShell("auditctl -D")
	#Obtaining the data from file_path	
	audit_handler = open(file_path, "r")
	audit_file_rules = audit_handler.readlines()
	audit_handler.close()
	#Removing redundant entries	from data
	filter_unique_audit_rule_list = []	
	for line in list(set(audit_file_rules)):
		line1 = line.strip('\n')
		if (('-b 320' in line1) or ('-D' in line1) or ('#' in line1)):
			continue

		final_line = re.sub("\s+" , " ", line1)
		filter_unique_audit_rule_list.append(final_line.strip())

	startup_line = "# This file contains the auditctl rules that are loaded\n # whenever the audit daemon is started via the initscripts.\n # The rules are simply the parameters that would be passed\n# to auditctl.\n # First rule - delete all\n-D\n\n # Increase the buffers to survive stress events.\n # Make this bigger for busy systems\n -b 320\n"
    
	with open(file_path, "w") as fhandler:
		res = runOnShell("uname -m")
		if "64" in res:
			arch_variable = "arch=b64" 
		else:
			arch_variable = "arch=b32" 

		fhandler.write(startup_line)
		rule_1 = "-a always,exit -F " + arch_variable + " -S fchownat -F auid>="+uid_value+" -F auid!=4294967295 -k perm_mod"
		rule_2 = "-a always,exit -F "+ arch_variable + " -S fchownat -F auid=0 -k perm_mod"
		unique_data = '\n'.join(filter_unique_audit_rule_list)
		fhandler.write(unique_data)
		for rule in [rule_1,rule_2]:
			if rule not in filter_unique_audit_rule_list:
				fhandler.write("\n"+rule+"\n")
	logging("Configuring the systems to audit all discretionary access control permission modifications using fchownat.")
	fhandler.close()
	runOnShell("auditctl -R "+file_path)
    	RunService("auditd")

def checkRule38555():
	if OsName.lower() == "ubuntu":
		logging("Checking the status of Firewall")
		ufw_status = runOnShell("ufw status verbose").split('\n')[0].split(':')[1]
		if tokenMatch('active',ufw_status):
			logging("Checking the service status of Firewall")
			service_status = runOnShell("service ufw status")
			service_status = service_status.split('\n')[0]
			if "start/running" in service_status:
				return True
	elif OsVersion >= (7,0):
		firewall_status = runOnShell("systemctl is-active firewalld").replace('\n','')
		iptables_status = runOnShell("systemctl is-active iptables").replace('\n','')
		if (firewall_status == "active" and iptables_status == "active"):
		    logging("Firewalld and iptables both are running which should not be used at a time.\
Please fix it manually by turning off one of them.In CentOS 7 the default firewall is `firewalld` so it is recommended to use firewalld.")	
		    return None
		elif firewall_status == "active": 
			if runOnShell("systemctl is-enabled firewalld").replace('\n','') == "enabled":
				return True
		elif iptables_status == "active":
			if runOnShell("systemctl is-enabled iptables").replace('\n','') == "enabled":
				return True
	else:
		if CheckService("iptables"):
			logging("IPv4 firewall is active/running on the system.")
			return True

	logging("IPv4 firewall is not active/running on the system, hence it is recommended to fix it manually.")
	return None


def fixRule38555():
	logging("Please fix it manually.")
	return None
	if OsName.lower() == "ubuntu":
		runOnShell("echo 'y'|ufw enable")
		runOnShell("ufw allow 22")
		runOnShell("ufw reload")
		runOnShell("sysv-rc-conf --level 0123456 ip6tables on")
	else:
		if OsVersion >= (7,0):
			flag_firewal_install = True
			flag_iptable_install = True
			if 'No such file or directory' in runOnShell("systemctl status firewalld"):
				flag_firewal_install = False
			if 'No such file or directory' in runOnShell("systemctl status iptables.service"):
				flag_iptable_install = False
			if not flag_firewal_install and not flag_iptable_install:
				runOnShell("yum install firewalld -y")	
				runOnShell("systemctl enable  firewalld")
				runOnShell("systemctl start  firewalld")
		        elif flag_firewal_install  and not flag_iptable_install:
				runOnShell("systemctl enable  firewalld")
				runOnShell("systemctl start  firewalld")
			else: 
				runOnShell("systemctl enable  iptables.service")
				runOnShell("systemctl start  iptables.service")
		else:
			runOnShell("chkconfig iptables on")
			runOnShell("service iptables start")



def checkRule38556():
    	if not CheckService("auditd"):
		return False


	uid_out_user = ""
	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Checking for keyword never,task.
    	logging("Checking if system call auditing is disabled.")
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
        	return False

    	#Checking for any error in file.
    	if "error" in runOnShell('auditctl -R '+file_path):
		logging("There is an error in "+file_path+", please fix it manually before remediating the rule.")
		return None

	uid_out_user = runOnShell("grep -w fremovexattr "+ file_path + "| grep " + "'auid>="+uid_value+ "' | grep -v '^#' ")
	uid_out_root = runOnShell("grep -w fremovexattr " + file_path + "| grep 'auid=0' | grep -v '^#'")
	
	return_flag = True
	if uid_out_user == "":
		logging("System is not configured to audit all discretionary access control\
 permission modifications for user using fremovexattr.")	
		return_flag = False
	if uid_out_root == "":
		logging("System is not configured to audit all discretionary access control\
 permission modifications for root user using fremovexattr.")	
		return_flag = False
	if not return_flag:
		return False

	logging("System is configured to audit all discretionary access control permission modifications using fremovexattr.")	
	return True

def fixRule38556():
        if not InstallPackage("audit"):
            return None

	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Removing for keyword never,task
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging(" Disabling the system call auditing to audit the events properly.")
        	runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /' "+file_path)

	#Clear previous rules set. 
	runOnShell("auditctl -D")
	#Obtaining the data from file_path	
	audit_handler = open(file_path, "r")
	audit_file_rules = audit_handler.readlines()
	audit_handler.close()
	#Removing redundant entries from data
	filter_unique_audit_rule_list = []	
	for line in list(set(audit_file_rules)):
		line1 = line.strip('\n')
		if (('-b 320' in line1) or ('-D' in line1) or ('#' in line1)):
			continue
		final_line = re.sub("\s+" , " ", line1)
		filter_unique_audit_rule_list.append(final_line.strip())

	startup_line = "# This file contains the auditctl rules that are loaded\n # whenever the audit daemon is started via the initscripts.\n # The rules are simply the parameters that would be passed\n# to auditctl.\n # First rule - delete all\n-D\n\n # Increase the buffers to survive stress events.\n # Make this bigger for busy systems\n -b 320\n"

	with open(file_path, "w") as fhandler:
		res = runOnShell("uname -m")
		if "64" in res:
			arch_variable = "arch=b64" 
		else:
			arch_variable = "arch=b32" 

		fhandler.write(startup_line)
		rule_1 = "-a always,exit -F " + arch_variable + " -S fremovexattr -F auid>="+uid_value+" -F auid!=4294967295 -k perm_mod"
		rule_2 = "-a always,exit -F "+ arch_variable + " -S fremovexattr -F auid=0 -k perm_mod"
		unique_data = '\n'.join(filter_unique_audit_rule_list)
		fhandler.write(unique_data)
		for rule in [rule_1,rule_2]:
			if rule not in filter_unique_audit_rule_list:
				fhandler.write("\n"+rule+"\n")
			
	logging("Configuring the system to audit all discretionary access control permission modifications using fremovexattr.")	
	fhandler.close()
	runOnShell("auditctl -R "+file_path)
    	RunService("auditd")


def checkRule38557():
    	if not CheckService("auditd"):
		return False

	uid_out_user = ""
	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Checking for keyword never,task.
    	logging("Checking if system call auditing is disabled.")
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
        	return False

    	#Checking for any error in file.
    	if "error" in runOnShell('auditctl -R '+file_path):
		logging("There is an error in "+file_path+", please fix it manually before remediating the rule.")
		return None

	uid_out_user = runOnShell("grep -w fsetxattr "+ file_path + "| grep " + "'auid>="+uid_value+ "' | grep -v '^#' ")
	uid_out_root = runOnShell("grep -w fsetxattr " + file_path + "| grep 'auid=0' | grep -v '^#'")

	return_flag = True
	if uid_out_user == "":
		logging("System is not configured to audit all discretionary access control\
 permission modifications for user using fsetxattr.")	
		return_flag = False
	if uid_out_root == "":
		logging("System is not configured to audit all discretionary access control\
 permission modifications for root user using fsetxattr.")	
		return_flag = False

	if not return_flag:
		return False

	logging("System is configured to audit all discretionary access control permission modifications using fsetxattr.")
	return True

def fixRule38557():
        if not InstallPackage("audit"):
            return None

	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Removing for keyword never,task
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging(" Disabling the system call auditing to audit the events properly.")
        	runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /' "+file_path)

	#Clear previous rules set. 
	runOnShell("auditctl -D")
	#Obtaining the data from file_path	
	audit_handler = open(file_path, "r")
	audit_file_rules = audit_handler.readlines()
	audit_handler.close()
	#Removing redundant entries	from data
	filter_unique_audit_rule_list = []	
	for line in list(set(audit_file_rules)):
		line1 = line.strip('\n')
		if (('-b 320' in line1) or ('-D' in line1) or ('#' in line1)):
			continue
		final_line = re.sub("\s+" , " ", line1)
		filter_unique_audit_rule_list.append(final_line.strip())

	startup_line = "# This file contains the auditctl rules that are loaded\n # whenever the audit daemon is started via the initscripts.\n # The rules are simply the parameters that would be passed\n# to auditctl.\n # First rule - delete all\n-D\n\n # Increase the buffers to survive stress events.\n # Make this bigger for busy systems\n -b 320\n"

	with open(file_path, "w") as fhandler:
		res = runOnShell("uname -m")
		if "64" in res:
			arch_variable = "arch=b64" 
		else:
			arch_variable = "arch=b32" 

		fhandler.write(startup_line)
		rule_1 = "-a always,exit -F " + arch_variable + " -S fsetxattr -F auid>="+uid_value+" -F auid!=4294967295 -k perm_mod"
		rule_2 = "-a always,exit -F "+ arch_variable + " -S fsetxattr -F auid=0 -k perm_mod"
		unique_data = '\n'.join(filter_unique_audit_rule_list)
		fhandler.write(unique_data)
		for rule in [rule_1,rule_2]:
			if rule not in filter_unique_audit_rule_list:
				fhandler.write("\n"+rule+"\n")

	logging("Adding the rule in audit file to audit permission modification in system"+file_path)
	fhandler.close()
	runOnShell("auditctl -R "+file_path)
    	RunService("auditd")

def checkRule38558():
    	if not CheckService("auditd"):
		return False

	uid_out_user = ""
	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Checking for keyword never,task.
    	logging("Checking if system call auditing is disabled.")
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
        	return False

    	#Checking for any error in file.
    	if "error" in runOnShell('auditctl -R '+file_path):
		logging("There is an error in "+file_path+", please fix it manually before remediating the rule.")
		return None

	uid_out_user = runOnShell("grep -w lchown "+ file_path + "| grep " + "'auid>="+uid_value+ "' | grep -v '^#' ")
	uid_out_root = runOnShell("grep -w lchown " + file_path + "| grep 'auid=0' | grep -v '^#'")
		
	return_flag = True
	if uid_out_user == "":
		logging("System is not configured to audit all discretionary access control\
 permission modifications for user using lchown.")	
		return_flag = False
	if uid_out_root == "":
		logging("System is not configured to audit all discretionary access control\
 permission modifications for root user using lchown.")	
		return_flag = False

	if not return_flag:
		return False

	logging("System is configured to audit all discretionary access control permission modifications using lchown.")	
	return True

def fixRule38558():
        if not InstallPackage("audit"):
            return None

	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Removing for keyword never,task
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging(" Disabling the system call auditing to audit the events properly.")
        	runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /' "+file_path)

	#Clear previous rules set. 
	runOnShell("auditctl -D")
	#Obtaining the data from file_path	
	audit_handler = open(file_path, "r")
	audit_file_rules = audit_handler.readlines()
	audit_handler.close()
	#Removing redundant entries	from data
	filter_unique_audit_rule_list = []	
	for line in list(set(audit_file_rules)):
		line1 = line.strip('\n')
		if (('-b 320' in line1) or ('-D' in line1) or ('#' in line1)):
			continue
		final_line = re.sub("\s+" , " ", line1)
		filter_unique_audit_rule_list.append(final_line.strip())

	startup_line = "# This file contains the auditctl rules that are loaded\n # whenever the audit daemon is started via the initscripts.\n # The rules are simply the parameters that would be passed\n# to auditctl.\n # First rule - delete all\n-D\n\n # Increase the buffers to survive stress events.\n # Make this bigger for busy systems\n -b 320\n"
	with open(file_path, "w") as fhandler:
		res = runOnShell("uname -m")
		if "64" in res:
			arch_variable = "arch=b64" 
		else:
			arch_variable = "arch=b32" 

		fhandler.write(startup_line)
		rule_1 = "-a always,exit -F " + arch_variable + " -S lchown -F auid>="+uid_value+" -F auid!=4294967295 -k perm_mod"
		rule_2 = "-a always,exit -F "+ arch_variable + " -S lchown -F auid=0 -k perm_mod"
		unique_data = '\n'.join(filter_unique_audit_rule_list)
		fhandler.write(unique_data)
		for rule in [rule_1,rule_2]:
			if rule not in filter_unique_audit_rule_list:
				fhandler.write("\n"+rule+"\n")

	logging("Adding the audit permission modification related rule to audit file "+file_path)
	fhandler.close()
	runOnShell("auditctl -R "+file_path)
    	RunService("auditd")

def checkRule38559():
    	if not CheckService("auditd"):
		return False

	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Checking for keyword never,task.
    	logging("Checking if system call auditing is disabled.")
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
        	return False

    	#Checking for any error in file.
    	if "error" in runOnShell('auditctl -R '+file_path):
		logging("There is an error in "+file_path+", please fix it manually before remediating the rule.")
		return None
		
	return_flag = True
	uid_out_user = runOnShell("grep -w lremovexattr "+ file_path + "| grep " + "'auid>="+uid_value+ "' | grep -v '^#' ")
	if uid_out_user == "":
		logging("System is not configured to audit all discretionary access control\
 permission modifications for user using lremovexattr.")	
		return_flag = False

	uid_out_root = runOnShell("grep -w lremovexattr " + file_path + "| grep 'auid=0' | grep -v '^#'")
	if uid_out_root == "":
		logging("System is not configured to audit all discretionary access control\
 permission modifications for root user using lremovexattr.")	
		return_flag = False

	if not return_flag:
		return False

	logging("System is configured to audit all discretionary access control permission modifications using lremovexattr")
	return True

def fixRule38559():
        if not InstallPackage("audit"):
            return None

	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

   	#Removing for keyword never,task
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging(" Disabling the system call auditing to audit the events properly.")
        	runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /' "+file_path)

	#Clear previous rules set. 
	runOnShell("auditctl -D")
	#Obtaining the data from file_path	
	audit_handler = open(file_path, "r")
	audit_file_rules = audit_handler.readlines()
	audit_handler.close()
	#Removing redundant entries	from data
	filter_unique_audit_rule_list = []	
	for line in list(set(audit_file_rules)):
		line1 = line.strip('\n')
		if (('-b 320' in line1) or ('-D' in line1) or ('#' in line1)):
			continue
		final_line = re.sub("\s+" , " ", line1)
		filter_unique_audit_rule_list.append(final_line.strip())

	startup_line = "# This file contains the auditctl rules that are loaded\n # whenever the audit daemon is started via the initscripts.\n # The rules are simply the parameters that would be passed\n# to auditctl.\n # First rule - delete all\n-D\n\n # Increase the buffers to survive stress events.\n # Make this bigger for busy systems\n -b 320\n"
	
	with open(file_path, "w") as fhandler:
		res = runOnShell("uname -m")
		if "64" in res:
			arch_variable = "arch=b64" 
		else:
			arch_variable = "arch=b32" 

		fhandler.write(startup_line)
		rule_1 = "-a always,exit -F " + arch_variable + " -S lremovexattr -F auid>="+uid_value+" -F auid!=4294967295 -k perm_mod"
		rule_2 = "-a always,exit -F "+ arch_variable + " -S lremovexattr -F auid=0 -k perm_mod"
		unique_data = '\n'.join(filter_unique_audit_rule_list)
		fhandler.write(unique_data)
		for rule in [rule_1,rule_2]:
			if rule not in filter_unique_audit_rule_list:
				fhandler.write("\n"+rule+"\n")

	logging("Adding the audit permission modification related rule to audit file "+file_path)
	fhandler.close()
	runOnShell("auditctl -R "+file_path)
    	RunService("auditd")

def checkRule38560():
	if OsName.lower() == "ubuntu":
		logging("Checking the status of Firewall")
		match_object = runOnShell("ufw status verbose").split('\n')[0]
		match_object1 = match_object.split(':')[1]
		if tokenMatch('active',match_object1):
			logging("Checking the service status of Firewall")
			service_status = runOnShell("service ufw status")
			service_status = service_status.split('\n')[0]
			if "start/running" in service_status:
				return True
	elif OsVersion >= (7,0):
		firewall_status = runOnShell("systemctl is-active firewalld").replace('\n','')
		iptables_status = runOnShell("systemctl is-active iptables").replace('\n','')
		if (firewall_status == "active" and iptables_status == "active"):
		    logging("Firewalld and iptables both are running which should not be used at a time.\
Please fix it manually by turning off one of them.In CentOS 7 the default firewall is `firewalld` so it is recommended to use firewalld.")	
		    return None
		elif firewall_status == "active": 
			if runOnShell("systemctl is-enabled firewalld").replace('\n','') == "enabled":
				return True
		elif iptables_status == "active":
			if runOnShell("systemctl is-enabled iptables").replace('\n','') == "enabled":
				return True
	else:   
    		if CheckService("iptables"):
			logging("Firewall is active/running on the system.")
			return True

	logging("Firewall is not active/running on the system, hence it is recommended to fix it manually.")
	return None


def fixRule38560():
	logging("Please fix it manually.")
	return None
	if OsName.lower() == "ubuntu":
		runOnShell("echo 'y'|ufw enable")
		runOnShell("ufw allow 22")
		runOnShell("ufw reload")
		runOnShell("sysv-rc-conf --level 0123456 ip6tables on")
	else:
		if OsVersion >= (7,0):
			flag_firewal_install = True
			flag_iptable_install = True
			if 'No such file or directory' in runOnShell("systemctl status firewalld"):
				flag_firewal_install = False
			if 'No such file or directory' in runOnShell("systemctl status iptables.service"):
				flag_iptable_install = False
			if flag_firewal_install == False and flag_iptable_install == False:
				runOnShell("yum install firewalld -y")	
				runOnShell("systemctl enable  firewalld")
				runOnShell("systemctl start  firewalld")
		        elif flag_firewal_install == True and flag_iptable_install == False:
				runOnShell("systemctl enable  firewalld")
				runOnShell("systemctl start  firewalld")
			else: 
				runOnShell("systemctl enable  iptables.service")
				runOnShell("systemctl start  iptables.service")
		else:
			runOnShell('chkconfig --level 0123456 iptables on' )
			runOnShell("service iptables start")

def checkRule51391():
    #To check whether aide service is installed or not
    if OsName.lower() == "ubuntu":
        aideConfFilePath = "/etc/aide/aide.conf"
    else:
        aideConfFilePath = "/etc/aide.conf"

    if not CheckPackage("aide"):
        return False

    logging ("Checking aide configuration file existence.")
    if not os.path.exists (aideConfFilePath):
        logging ("aide configuration file is not avaialble. Please fix it manually.")
        return None

    aideDatabaseFilePath = ""
    if OsName.lower() == "ubuntu":
        #To get the AIDE database file from AIDE configuration file
        aideDatabaseFilePath = runOnShell ("grep -w 'database' " + aideConfFilePath + " | grep -v '^#' | cut -d':' -f2")
        if (len(aideDatabaseFilePath.split()) > 1) or (aideDatabaseFilePath == "") or aideDatabaseFilePath.startswith((' ', '\t')):
	    logging ("There is a configuration error in aide configuration file. Please fix it manually.")
            return None

        aideDatabaseFilePath = aideDatabaseFilePath.strip()
    else:
        aideDatabaseFilePath = runOnShell ("grep -w DBDIR " + aideConfFilePath + " | grep -v '^#'" )
        if aideDatabaseFilePath == "":
            logging ("aide database is not configured aide configuration file. Please fix it manually.")
            return None

        aideDatabaseConfigInfo = aideDatabaseFilePath.translate (string.maketrans("\t\r", "  ")).strip()
        aideDatabaseConfigInfo = aideDatabaseFilePath.splitlines()
        aideDatabaseFilePath = aideDatabaseConfigInfo[0]
        aideDatabaseFilePath = re.sub('\s+', ' ', aideDatabaseFilePath)
        try:
            aideDatabaseFilePath = aideDatabaseFilePath.split()[2]
        except IndexError:
	    logging ("There is a configuration error in aide configuration file. Please fix it manually.")
            return None

        #Checking aide database file path existence in aide configuration file
        if aideDatabaseFilePath == "/":
            logging ("aide database can not be created under '/' directory. Please fix it manually.")
            return None
        elif not os.path.exists (aideDatabaseFilePath):
            logging (aideDatabaseFilePath + " does not exist for creating aide database.")
            return False
        else:
            pass

        aideDatabaseFileName = "".join(filter (lambda ele: "database=file:@@" in ele, aideDatabaseConfigInfo))
        try:
            aideDatabaseFileName = aideDatabaseFileName.split('/')[1]
        except IndexError:
	    logging ("There is a configuration error in aide configuration file. Please fix it manually.")
            return None
        aideDatabaseFilePath = aideDatabaseFilePath + "/" + aideDatabaseFileName

    if os.path.exists (aideDatabaseFilePath):
        logging ("The AIDE file integrity tool's data base is created.")
        return True
    else:
        logging ("The AIDE file integrity tool's data base is not created.")
        return False

def fixRule51391():
    if OsName.lower() == "amazon linux ami":
        yumFlag = False
        yumFlagStr = "plugins=0"
        #open the /etc/yum.conf file for searching yumString
        with open("/etc/yum.conf", "r") as yumConfigFile:
            file_data = ""
            for line in yumConfigFile:
                if isL(line) and tokenMatchIC(yumFlagStr, line):
                    yumFlag = True
                    break

        if yumFlag == False:
            #If yum plugin is not set, enable the flag to allow yum to install aide
            setPluginParamYum(False)

    if not CheckPackage ("aide"):
        logging ("Installing the aide package.")
        if OsName.lower() == "ubuntu":
            if "dpkg was interrupted" in runOnShell('apt-get -y install aide'):
                logging ("dpkg is not properly configured.\ndpkg will be properly configured using 'dpkg --configure -a' command.")
                return None
        else:
            runOnShell ("yum -y install aide")

    if (OsName.lower() == "amazon linux ami") and (yumFlag == False):
        #Disable the flag
        setPluginParamYum(True)

    if OsName.lower() == "ubuntu":
        aideConfFilePath = "/etc/aide/aide.conf"
        aideBinFilePath = "/usr/bin/aide"
    else:
        aideConfFilePath = "/etc/aide.conf"
        aideBinFilePath = "/usr/sbin/aide"

    if os.path.exists (aideConfFilePath):
        if OsName.lower() == "ubuntu":
            #To get the AIDE database file from AIDE configuration file
            aideDatabaseFile = runOnShell ("grep -w 'database' " + aideConfFilePath + " | grep -v '^#' | cut -d':' -f2")
            aideDatabaseFile = aideDatabaseFile.strip()
            if (len(aideDatabaseFile.split()) > 1) or (aideDatabaseFile == "") or aideDatabaseFile.startswith((' ', '\t')):
	        logging ("There is a configuration error in aide configuration file.")
                return None
            aideDatabaseFile = aideDatabaseFile.strip()
            splitaideDatabaseFile = aideDatabaseFile.split('/')[:-1]
	    if not os.path.exists ("/".join(splitaideDatabaseFile)):
                logging ("creating " + "/".join(splitaideDatabaseFile) + " for initiating aide database.")
                runOnShell ("mkdir -p " + "/".join(splitaideDatabaseFile))

            if not os.path.exists (aideDatabaseFile):
                aideDatabaseNewFile = runOnShell ("grep -w 'database_out' " + aideConfFilePath + " | grep -v '^#' | cut -d':' -f2")
                if (len(aideDatabaseNewFile.split()) > 1) or (aideDatabaseNewFile == "") or aideDatabaseNewFile.startswith((' ', '\t')):
	            logging ("There is a configuration error in aide configuration file.")
                    return None

                aideDatabaseNewFile = aideDatabaseNewFile.strip()
                if not os.path.exists(aideDatabaseNewFile):
                    logging ("Initiating aide database.")
                    #Generating AIDE database, if not available
                    runOnShell ("aideinit >/dev/null 2>&1")

                if os.path.exists (aideDatabaseNewFile):
                    runOnShell ("cp " + aideDatabaseNewFile +  " " + aideDatabaseFile)
		else:
                    logging ("AIDE database can not be created because aide database base file is not available.")
                    return None
        else:
            aideDatabaseFilePath = runOnShell ("grep -w DBDIR " + aideConfFilePath + " | grep -v '^#'" )
            if aideDatabaseFilePath == "":
                logging ("aide database is not configured in aide configuration file. Please fix it manually.")
                return None

            aideDatabaseConfigInfo = aideDatabaseFilePath.translate (string.maketrans("\t\r", "  ")).strip()
            aideDatabaseConfigInfo = aideDatabaseFilePath.splitlines()
            aideDatabaseFilePath = aideDatabaseConfigInfo[0]
            aideDatabaseFilePath = re.sub('\s+', ' ', aideDatabaseFilePath)
            try:
                aideDatabaseMainFilePath = aideDatabaseFilePath.split()[2]
            except IndexError:
	        logging ("There is a configuration error in aide configuration file.")
                return None
            if aideDatabaseMainFilePath == "/":
                logging ("aide database can't be created under '/' directory.")
                return None
            #Checking aide database file path existence in aide configuration file
            elif not os.path.exists (aideDatabaseMainFilePath):
                logging ("Creating " + aideDatabaseMainFilePath + " path for creating aide database.")
                runOnShell ("mkdir -p " + aideDatabaseMainFilePath)
            else:
                pass

            aideDatabaseFileName = "".join(filter (lambda ele: "database=file:@@" in ele, aideDatabaseConfigInfo))
            try:
                aideDatabaseFileName = aideDatabaseFileName.split('/')[1]
            except IndexError:
                logging ("aide database could not be created.")
                return None
            aideDatabaseFilePath = aideDatabaseMainFilePath + "/" + aideDatabaseFileName
            if not os.path.exists (aideDatabaseFilePath):
                aideDatabaseNewFileName = "".join(filter (lambda ele: "database_out=file:@@" in ele, aideDatabaseConfigInfo))
                try:
                    aideDatabaseNewFileName = aideDatabaseNewFileName.split('/')[1]
                except IndexError:
                    logging ("aide database could not be created.")
                    return None
                aideDatabaseNewFilePath = aideDatabaseMainFilePath + "/" + aideDatabaseNewFileName

                if not os.path.exists (aideDatabaseNewFilePath):
                    logging ("Initiating aide database.")
                    #Initializing aide dtabase
                    runOnShell ("aide --init >/dev/null 2>&1")

                if os.path.exists (aideDatabaseNewFilePath):
                    runOnShell ("cp " + aideDatabaseNewFilePath + " " +  aideDatabaseFilePath)
                else:
                    logging ("AIDE database can not be created because aide database base file is not available.")
                    return None
    else:
        logging ("AIDE configuration file does not exist.")
        return None

    logging ("AIDE is scanning the system.")
    runOnShell (aideBinFilePath + " -c " + aideConfFilePath + " --check")
    if os.system('grep "Couldn\'t open file" ' + aideTmpLogFile) == 0:
        logging ("aide database is not properly configured.")
        return False
    elif os.system ('grep "syntax error" ' + aideTmpLogFile) == 0:
        logging ("Since syntax issues in aide configuration file, need manual remediation to fix the aide configuration error.")
        return None
    else:
	pass

#seems to be same as 103...
def checkRule38561():
    	if not CheckService("auditd"):
		return False

	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Checking for keyword never,task.
    	logging("Checking if system call auditing is disabled.")
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
        	return False

    	#Checking for any error in file.
    	if "error" in runOnShell('auditctl -R '+file_path):
		logging("There is an error in "+file_path+", please fix it manually before remediating the rule.")
		return None

        return_flag = True
        uid_out_user = runOnShell("grep -w lsetxattr "+ file_path + "| grep " + "'auid>="+uid_value+ "' | grep -v '^#' ")
        if uid_out_user == "":
                logging("System is not configured to audit all discretionary access control\
 permission modifications for user using lsetxattr.")
                return_flag = False

        uid_out_root = runOnShell("grep -w lsetxattr " + file_path + "| grep 'auid=0' | grep -v '^#'")
        if uid_out_root == "":
                logging("System is not configured to audit all discretionary access control\
 permission modifications for root user using lsetxattr.")
                return_flag = False

        if not return_flag:
                return False

	logging("System is configured to audit all discretionary access control permission modifications using lsetxattr.")
	return True

def fixRule38561():
        if not InstallPackage("audit"):
            return None

	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Removing for keyword never,task
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging(" Disabling the system call auditing to audit the events properly.")
        	runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /' "+file_path)

	#Clear previous rules set. 
	runOnShell("auditctl -D")
	#Obtaining the data from file_path	
	audit_handler = open(file_path, "r")
	audit_file_rules = audit_handler.readlines()
	audit_handler.close()
	#Removing redundant entries	from data
	filter_unique_audit_rule_list = []	
	for line in list(set(audit_file_rules)):
		line1 = line.strip('\n')
		if (('-b 320' in line1) or ('-D' in line1) or ('#' in line1)):
			continue
		
		final_line = re.sub("\s+" , " ", line1)
		filter_unique_audit_rule_list.append(final_line.strip())
	startup_line = "# This file contains the auditctl rules that are loaded\n # whenever the audit daemon is started via the initscripts.\n # The rules are simply the parameters that would be passed\n# to auditctl.\n # First rule - delete all\n-D\n\n # Increase the buffers to survive stress events.\n # Make this bigger for busy systems\n -b 320\n"

	with open(file_path, "w") as fhandler:
		res = runOnShell("uname -m")
		if "64" in res:
			arch_variable = "arch=b64" 
		else:
			arch_variable = "arch=b32" 
		fhandler.write(startup_line)
		rule_1 = "-a always,exit -F " + arch_variable + " -S lsetxattr -F auid>="+uid_value+" -F auid!=4294967295 -k perm_mod"
		rule_2 = "-a always,exit -F "+ arch_variable + " -S lsetxattr -F auid=0 -k perm_mod"
		unique_data = '\n'.join(filter_unique_audit_rule_list)
		fhandler.write(unique_data)
		for rule in [rule_1,rule_2]:
			if rule not in filter_unique_audit_rule_list:
				fhandler.write("\n"+rule+"\n")
	logging("Configuring the system to audit all discretionary access control permission modifications using lsetxattr.")
	fhandler.close()
	runOnShell("auditctl -R "+file_path)
    	RunService("auditd")

def checkRule38563():
    	if not CheckService("auditd"):
		return False

	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Checking for keyword never,task.
    	logging("Checking if system call auditing is disabled.")
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
        	return False

    	#Checking for any error in file.
    	if "error" in runOnShell('auditctl -R '+file_path):
		logging("There is an error in "+file_path+", please fix it manually before remediating the rule.")
		return None

        return_flag = True
        uid_out_user = runOnShell("grep -w removexattr "+ file_path + "| grep " + "'auid>="+uid_value+ "' | grep -v '^#' ")
        if uid_out_user == "":
                logging("System is not configured to audit all discretionary access control permission modifications for user using removexattr.")
                return_flag = False
        uid_out_root = runOnShell("grep -w removexattr " + file_path + "| grep 'auid=0' | grep -v '^#'")
        if uid_out_root == "":
                logging("System is not configured to audit all discretionary access control permission modifications for root user using removexattr.")
                return_flag = False

        if not return_flag:
                return False

	logging("System is configured to audit all discretionary access control permission modifications using removexattr")	
	return True

def fixRule38563():
        if not InstallPackage("audit"):
            return None

	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Removing for keyword never,task
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging(" Disabling the system call auditing to audit the events properly.")
        	runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /' "+file_path)

	#Clear previous rules set. 
	runOnShell("auditctl -D")
	#Obtaining the data from file_path	
	audit_handler = open(file_path, "r")
	audit_file_rules = audit_handler.readlines()
	audit_handler.close()
	#Removing redundant entries	from data
	filter_unique_audit_rule_list = []	
	for line in list(set(audit_file_rules)):
		line1 = line.strip('\n')
		if (('-b 320' in line1) or ('-D' in line1) or ('#' in line1)):
			continue
		final_line = re.sub("\s+" , " ", line1)
		filter_unique_audit_rule_list.append(final_line.strip())

	startup_line = "# This file contains the auditctl rules that are loaded\n # whenever the audit daemon is started via the initscripts.\n # The rules are simply the parameters that would be passed\n# to auditctl.\n # First rule - delete all\n-D\n\n # Increase the buffers to survive stress events.\n # Make this bigger for busy systems\n -b 320\n"
	
	with open(file_path, "w") as fhandler:
		res = runOnShell("uname -m")
		if "64" in res:
			arch_variable = "arch=b64" 
		else:
			arch_variable = "arch=b32" 
	
		fhandler.write(startup_line)
		rule_1 = "-a always,exit -F " + arch_variable + " -S removexattr -F auid>="+uid_value+" -F auid!=4294967295 -k perm_mod"
		rule_2 = "-a always,exit -F "+ arch_variable + " -S removexattr -F auid=0 -k perm_mod"
		unique_data = '\n'.join(filter_unique_audit_rule_list)
		fhandler.write(unique_data)
		for rule in [rule_1,rule_2]:
			if rule not in filter_unique_audit_rule_list:
				fhandler.write("\n"+rule+"\n")
	
	logging("Configuring the system to audit all discretionary access control permission modifications using removexattr")	
	fhandler.close()
	runOnShell("auditctl -R "+file_path)
    	RunService("auditd")

def checkRule38565():
    	if not CheckService("auditd"):
		return False

	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Checking for keyword never,task.
    	logging("Checking if system call auditing is disabled.")
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
        	return False

    	#Checking for any error in file.
    	if "error" in runOnShell('auditctl -R '+file_path):
		logging("There is an error in "+file_path+", please fix it manually before remediating the rule.")
		return None

        return_flag = True
        uid_out_user = runOnShell("grep -w 'setxattr' "+ file_path + "| grep " + "'auid>="+uid_value+ "' | grep -v '^#' ")
        if uid_out_user == "":
                logging("System is not configured to audit all discretionary access control permission modifications for user using setxattr.")
                return_flag = False
        uid_out_root = runOnShell("grep -w 'setxattr' " + file_path + "| grep 'auid=0' | grep -v '^#'")
        if uid_out_root == "":
                logging("System is not configured to audit all discretionary access control permission modifications for root user using setxattr.")
                return_flag = False

        if not return_flag:
                return False

	logging("System is configured to audit all discretionary access control permission modifications using setxattr.")

	return True

def fixRule38565():
        if not InstallPackage("audit"):
            return None

	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Removing for keyword never,task
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging(" Disabling the system call auditing to audit the events properly.")
        	runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /' "+file_path)

	#Clear previous rules set. 
	runOnShell("auditctl -D")
	#Obtaining the data from file_path
	audit_handler = open(file_path, "r")
	audit_file_rules = audit_handler.readlines()
	audit_handler.close()
	#Removing redundant entries	from data
	filter_unique_audit_rule_list = []
	for line in list(set(audit_file_rules)):
		line1 = line.strip('\n')
		if (('-b 320' in line1) or ('-D' in line1) or ('#' in line1)):
			continue
		final_line = re.sub("\s+" , " ", line1)
		filter_unique_audit_rule_list.append(final_line.strip())

	startup_line = "# This file contains the auditctl rules that are loaded\n # whenever the audit daemon is started via the initscripts.\n # The rules are simply the parameters that would be passed\n# to auditctl.\n # First rule - delete all\n-D\n\n # Increase the buffers to survive stress events.\n # Make this bigger for busy systems\n -b 320\n"
	
	with open(file_path, "w") as fhandler:
		res = runOnShell("uname -m")
		if "64" in res:
			arch_variable = "arch=b64" 
		else:
			arch_variable = "arch=b32" 
	
		fhandler.write(startup_line)
		rule_1 = "-a always,exit -F " + arch_variable + " -S setxattr -F auid>="+uid_value+" -F auid!=4294967295 -k perm_mod"
		rule_2 = "-a always,exit -F "+ arch_variable + " -S setxattr -F auid=0 -k perm_mod"
		unique_data = '\n'.join(filter_unique_audit_rule_list)
		fhandler.write(unique_data)
		for rule in [rule_1,rule_2]:
			if rule not in filter_unique_audit_rule_list:
				fhandler.write("\n"+rule+"\n")
	
	logging("Adding the audit permission modification related rule to audit file "+file_path)
	fhandler.close()
	runOnShell("auditctl -R "+file_path)
    	RunService("auditd")


def checkRule38566():
    	if not CheckService("auditd"):
		return False

    	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Checking for keyword never,task.
    	logging("Checking if system call auditing is disabled.")
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
        	return False

    	#Checking for any error in file.
    	if "error" in runOnShell('auditctl -R '+file_path):
		logging("There is an error in "+file_path+", please fix it manually before remediating the rule.")
		return None

        return_flag = True
	uid_out_user_eacces = runOnShell("grep EACCES "+file_path +"|grep 'auid>="+uid_value+ "' | grep -v '^#'" )
        if uid_out_user_eacces == "":
		logging("System is not configured to audit failed attempts to access files and programs for user.")
                return_flag = False

	uid_out_root_eacces = runOnShell("grep EACCES "+file_path +"|grep 'auid=0'| grep -v '^#'" )
        if uid_out_root_eacces == "":
		logging("System is not configured to audit failed attempts to access files and programs for root user.")
                return_flag = False

	uid_out_user_eperm = runOnShell("grep EPERM "+file_path +"|grep 'auid>="+uid_value+ "' | grep -v '^#'" )
        if uid_out_user_eperm == "":
		logging("System is not configured to audit failed attempts to access files and programs for user.")
                return_flag = False

	uid_out_root_eperm = runOnShell("grep EPERM "+file_path +"|grep 'auid=0'| grep -v '^#'")
        if uid_out_root_eperm == "":
		logging("System is not configured to audit failed attempts to access files and programs for root user.")
                return_flag = False

        if not return_flag:
                return False

	logging("System is configured to audit failed attempts to access files and programs.")
	return True
	
def fixRule38566():
        if not InstallPackage("audit"):
            return None

    	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Removing for keyword never,task
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging(" Disabling the system call auditing to audit the events properly.")
        	runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /' "+file_path)

	#Clear previous rules set. 
	runOnShell("auditctl -D")
	#Obtaining the data from file_path	
	audit_handler = open(file_path, "r")
	audit_file_rules = audit_handler.readlines()
	audit_handler.close()
	#Removing redundant entries	from data
	filter_unique_audit_rule_list = []	
	for line in list(set(audit_file_rules)):
		line1 = line.strip('\n')
		if (('-b 320' in line1) or ('-D' in line1) or ('#' in line1)):
			continue
		final_line = re.sub("\s+" , " ", line1)
		filter_unique_audit_rule_list.append(final_line.strip())

	startup_line = "# This file contains the auditctl rules that are loaded\n # whenever the audit daemon is started via the initscripts.\n # The rules are simply the parameters that would be passed\n# to auditctl.\n # First rule - delete all\n-D\n\n # Increase the buffers to survive stress events.\n # Make this bigger for busy systems\n -b 320\n"

	with open(file_path, "w") as fhandler:
		res = runOnShell("uname -m")
		if "64" in res:
			arch_variable = "arch=b64" 
		else:
			arch_variable = "arch=b32" 

		fhandler.write(startup_line)
		rule_1 = "-a always,exit -F "+ arch_variable +" -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EACCES -F auid>="+uid_value+" -F auid!=4294967295 -k access"
		rule_2 = "-a always,exit -F "+ arch_variable +" -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EPERM -F auid>="+uid_value+" -F auid!=4294967295 -k access"
		rule_3 = "-a always,exit -F "+ arch_variable +" -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EACCES -F auid=0 -k access"
		rule_4 = "-a always,exit -F "+ arch_variable +" -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EPERM -F auid=0 -k access"
		unique_data = '\n'.join(filter_unique_audit_rule_list)
		fhandler.write(unique_data)
		for rule in [rule_1,rule_2,rule_3,rule_4]:
			if rule not in filter_unique_audit_rule_list:
				fhandler.write("\n"+rule+"\n")

	logging("Configuring the system to audit failed attempts to access files and programs.")
	fhandler.close()
	runOnShell("auditctl -R "+file_path)
    	RunService("auditd")


def checkRule38567():
    	if not CheckService("auditd"):
		return False

	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'
	
    	#Checking for keyword never,task.
    	logging("Checking if system call auditing is disabled.")
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
        	return False

    	#Checking for any error in file.
    	if "error" in runOnShell('auditctl -R '+file_path):
		logging("There is an error in "+file_path+", please fix it manually before remediating the rule.")
		return None

	setid_prog = runOnShell('find / -type f -perm /6000 2>/dev/null')
	list_of_lines = setid_prog.splitlines()
	for line in list_of_lines:
		uid_out_user = runOnShell("grep -w " + line + " " + file_path + " | grep " + "'auid>=" + uid_value + "' | grep -v '^#'")
		uid_out_root = runOnShell("grep -w " + line + " " + file_path + " | grep 'auid=0' | grep -v '^#'")
		if uid_out_root == "" or uid_out_user == "":
			logging("System is not configured to audit all use of setuid and setgid programs.")
			return False


	logging("System is configured to audit all use of setuid and setgid programs")
	return True
    

def fixRule38567():
        if not InstallPackage("audit"):
            return None

	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Removing for keyword never,task
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging(" Disabling the system call auditing to audit the events properly.")
        	runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /' "+file_path)

	#Clear previous rules set. 
	runOnShell("auditctl -D")
	#Obtaining the data from file_path	
	audit_handler = open(file_path, "r")
	audit_file_rules = audit_handler.readlines()
	audit_handler.close()
	#Removing redundant entries	from data
	filter_unique_audit_rule_list = []	
	for line in list(set(audit_file_rules)):
		line1 = line.strip('\n')
		if (('-b 320' in line1) or ('-D' in line1) or ('#' in line1)):
			continue
		final_line = re.sub("\s+" , " ", line1)
		filter_unique_audit_rule_list.append(final_line.strip())
		
	startup_line = "# This file contains the auditctl rules that are loaded\n # whenever the audit daemon is started via the initscripts.\n # The rules are simply the parameters that would be passed\n# to auditctl.\n # First rule - delete all\n-D\n\n # Increase the buffers to survive stress events.\n # Make this bigger for busy systems\n -b 320\n"
	
	with open(file_path, "w") as fhandler:
		res = runOnShell("uname -m")
		if "64" in res:
			arch_variable = "arch=b64" 
		else:
			arch_variable = "arch=b32" 
	
		#Adding the starting line to the top of auditctl file .
		fhandler.write(startup_line)
		unique_data = '\n'.join(filter_unique_audit_rule_list)
		fhandler.write(unique_data)
		setid_prog = runOnShell('find / -type f -perm /6000 2>/dev/null')
		setid_list = setid_prog.split("\n")
		show_msg_flag = True
		for line in setid_list:
			if len(line.replace(' ','')) != 0:
				if show_msg_flag:
					logging("Configuring the system to audit all use of setuid and setgid programs")
				user_rule = "-a always,exit -F path=%s -F perm=x -F auid>=" % line
				absolute_user_rule = user_rule + uid_value +" -F auid!=4294967295 -k privileged"
				root_rule = "-a always,exit -F path=%s -F perm=x -F auid=0" % line
				root_rule = root_rule+" -k privileged"
				if absolute_user_rule not in filter_unique_audit_rule_list:
					fhandler.write("\n"+absolute_user_rule+"\n")
				if root_rule not in filter_unique_audit_rule_list:
					fhandler.write("\n"+root_rule+"\n")
			show_msg_flag = False


	logging("Configuring the system to audit successful file system mounts.")		
	fhandler.close()
	runOnShell("auditctl -R "+file_path)#Reading the rules from audit rule file.
    	RunService("auditd")

def checkRule38568():
    	if not CheckService("auditd"):
		return False

	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'
	
    	#Checking for keyword never,task.
    	logging("Checking if system call auditing is disabled.")
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
        	return False

    	#Checking for any error in file.
    	if "error" in runOnShell('auditctl -R '+file_path):
		logging("There is an error in "+file_path+", please fix it manually before remediating the rule.")
		return None

	return_flag = True
	uid_out_user = runOnShell("grep -w '\-S\s*mount' "+ file_path + "| grep " + "'auid>="+uid_value+ "' | grep -v '^#' ")
	if uid_out_user == "":
	    	logging("System is not configured to audit successful file system mounts for system user")		
		return_flag = False

	uid_out_root = runOnShell("grep -w '\-S\s*mount' " + file_path + "| grep 'auid=0' | grep -v '^#'")
	if uid_out_root == "":
	    	logging("System is not configured to audit successful file system mounts for root user")		
		return_flag = False

	if not return_flag:
		return False

	logging("System is configured to audit successful file system mounts.")		
	return True
	
def fixRule38568():
        if not InstallPackage("audit"):
            return None

	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Removing for keyword never,task
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging(" Disabling the system call auditing to audit the events properly.")
        	runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /' "+file_path)

	#Clear previous rules set. 
	runOnShell("auditctl -D")
	#Obtaining the data from file_path	
	audit_handler = open(file_path, "r")
	audit_file_rules = audit_handler.readlines()
	audit_handler.close()
	#Removing redundant entries	from data
	filter_unique_audit_rule_list = []	
	for line in list(set(audit_file_rules)):
		line1 = line.strip('\n')
		if (('-b 320' in line1) or ('-D' in line1) or ('#' in line1)):
			continue
		final_line = re.sub("\s+" , " ", line1)
		filter_unique_audit_rule_list.append(final_line.strip())
		
	startup_line = "# This file contains the auditctl rules that are loaded\n # whenever the audit daemon is started via the initscripts.\n # The rules are simply the parameters that would be passed\n# to auditctl.\n # First rule - delete all\n-D\n\n # Increase the buffers to survive stress events.\n # Make this bigger for busy systems\n -b 320\n"
	
	with open(file_path, "w") as fhandler:
		res = runOnShell("uname -m")
		if "64" in res:
			arch_variable = "arch=b64" 
		else:
			arch_variable = "arch=b32" 
	
		#Adding the starting line to the top of auditctl file .
		fhandler.write(startup_line)
		rule_1 = "-a always,exit -F " + arch_variable + " -S mount -F auid>="+uid_value+" -F auid!=4294967295 -k export"
		rule_2 = "-a always,exit -F "+ arch_variable + " -S mount -F auid=0 -k export"
		unique_data = '\n'.join(filter_unique_audit_rule_list)
		fhandler.write(unique_data)
		for rule in [rule_1,rule_2]:
			if rule not in filter_unique_audit_rule_list:
				fhandler.write("\n"+rule+"\n")
	

	logging("Configuring the system to audit successful file system mounts.")		
	fhandler.close()
	runOnShell("auditctl -R "+file_path)#Reading the rules from audit rule file.
    	RunService("auditd")

def checkRule38569(min_val=-1):
        qualityCheck = False # flag to check if ucredit exist in pwquality.conf
        grepModule = "pam_cracklib.so"
        if OsName.lower() == "ubuntu":
	    if not CheckPackage("libpam-cracklib"):
		return False
            filePath = "/etc/pam.d/common-password"
        else:
            filePath = "/etc/pam.d/system-auth"
            if OsVersion >= (7,0):
                grepModule = 'pam_pwquality.so'
		logging("Checking for how many uppercase are required in a password in the password quality configuration file.")
		# Checking the ucredit in the /etc/security/pwquality.conf file
		checkPwQuality = runOnShell('grep -w ucredit /etc/security/pwquality.conf | grep -v "^#"')
		checkDigit = re.match(r'.*\s*(\bucredit\s*=\s*-?\d\b)\s*', checkPwQuality)
	        if checkDigit != None:
	            parameter = checkDigit.group(1)
	            actualParamDigit,paramValueDigit =  parameter.split("=")
	            actualParamDigit = actualParamDigit.replace(" ","")
	            paramValueDigit = paramValueDigit.replace(" ","")
	            qualityCheck = True
	logging("Checking for how many uppercase characters are required in a password, the DoD requires at least one uppercase in a password.")
	checkResult = runOnShell('grep -w '+ grepModule + " " + filePath +' | grep -w requisite | grep -v "^#"')
	checkResult = checkResult.translate(string.maketrans("\n\t\r", "   ")).strip()
	matchObj = re.match(r'.*\s*(\bucredit=-?\w*\b)\s*', checkResult)
	if matchObj:
	    parameter = matchObj.group(1)
	    actualParam,paramValue =  parameter.split("=")
	    if paramValue != "":
		try:
		    validValue = False
		    if qualityCheck:
			if int(paramValue) <= min_val and int(paramValue) <= int(paramValueDigit):
				validValue = True
		    else:
			if int(paramValue) <= min_val:
				validValue = True
		    if validValue:
		    	logging("The minimum uppercase requirement in a password is configured correctly.")
			return True
		except:
                    logging("The minimum uppercase required in a password is not specified correctly.")
		    return False
	logging("The parameter for minimum uppercase is not specified correctly.")
	return False

def fixRule38569(min_val=-1):
	paramValue = -1
	qualityCheck = False # flag to check if ucredit exist in pwquality.conf
	grepModule = 'pam_cracklib.so'
	if OsName.lower() == "ubuntu":
	    if not CheckPackage("libpam-cracklib"):
                InstallPackage("libpam-cracklib")
	    filePath = "/etc/pam.d/common-password"
	else:
	    filePath = "/etc/pam.d/system-auth"
            if OsVersion >= (7,0):
                grepModule = 'pam_pwquality.so'
		checkPwQuality = runOnShell('grep -w ucredit /etc/security/pwquality.conf | grep -v "^#"')
		checkDigit = re.match(r'.*\s*(\bucredit\s*=\s*-?\d\b)\s*', checkPwQuality)
		if checkDigit != None:
		    parameter = checkDigit.group(1)
		    actualParamDigit,paramValueDigit =  parameter.split("=")
		    actualParamDigit = actualParamDigit.replace(" ","")
		    paramValueDigit = paramValueDigit.replace(" ","")
		    qualityCheck = True
	checkResult = runOnShell('grep -w '+ grepModule + " " + filePath +' | grep -w requisite | grep -v "^#"')
	with open(filePath, "r") as file_content:
            fileString = ""
	    lastLine = ""
            logging("Updating the uppercase characters requirement in a password, the DoD requires at least one uppercase character in a password.")
            for line in file_content:
                updateValue = False
		moduleSearchObj = re.search('^password\s*requisite\s*'+ grepModule,line,re.M|re.I)
		if moduleSearchObj != None and checkResult != "":
			checkValue = False
			if isL(line) and "ucredit" in line:
			    line = line.translate(string.maketrans("\n\t\r", "   ")).strip()
			    matchObjs = re.match(r'.*\s*(\bucredit=-?\w\b)\s*', checkResult)
			    resultTranslate = checkResult.translate(string.maketrans("\n\t\r", "   "))
			    if tokenMatchIC("ucredit", resultTranslate) or tokenMatchIC("ucredit=", resultTranslate):
				checkValue = True
			    elif matchObjs != None:
				parameter = matchObjs.group(1)
				actualParam,paramValue =  parameter.split("=")
				try:
				    if qualityCheck:
					if int(paramValue) > int(paramValueDigit):
						checkValue = True
				    elif (int(paramValue) > min_val):
						checkValue = True
				    else:
					pass
				except:
				    checkValue = True
			    else:
				updateValue = True
			else:
			    updateValue = True
			if qualityCheck:
			    if int(paramValue) > int(paramValueDigit):
				newValue = paramValueDigit
			    else:
				newValue = paramValue
			else:
				newValue = min_val
			if checkValue:
			    start = line.index("ucredit")
			    new = line[start:]
			    try:
			        end = new.index(" ")
			        line = line[0:start] + "ucredit="+str(newValue) + line[start+end:]
			    except:
			        end = 10
			        line = line[0:start] + "ucredit="+str(newValue) + line[start+end:len(line[start:])]
			if updateValue:
			    line = line.translate(string.maketrans("\n", " ")).strip()
			    line = line+' ucredit='+str(newValue)
			if "Cloud Raxak updated next line" not in lastLine:
                            fileString += "# Cloud Raxak updated next line\n"
			fileString += line + '\n'
		elif checkResult == "":
		    if OsName.lower() == "ubuntu":
		        if re.search('^password\s*\[success\=1\sdefault=ignore\]\s*pam_unix.so', line):
                            if "Cloud Raxak updated next line" not in lastLine:
                                fileString += "# Cloud Raxak updated next line\n"
		            fileString += "password       requisite       pam_cracklib.so ucredit=-1\n"
	    	    else:
		        if re.search('^password\s*sufficient\s*pam_unix.so',line):
                            if "Cloud Raxak updated next line" not in lastLine:
                                fileString += "# Cloud Raxak updated next line\n"
			    if qualityCheck:
				if (int(paramValueDigit)) < min_val:
					fileString += "password     requisite     "+ grepModule + " ucredit="+paramValueDigit +"\n"
				else:
					fileString += "password     requisite     "+ grepModule + " ucredit=-1\n"
			    else:
				fileString += "password     requisite     "+ grepModule + " ucredit=-1\n"
		    fileString += line
		else:
		    fileString += line
		lastLine = line
	fout = None
        fout = open(filePath, 'wt')
        if fout != None:
            fout.write(fileString)
            fout.close()
	
def checkRule38570(min_val=-1):
        qualityCheck = False # flag to check if ocredit exist in pwquality.conf
        grepModule = "pam_cracklib.so"
        if OsName.lower() == "ubuntu":
	    if not CheckPackage("libpam-cracklib"):
		return False
            filePath = "/etc/pam.d/common-password"
        else:
            filePath = "/etc/pam.d/system-auth"
            if OsVersion >= (7,0):
                grepModule = 'pam_pwquality.so'
	        logging("Checking for how many special characters are required in a password quality configuration file.")
		# Checking the ocredit in the /etc/security/pwquality.conf file
		checkPwQuality = runOnShell('grep -w ocredit /etc/security/pwquality.conf | grep -v "^#"')
		checkDigit = re.match(r'.*\s*(\bocredit\s*=\s*-?\d\b)\s*', checkPwQuality)
	        if checkDigit != None:
	            parameter = checkDigit.group(1)
	            actualParamDigit,paramValueDigit =  parameter.split("=")
	            actualParamDigit = actualParamDigit.replace(" ","")
	            paramValueDigit = paramValueDigit.replace(" ","")
	            qualityCheck = True
	logging("Checking for how many special characters are required in a password, the DoD requires at least one special character must be used.")
	checkResult = runOnShell('grep -w '+ grepModule + " " + filePath +' | grep -w requisite | grep -v "^#"')
	checkResult = checkResult.translate(string.maketrans("\n\t\r", "   ")).strip()
	matchObj = re.match(r'.*\s*(\bocredit=-?\w*\b)\s*', checkResult)
	if matchObj:
	    parameter = matchObj.group(1)
	    actualParam,paramValue =  parameter.split("=")
	    if paramValue != "":
		try:
		    validValue = False
		    if qualityCheck:
			if int(paramValue) <= min_val and int(paramValue) <= int(paramValueDigit):
				validValue = True
		    else:
			if int(paramValue) <= min_val:
				validValue = True
		    if validValue:
		    	logging("The minimum  special characters requirement in a password is configured correctly.")
			return True
		except:
		    logging("The minimum special characters required in a password is not specified correctly.")
		    return False
	logging("The parameter for minimum special characters is not specified correctly.")
	return False

def fixRule38570(min_val=-1):
        paramValue = -1
	qualityCheck = False # flag to check if ocredit exist in pwquality.conf
	grepModule = 'pam_cracklib.so'
	if OsName.lower() == "ubuntu":
	    if not CheckPackage("libpam-cracklib"):
                InstallPackage("libpam-cracklib")
	    filePath = "/etc/pam.d/common-password"
	else:
	    filePath = "/etc/pam.d/system-auth"
            if OsVersion >= (7,0):
                grepModule = 'pam_pwquality.so'
		checkPwQuality = runOnShell('grep -w ocredit /etc/security/pwquality.conf | grep -v "^#"')
		checkDigit = re.match(r'.*\s*(\bocredit\s*=\s*-?\d\b)\s*', checkPwQuality)
		if checkDigit != None:
		    parameter = checkDigit.group(1)
		    actualParamDigit,paramValueDigit =  parameter.split("=")
		    actualParamDigit = actualParamDigit.replace(" ","")
		    paramValueDigit = paramValueDigit.replace(" ","")
		    qualityCheck = True
	checkResult = runOnShell('grep -w '+ grepModule + " " + filePath +' | grep -w requisite | grep -v "^#"')
	with open(filePath, "r") as file_content:
            fileString = ""
            lastLine = ""
            logging("Updating the special characters requirement in a password, the DoD requires at least one special character in a password.")
            for line in file_content:
	        updateValue = False
		moduleSearchObj = re.search('^password\s*requisite\s*'+ grepModule,line,re.M|re.I)
		if moduleSearchObj != None and checkResult != "":
			checkValue = False
			if isL(line) and "ocredit" in line:
			    line = line.translate(string.maketrans("\n\t\r", "   ")).strip()
			    matchObjs = re.match(r'.*\s*(\bocredit=-?\w\b)\s*', checkResult)
			    resultTranslate = checkResult.translate(string.maketrans("\n\t\r", "   "))
			    if tokenMatchIC("ocredit", resultTranslate) or tokenMatchIC("ocredit=", resultTranslate):
				checkValue = True
			    elif matchObjs != None:
				parameter = matchObjs.group(1)
				actualParam,paramValue =  parameter.split("=")
				try:
				    if qualityCheck:
					if int(paramValue) > int(paramValueDigit):
						checkValue = True
				    elif (int(paramValue) > min_val):
						checkValue = True
				    else:
					pass
				except:
				    checkValue = True
			    else:
				updateValue = True
			else:
			    updateValue = True
			if qualityCheck:
			    if int(paramValue) > int(paramValueDigit):
				newValue = paramValueDigit
			    else:
				newValue = paramValue
			else:
				newValue = min_val
			if checkValue:
			    start = line.index("ocredit")
			    new = line[start:]
			    try:
			        end = new.index(" ")
			        line = line[0:start] + "ocredit="+str(newValue) + line[start+end:]
			    except:
			        end = 10
			        line = line[0:start] + "ocredit="+str(newValue) + line[start+end:len(line[start:])]

			if updateValue:
			    line = line.translate(string.maketrans("\n", " ")).strip()
			    line = line+' ocredit='+str(newValue)
			if "Cloud Raxak updated next line" not in lastLine:
                            fileString += "# Cloud Raxak updated next line\n"
			fileString += line + '\n'
		elif checkResult == "":
		    if OsName.lower() == "ubuntu":
		        if re.search('^password\s*\[success\=1\sdefault=ignore\]\s*pam_unix.so', line):
			    if "Cloud Raxak updated next line" not in lastLine:
				fileString += "# Cloud Raxak updated next line\n"
			    fileString += "password       requisite       pam_cracklib.so ocredit=-1\n"
	    	    else:
		        if re.search('^password\s*sufficient\s*pam_unix.so',line):
			    if "Cloud Raxak updated next line" not in lastLine:
                                        fileString += "# Cloud Raxak updated next line\n"
			    if qualityCheck:
				if (int(paramValueDigit)) < min_val:
                                    fileString += "password     requisite     "+ grepModule + " ocredit="+paramValueDigit +"\n"
				else:
				    fileString += "password     requisite     "+ grepModule + " ocredit=-1\n"
			    else:
				fileString += "password     requisite     "+ grepModule + " ocredit=-1\n"
		    fileString += line
		else:
		    fileString += line
		lastLine = line
	fout = None
        fout = open(filePath, 'wt')
        if fout != None:
            fout.write(fileString)
            fout.close()

def checkRule38571(min_val=-1):
	qualityCheck = False # flag to check if lcredit exist in pwquality.conf
        grepModule = "pam_cracklib.so"
        if OsName.lower() == "ubuntu":
	    if not CheckPackage("libpam-cracklib"):
		return False
            filePath = "/etc/pam.d/common-password"
        else:
            filePath = "/etc/pam.d/system-auth"
            if OsVersion >= (7,0):
                grepModule = 'pam_pwquality.so'
	        logging("Checking for how many lowercase characters are required in a password quality configuration file.")
		# Checking the lcredit in the /etc/security/pwquality.conf file
		checkPwQuality = runOnShell('grep -w lcredit /etc/security/pwquality.conf | grep -v "^#"')
		checkDigit = re.match(r'.*\s*(\blcredit\s*=\s*-?\d\b)\s*', checkPwQuality)
	        if checkDigit != None:
	            parameter = checkDigit.group(1)
	            actualParamDigit,paramValueDigit =  parameter.split("=")
	            actualParamDigit = actualParamDigit.replace(" ","")
	            paramValueDigit = paramValueDigit.replace(" ","")
	            qualityCheck = True
	logging("Checking for how many lowercase characters are required in a password, the DoD requires at least one lowercase character must be used.")
	checkResult = runOnShell('grep -w '+ grepModule + " " + filePath +' | grep -w requisite | grep -v "^#"')
	checkResult = checkResult.translate(string.maketrans("\n\t\r", "   ")).strip()
	matchObj = re.match(r'.*\s*(\blcredit=-?\w*\b)\s*', checkResult)
	if matchObj:
	    parameter = matchObj.group(1)
	    actualParam,paramValue =  parameter.split("=")
	    if paramValue != "":
		try:
		    validValue = False
		    if qualityCheck:
			if int(paramValue) <= min_val and int(paramValue) <= int(paramValueDigit):
				validValue = True
		    else:
			if int(paramValue) <= min_val:
				validValue = True
		    if validValue:
		    	logging("The minimum  lowercase characters requirement in a password is configured correctly.")
			return True
		except:
		    logging("The minimum lowercase characters required in a password is not specified correctly.")
		    return False
	logging("The parameter for minimum lowercase characters is not specified correctly.")
	return False

def fixRule38571(min_val=-1):
	paramValue = -1
	qualityCheck = False # flag to check if lcredit exist in pwquality.conf
	grepModule = 'pam_cracklib.so'
	if OsName.lower() == "ubuntu":
	    if not CheckPackage("libpam-cracklib"):
                InstallPackage("libpam-cracklib")
	    filePath = "/etc/pam.d/common-password"
	else:
	    filePath = "/etc/pam.d/system-auth"
            if OsVersion >= (7,0):
                grepModule = 'pam_pwquality.so'
		checkPwQuality = runOnShell('grep -w lcredit /etc/security/pwquality.conf | grep -v "^#"')
		checkDigit = re.match(r'.*\s*(\blcredit\s*=\s*-?\d\b)\s*', checkPwQuality)
		if checkDigit != None:
		    parameter = checkDigit.group(1)
		    actualParamDigit,paramValueDigit =  parameter.split("=")
		    actualParamDigit = actualParamDigit.replace(" ","")
		    paramValueDigit = paramValueDigit.replace(" ","")
		    qualityCheck = True
	checkResult = runOnShell('grep -w '+ grepModule + " " + filePath +' | grep -w requisite | grep -v "^#"')
	with open(filePath, "r") as file_content:
            fileString = ""
            lastLine = ""
            logging("Updating the lowercase character requirement in a password, the DoD requires at least one lowercase character in a password.")
            for line in file_content:
	        updateValue = False
		moduleSearchObj = re.search('^password\s*requisite\s*'+ grepModule,line,re.M|re.I)
		if moduleSearchObj != None and checkResult != "":
			checkValue = False
			if isL(line) and "lcredit" in line:
			    line = line.translate(string.maketrans("\n\t\r", "   ")).strip()
			    matchObjs = re.match(r'.*\s*(\blcredit=-?\w\b)\s*', checkResult)
			    resultTranslate = checkResult.translate(string.maketrans("\n\t\r", "   "))
			    if tokenMatchIC("lcredit", resultTranslate) or tokenMatchIC("lcredit=", resultTranslate):
				checkValue = True
			    elif matchObjs != None:
				parameter = matchObjs.group(1)
				actualParam,paramValue =  parameter.split("=")
				try:
				    if qualityCheck:
					if int(paramValue) > int(paramValueDigit):
						checkValue = True
				    elif (int(paramValue) > min_val):
						checkValue = True
				    else:
					pass
				except:
				    checkValue = True
			    else:
				updateValue = True
			else:
			    updateValue = True
			if qualityCheck:
			    if int(paramValue) > int(paramValueDigit):
				newValue = paramValueDigit
			    else:
				newValue = paramValue
			else:
				newValue = min_val
			if checkValue:
			    start = line.index("lcredit")
			    new = line[start:]
			    try:
			        end = new.index(" ")
			        line = line[0:start] + "lcredit="+str(newValue) + line[start+end:]
			    except:
			        end = 10
			        line = line[0:start] + "lcredit="+str(newValue) + line[start+end:len(line[start:])]
			if updateValue:
			    line = line.translate(string.maketrans("\n", " ")).strip()
			    line = line+' lcredit='+str(newValue)
			if "Cloud Raxak updated next line" not in lastLine:
                            fileString += "# Cloud Raxak updated next line\n"
			fileString += line + '\n'
		elif checkResult == "":
		    if OsName.lower() == "ubuntu":
		        if re.search('^password\s*\[success\=1\sdefault=ignore\]\s*pam_unix.so', line):
                            if "Cloud Raxak updated next line" not in lastLine:
				fileString += "# Cloud Raxak updated next line\n"
		            fileString += "password       requisite       pam_cracklib.so lcredit=-1\n"
	    	    else:
		        if re.search('^password\s*sufficient\s*pam_unix.so',line):
                            if "Cloud Raxak updated next line" not in lastLine:
                                fileString += "# Cloud Raxak updated next line\n"
			    if qualityCheck:
				if (int(paramValueDigit)) < min_val:
					fileString += "password     requisite     "+ grepModule + " lcredit=" + paramValueDigit +"\n"
				else:
					fileString += "password     requisite     "+ grepModule + " lcredit=-1\n"
			    else:
				fileString += "password     requisite     "+ grepModule + " lcredit=-1\n"
		    fileString += line
		else:
		    fileString += line
		lastLine = line
	fout = None
        fout = open(filePath, 'wt')
        if fout != None:
            fout.write(fileString)
            fout.close()

def checkRule38572(difokMinValue=4):
	qualityCheck = False # flag to check if difok exist in pwquality.conf
        grepModule = "pam_cracklib.so"
        if OsName.lower() == "ubuntu":
	    if not CheckPackage("libpam-cracklib"):
		return False
            filePath = "/etc/pam.d/common-password"
        else:
            filePath = "/etc/pam.d/system-auth"
            if OsVersion >= (7,0):
                grepModule = 'pam_pwquality.so'
	        logging("Checking for how many special characters are required in a password quality configuration file.")
		# Checking the difok in the /etc/security/pwquality.conf file
		checkPwQuality = runOnShell('grep -w difok /etc/security/pwquality.conf | grep -v "^#"')
		checkDigit = re.match(r'.*\s*(\bdifok\s*=\s*\d\b)\s*', checkPwQuality)
	        if checkDigit != None:
	            parameter = checkDigit.group(1)
	            actualParamDigit,paramValueDigit =  parameter.split("=")
	            actualParamDigit = actualParamDigit.replace(" ","")
	            paramValueDigit = paramValueDigit.replace(" ","")
	            qualityCheck = True
	logging("Checking for minimum number of different characters required during password change.")
	checkResult = runOnShell('grep -w '+ grepModule + " " + filePath +' | grep -w requisite | grep -v "^#"')
	checkResult = checkResult.translate(string.maketrans("\n\t\r", "   ")).strip()
	matchObj = re.match(r'.*\s*(\bdifok=\w*\b)\s*', checkResult)
	if matchObj:
	    parameter = matchObj.group(1)
	    actualParam,paramValue =  parameter.split("=")
	    if paramValue != "":
		try:
		    validValue = False
		    if qualityCheck:
			if int(paramValue) >= difokMinValue and int(paramValue) >= int(paramValueDigit):
				validValue = True
		    else:
			if int(paramValue) >= difokMinValue:
				validValue = True
		    if validValue:
			logging("The password configuration for checking the difference of characters during password change is configured correctly.")
			return True
		except:
                    logging("The password configuration for checking the difference of characters during password change is not specified correctly.")
		    return False
	logging("The parameter for checking the difference of characters during password change is not specified correctly.")
	return False

def fixRule38572(difokMinValue=4):
	paramValue = 4
	qualityCheck = False # flag to check if difok exist in pwquality.conf
	grepModule = 'pam_cracklib.so'
	if OsName.lower() == "ubuntu":
	    if not CheckPackage("libpam-cracklib"):
                InstallPackage("libpam-cracklib")
	    filePath = "/etc/pam.d/common-password"
	else:
	    filePath = "/etc/pam.d/system-auth"
            if OsVersion >= (7,0):
                grepModule = 'pam_pwquality.so'
		checkPwQuality = runOnShell('grep -w difok /etc/security/pwquality.conf | grep -v "^#"')
		checkDigit = re.match(r'.*\s*(\bdifok\s*=\s*\d\b)\s*', checkPwQuality)
		if checkDigit != None:
		    parameter = checkDigit.group(1)
		    actualParamDigit,paramValueDigit =  parameter.split("=")
		    actualParamDigit = actualParamDigit.replace(" ","")
		    paramValueDigit = paramValueDigit.replace(" ","")
		    qualityCheck = True
	checkResult = runOnShell('grep -w '+ grepModule + " " + filePath +' | grep -w requisite | grep -v "^#"')
	with open(filePath, "r") as file_content:
            fileString = ""
	    lastLine = ""
	    logging("Updating the requirement of different characters in a password.")
            for line in file_content:
	        updateValue = False
		moduleSearchObj = re.search('^password\s*requisite\s*'+ grepModule, line)
		if moduleSearchObj != None and checkResult != "":
			checkValue = False
			if isL(line) and "difok" in line:
			    line = line.translate(string.maketrans("\n\t\r", "   ")).strip()
			    matchObjs = re.match(r'.*\s*(\bdifok=\d\b)\s*', checkResult)
			    resultTranslate = checkResult.translate(string.maketrans("\n\t\r", "   "))
			    if tokenMatchIC("difok", resultTranslate) or tokenMatchIC("difok=", resultTranslate):
				checkValue = True
			    elif matchObjs != None:
				parameter = matchObjs.group(1)
				actualParam,paramValue =  parameter.split("=")
				try:
				    if qualityCheck:
					if int(paramValue) < int(paramValueDigit):
						checkValue = True
				    elif (int(paramValue) < difokMinValue):
						checkValue = True
				    else:
					pass
				except:
				    checkValue = True
			    else:
				updateValue = True
			else:
			    updateValue = True
			if qualityCheck:
			    if int(paramValue) < int(paramValueDigit):
				newValue = paramValueDigit
			    else:
				newValue = paramValue
			else:
				newValue = difokMinValue
			if checkValue:
			    start = line.index("difok")
			    new = line[start:]
			    try:
			        end = new.index(" ")
			        line = line[0:start] + "difok="+str(newValue) + line[start+end:]
			    except:
			        end = 8
			        line = line[0:start] + "difok="+str(newValue) + line[start+end:len(line[start:])]
			if updateValue:
			    line = line.translate(string.maketrans("\n", " ")).strip()
			    line = line+' difok='+str(newValue)
			if "Cloud Raxak updated next line" not in lastLine:
                            fileString += "# Cloud Raxak updated next line\n"
			fileString += line + '\n'
		elif checkResult == "":
		    if OsName.lower() == "ubuntu":
		        if re.search('^password\s*\[success\=1\sdefault=ignore\]\s*pam_unix.so', line):
                            if "Cloud Raxak updated next line" not in lastLine:
                                fileString += "# Cloud Raxak updated next line\n"
		            fileString += "password       requisite       pam_cracklib.so difok=4\n"
	    	    else:
		        if re.search('^password\s*sufficient\s*pam_unix.so',line):
                            if "Cloud Raxak updated next line" not in lastLine:
                                fileString += "# Cloud Raxak updated next line\n"
			    if qualityCheck:
				if (int(paramValueDigit) > difokMinValue):
					fileString += "password     requisite     "+ grepModule + " difok="+paramValueDigit +"\n"
				else:
					fileString += "password     requisite     "+ grepModule + " difok=4\n"
			    else:
				fileString += "password     requisite     "+ grepModule + " difok=4\n"
		    fileString += line
		else:
		    fileString += line
		lastLine = line
	fout = None
        fout = open(filePath, 'wt')
        if fout != None:
            fout.write(fileString)
            fout.close()

def checkRule38573(val=3):
    logging("Checking the configuration to lock out accounts after a number of incorrect logon attempts.") 
    if OsName.lower() == "ubuntu":
	listPath = ['/etc/pam.d/common-auth']
	checkCommonAuthFile = runOnShell('grep "auth\s*required\s*pam_tally2.so" /etc/pam.d/common-auth | grep -v "^#"')
	checkCommonAccount = runOnShell('grep "account\s*required\s*pam_tally2.so" /etc/pam.d/common-account | grep -v "^#"')
	if (checkCommonAuthFile == "") or (checkCommonAccount == ""):
                logging("Failed password attempt policy is not configured correctly.")
		return False

	data = [checkCommonAuthFile]
    else:
	listPath = ['/etc/pam.d/system-auth','/etc/pam.d/password-auth']

    returnFlag = True
    for fileName in listPath:
	if not OsName.lower() == "ubuntu":
            # Checking for the auth and account lines in the system-auth and pawword-auth files.
            systemAuthReq = runOnShell('grep "auth\s*required\s*pam_faillock.so" '+ fileName + ' | grep -v "^#"')
	    systemAuthDefault = runOnShell('grep "auth\s*\[default\=die\]\s*pam_faillock.so" '+ fileName + ' | grep -v "^#"') 
            systemAccReq = runOnShell('grep "account\s*required\s*pam_faillock.so" '+ fileName + ' | grep -v "^#"')

            if (systemAuthReq == "") or (systemAccReq == "") or (systemAuthDefault == ""):
                logging("Failed password attempt policy is not configured correctly.")
                return False
            data = [systemAuthReq, systemAuthDefault]

        for line in data:
	    if OsName.lower() == "ubuntu":
                if re.match(r'.*\s*(\bauth\s*required\s*pam_tally2.so\b)\s*', line):
		    line = line.translate(string.maketrans("\n\t\r", "   "))
            else:
		if re.match(r'.*\s*(\bauth\s*required\s*pam_faillock.so\b)\s*', line) or \
		    re.match(r'.*\s*(\bauth\s*\[default\=die\]\s*pam_faillock.so\b)\s*', line):
		    line = line.translate(string.maketrans("\n\t\r", "   "))
	    matchObjs = re.match(r'.*\s*(\bdeny=\w*\b)\s*', line)
            if matchObjs != None:
                parameter = matchObjs.group(1)
                actualParam,paramValue =  parameter.split("=")
                try:
                    if (int(paramValue) <= 0) or (int(paramValue) > val):
                        returnFlag = False
                        break
                except:
                    returnFlag = False
                    break
            else:
                returnFlag = False
                break
        if not returnFlag:
            logging("Failed password attempt policy is not configured correctly.")
            return False
    logging("Failed password attempt policy is configured correctly.")
    return True


def fixRule38573(val=3):
    logging("Modifying the password configuration to lock out account(s) after a number of incorrect logon attempts.")
    if OsName.lower() == "ubuntu":
	listPath = ['/etc/pam.d/common-auth','/etc/pam.d/common-account']
	systemAuthReq = runOnShell('grep "auth\s*required\s*pam_tally2.so" /etc/pam.d/common-auth | grep -v "^#"')
	systemAccReq = runOnShell('grep "account\s*required\s*pam_tally2.so" /etc/pam.d/common-account | grep -v "^#"')
    else:
	listPath = ['/etc/pam.d/system-auth','/etc/pam.d/password-auth']

    moduleSearchAuthDefault = ""
    systemAuthDefault = "" 
    for fileName in listPath:
	if not OsName.lower() == "ubuntu":
            systemAuthReq = runOnShell('grep "auth\s*required\s*pam_faillock.so" '+ fileName + ' | grep -v "^#"')
    
            systemAuthDefault = runOnShell('grep "auth\s*\[default\=die\]\s*pam_faillock.so" '+ fileName + ' | grep -v "^#"') 
            systemAccReq = runOnShell('grep "account\s*required\s*pam_faillock.so" '+ fileName + ' | grep -v "^#"')
        
	fileData = open(fileName,"r")
        fileString = ""
	lastLine = ""
	updateValue = False
        for line in fileData:
	    updateValue = False

	    if OsName.lower() == "ubuntu":
                moduleSearchAuthReq = re.search('auth\s*required\s*pam_tally2.so',line)
	    else:
                moduleSearchAuthReq = re.search('auth\s*required\s*pam_faillock.so',line)
		moduleSearchAuthDefault = re.search('auth\s*\[default\=die\]\s*pam_faillock.so',line)
            moduleSearchAccReq = re.search('account\s*required\s*pam_faillock.so',line)

	    if (moduleSearchAuthReq != None and systemAuthReq) or (moduleSearchAuthDefault != None and systemAuthDefault):
		# Updating the deny parameter if not configured properly.
		checkValue = False
		if isL(line) and "deny" in line:
		    line = line.translate(string.maketrans("\n\t\r", "   ")).strip()
		    matchObjs = re.match(r'.*\s*(\bdeny=\w*\b)\s*', line)
		    systemAuthReq = systemAuthReq.translate(string.maketrans("\n\t\r", "   "))
		    systemAuthDefault = systemAuthDefault.translate(string.maketrans("\n\t\r", "   "))
		    if tokenMatchIC("deny", systemAuthReq) or tokenMatchIC("deny=", systemAuthReq):
			checkValue = True
		    elif tokenMatchIC("deny", systemAuthDefault) or tokenMatchIC("deny=", systemAuthDefault):
			checkValue = True
		    elif matchObjs != None:
			parameter = matchObjs.group(1)
			actualParam,paramValue = parameter.split("=")
			try:
                            if (int(paramValue) <= 0) or (int(paramValue) > val):
				checkValue = True
			    else:
				pass
			except:
			    checkValue = True
		    else:
			updateValue = True
		else:
		    updateValue = True
		if checkValue:
		    start = line.index("deny")
		    new = line[start:]
		    try:
		        end = new.index(" ")
		        line = line[0:start] + "deny=3" + line[start+end:]
		    except:
		        end = 6
		        line = line[0:start] + "deny=3" + line[start+end:len(line[start:])]
    
		if updateValue:
		    line = line.translate(string.maketrans("\n", " ")).strip()
		    line = line+' deny=3'
		fileString += line + '\n'
	    # Adding the auth and account lines if the lines does not exist.
	    elif systemAuthReq == "" or systemAuthDefault == "" or systemAccReq == "":
		# If the auth line does not exist.
		if systemAuthReq == "":
		    if OsName.lower() == "ubuntu":
                        if re.search('^auth.*pam_unix.so',line):
			    if not tokenMatch('Cloud Raxak updated next line', lastLine):
                                fileString += "# Cloud Raxak updated next line\n"
                            fileString += "auth required pam_tally2.so deny=3 onerr=fail" +"\n"
	            else:
                        if re.search('^auth\s*sufficient\s*pam_unix.so',line):
                            if not tokenMatch('Cloud Raxak updated next line', lastLine):
                                fileString += "# Cloud Raxak updated next line\n"
                            fileString += "auth required pam_faillock.so preauth silent deny=3" +"\n"

		# If the auth default line does not exist.
		if systemAuthDefault == "":
                        if re.search('^auth\s*sufficient\s*pam_unix.so',line):
                            fileString += line + "# Cloud Raxak updated next line\nauth [default=die] pam_faillock.so authfail deny=3" +"\n"
                            continue

		# If the account line does not exist.
		if systemAccReq == "":
		    if OsName.lower() == "ubuntu":
                        checkLine = re.search('^account.*pam_unix.so',line)
		    else:
                        checkLine = re.search('^account\s*required\s*pam_unix.so',line)
		    if checkLine:  
                        if not tokenMatch('Cloud Raxak updated next line', lastLine):
                            fileString += "# Cloud Raxak updated next line\n"
			if OsName.lower() == "ubuntu":
			    fileString += "account required pam_tally2.so" +"\n"
			else:
			    fileString += "account required pam_faillock.so" +"\n"
		fileString += line
	    else:
	        fileString += line
	    lastLine = line
        fout = None
        fout = open(fileName, 'wt')
        if fout != None:
            fout.write(fileString)
            fout.close()

def checkRule38574():
	if OsName.lower() == "ubuntu":
	    filePath = "/etc/pam.d/common-password"
	else:
	    filePath = "/etc/pam.d/system-auth"
	logging("Checking the hashing algorithm for generating account password hashes.")
	if os.path.exists(filePath):
	    res = runOnShell('grep -w password '+ filePath +'  | grep -w pam_unix.so | grep -v "^#"')
	    res = res.translate(string.maketrans("\n\t\r", "   ")).strip()
            match_obj = re.match(r'.*\s*(\bsha512\b)\s*', res)
            if (match_obj):
                logging("Hashes for the new password is using the SHA-512 algorithm.")
                return True
            else:
                logging("Hashes for the new password is not using the SHA-512 algorithm.")
                return False
        logging("Pam module file for password authentication does not exists.")
        return None

def fixRule38574():
	if OsName.lower() == "ubuntu":
	    filePath = "/etc/pam.d/common-password"
	else:
	    filePath = "/etc/pam.d/system-auth"
	if os.path.exists(filePath):
	    res = runOnShell('grep -w password '+ filePath +'  | grep -w pam_unix.so | grep -v "^#"')
	    with open(filePath, "r") as file_content:
		file_string = ""
		match_passwd_module_line = False
		logging("Modifying with the stronger hashing algorithm for generating the account password hashes.")
		for line in file_content:
		    if OsName.lower() == "ubuntu":
		        module_search_obj = re.search('password\s*\[success\=1\sdefault\=ignore\]\s*pam_unix.so',line,re.M|re.I)
		    else:
		    	module_search_obj = re.search('password\s*sufficient\s*pam_unix.so',line,re.M|re.I)
		    if module_search_obj != None and res != "":
		    	if isL(line):
		    	    line = line.translate(string.maketrans("\n\t\r", "   ")).strip()
			    line = line.lower()
		    	    match_obj = re.match(r'.*\s*(\bsha512\b)\s*', res)
			    match_SHA512 = re.match(r'.*\s*(\bSHA512\b)\s*', res) 
			    if match_SHA512:
				start = line.index("sha512")
		        	new = line[start:]
		        	try:
		        	    end = new.index(" ")
		        	    line = line[0:start] + "sha512" + line[start+end:] + "\n"
		        	except:
		        	    end = 6
		        	    line = line[0:start] + "sha512" + line[start+end:len(line[start:])] + "\n"
		    	    else:
				if match_obj == None:
				    line = line.translate(string.maketrans("\n", " ")).strip()
				    line = line+' sha512'
		    	file_string += line + '\n'
		    elif res == "":
			if match_passwd_module_line == False:
				if re.search('^password\s',line,re.M|re.I):
		        	    if OsName.lower() == "ubuntu":
		        		file_string += "password    [success=1 default=ignore] pam_unix.so obscure use_authtok try_first_pass sha512\n"
				    else:
		        		file_string += "password   sufficient  pam_unix.so obscure use_authtok try_first_pass sha512\n"
		    		    match_passwd_module_line = True
	            	file_string += line
		    else:
		        file_string += line
	    fout = None
	    try:
	        fout = open(filePath, "wt")
	        fout.write(file_string)
	    finally:
	        if (fout is not None):
	            fout.close()
	else:
		logging ("Pam module file for password authentication does not exists.")
		return None

def checkRule38575():
    	if not CheckService("auditd"):
		return False
		
	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

        #Checking for keyword never,task.
        logging("Checking if system call auditing is disabled.")
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
            logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
	    return False

    	#Checking for any error in file.
    	if "error" in runOnShell('auditctl -R '+file_path):
		logging("There is an error in "+file_path+", please fix it manually before remediating the rule.")
		return None

	for token in ["rmdir", "unlink", "unlinkat", "rename", "renameat"]:
		if runOnShell("grep -v '^#' "+file_path+" | grep -w '"+ token + "' | grep -w 'auid>=" + uid_value +"'") == "":
			logging("System is not configured to audit user deletions of files and programs for system user.")
			return False 
		if runOnShell("grep -v '^#' "+file_path+" | grep -w '"+ token + "' | grep -w 'auid=0'") == "":
			logging("System is not configured to audit user deletions of files and programs for root user.")
			return False 

	logging("System is configured to audit user deletions of files and programs.")
	return True	

def fixRule38575():
        if not InstallPackage("audit"):
            return None

	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

        #Checking for keyword never,task
        if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
	    logging(" Disabling the system call auditing to audit the events properly.")
	    runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /' "+file_path)

	#Clear previous rules set. 
	runOnShell("auditctl -D")
	#Obtaining the data from file_path	
	audit_handler = open(file_path, "r")
	audit_file_rules = audit_handler.readlines()
	audit_handler.close()
	#Removing redundant entries	from data
	filter_unique_audit_rule_list = []	
	for line in list(set(audit_file_rules)):
		line1 = line.strip('\n')
		if (('-b 320' in line1) or ('-D' in line1) or ('#' in line1)):
			continue
		final_line = re.sub("\s\s+" , " ", line1)
		filter_unique_audit_rule_list.append(final_line.strip())
		
	startup_line = "# This file contains the auditctl rules that are loaded\n # whenever the audit daemon is started via the initscripts.\n # The rules are simply the parameters that would be passed\n# to auditctl.\n # First rule - delete all\n-D\n\n # Increase the buffers to survive stress events.\n # Make this bigger for busy systems\n -b 320\n"
	
	with open(file_path, "w") as fhandler:
		res = runOnShell("uname -m")
		if "64" in res:
			arch_variable = "arch=b64" 
		else:
			arch_variable = "arch=b32" 
		fhandler.write(startup_line)
		rule_1 = "-a always,exit -F " + arch_variable + " -S rmdir -S unlink -S unlinkat -S rename -S renameat -F auid>="+uid_value+" -F auid!=4294967295 -k delete"
		rule_2 = "-a always,exit -F "+ arch_variable + " -S rmdir -S unlink -S unlinkat -S rename -S renameat -F auid=0 -k delete"
		unique_data = '\n'.join(filter_unique_audit_rule_list)
		fhandler.write(unique_data)
		for rule in [rule_1,rule_2]:
			if rule not in filter_unique_audit_rule_list:
				fhandler.write("\n"+rule+"\n")
			
	logging("Configuring the system to audit user deletions of files and programs.")
	fhandler.close() 
	runOnShell("auditctl -R "+file_path)
    	RunService("auditd")

def checkRule38576():
	logging("Checking if the system is using SHA-512 as the hashing algorithm.")
        result = runOnShell('grep "ENCRYPT_METHOD SHA512" /etc/login.defs | grep -v "^#"')
        if result == "":
	    logging("The system is not using SHA-512 as the hashing algorithm.")
            return False

        result1=result.translate(string.maketrans("\n\t\r", "   "))
        ret = tokenMatchIC('ENCRYPT_METHOD SHA512',result1)
        if ret:
	    logging("The system is using SHA-512 as the hashing algorithm.")
            return True
	logging("The system is not using SHA-512 as the hashing algorithm.")
        return False

def fixRule38576():
    with open("/etc/login.defs", "r") as f:
        flag = False
        s = ""
        lastLine = ""
	logging("Updating the system hashing algorithm.")
        for line in f:
            if "ENCRYPT_METHOD" in line and isL(line):
                if not tokenMatch('Cloud Raxak updated next line',lastLine):
                    s += "# Cloud Raxak updated next line\n"
                s += "ENCRYPT_METHOD SHA512\n"
                flag = True
            else:
                s += line
		lastLine = line
        if not(flag):
	    logging("Adding the system hashing algorithm.")
            s += "# Cloud Raxak updated next line\n"
            s += "ENCRYPT_METHOD SHA512\n"
	
        fout = None
        try:
            fout = open("/etc/login.defs", 'wt')
            fout.write(s)
        finally:
            if fout is not None:
                fout.close()

def checkRule38577():
	if OsName.lower() == "ubuntu" and OsVersion == (14,10):
		logging("The /etc/libuser.conf is not included in the .deb package in the current version of UBUNTU 14.10, so the rule is not applicable.")
		return 3
	else:
	    logging("Checking if SHA-512 algorithm is used for password hashing.")
	    res = runOnShell('grep -w crypt_style /etc/libuser.conf | grep -v "^#"')
	    #If libuser.conf file does not exists 
	    if tokenMatchIC("No such file",res):
		if OsName.lower() == "ubuntu":
		    logging("libuser configuration does not exist, so need to install libuser1 package.")
		else:
		    logging("libuser configuration does not exist, so need to install libuser package.")
		return False
	    res_split = res.split("\n")
	    flag = False
	    with open("/etc/libuser.conf", "r") as file_content:
		for line in file_content:
			match_obj = re.match(r'.*(\[.*\])',line)
			if match_obj != None:
				if tokenMatchIC("[defaults]", match_obj.group(1)):
					flag = True			
				else:
					flag = False
			if flag:
				if "crypt_style" in line and isL(line):
					res_split = res.split("\n")
					for element in res_split:
					    if keyValEqMatch("crypt_style", 'sha512', element):
						logging("The system is using the SHA-512 algorithm for password hashing.")
						return True
	logging("The system is not using the SHA-512 algorithm for password hashing under the 'defaults' settings.")
	return False
		
def fixRule38577():
    if OsName.lower() == "ubuntu" and OsVersion == (14,10):
    	logging("The /etc/libuser.conf is not included in the .deb package in the current version of UBUNTU 14.10, so the rule is not applicable.")
    	return 3
    else:
        if OsName.lower() == "ubuntu":
    	    pkgName = "libuser1"
        else:	
    	    pkgName = "libuser"
    
    if not CheckPackage(pkgName):
        if not InstallPackage(pkgName):
    	    return None

    res = runOnShell('grep -w crypt_style /etc/libuser.conf | grep -v "^#"')
    if os.path.exists("/etc/libuser.conf"):
            flag = False
            flag_match = False
            with open("/etc/libuser.conf", "r") as file_content:
        	for line in file_content:
        		match_obj = re.match(r'.*(\[.*\])',line)
        		if match_obj != None:
        			if tokenMatchIC("[defaults]", match_obj.group(1)):
        				flag = True			
        			else:
        				flag = False
        		if flag:
        			if "crypt_style" in line and isL(line):
        			    res_split = res.translate(string.maketrans("\n\t\r", "   "))
        			    if tokenMatchIC("crypt_style",res_split):
        				flag_match = True
            with open("/etc/libuser.conf", "r") as file_content:
                    file_string = ""
        	    match_passwd_module_line = False
                    for line in file_content:
        	        #If pattern exist with wrong value.
        		if flag_match and isL(line) and "crypt_style" in line:
        		    line = line.translate(string.maketrans("\n\t\r", "   ")).strip()
        	            serach_obj = re.search(r'crypt_style =\d*',line)
        		    if serach_obj:
        			logging("Updating the password hashing algorithm to 'sha512'.")
        	                match_pattern = serach_obj.group()
        		        start = line.index("crypt_style =")
        	                new = line[start:]
        	                try:
        			    end = new.index(" ")
        			    file_string += line[0:start] + "crypt_style = sha512\n"
        		        except:
        			    end = 18
        			    file_string += line[0:start] + "crypt_style = sha512" + line[start+end:len(line[start:])] + "\n"
        			match_passwd_module_line= True
        		elif flag_match == False :
        		    if match_passwd_module_line == False:
        			if "crypt_style" in line:
        			    continue	
        			elif re.search('^\[defaults\]\s',line,re.M|re.I):
        			    logging("Adding the password hashing algorithm to sha512.")
        			    file_string += line +"crypt_style = sha512\n"
        			    continue
        		    file_string += line
        		else:
        		    file_string += line
        	    fout = None
                    try:
                        fout = open("/etc/libuser.conf", "wt")
                        fout.write(file_string)
                    finally:
                        if (fout is not None):
                            fout.close()

def checkRule38578():
    	if not CheckService("auditd"):
		return False

	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Checking for keyword never,task.
    	logging("Checking if system call auditing is disabled.")
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
        	return False

    	#Checking for any error in file.
    	if "error" in runOnShell('auditctl -R '+file_path):
		logging("There is an error in "+file_path+", please fix it manually before remediating the rule.")
		return None

	res = ""
	if OsVersion == '2015.03':	
		res = runOnShell('auditctl -l | grep "watch=/etc/sudoers"')
	else:
		res = runOnShell('auditctl -l | grep "/etc/sudoers" ')
	if res == "":
		logging("System is not configured to audit changes to the /etc/sudoers file.")
		return False

	logging("System is configured to audit changes to the /etc/sudoers file.")
	return True


def fixRule38578():
        if not InstallPackage("audit"):
            return None

	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Removing for keyword never,task
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging(" Disabling the system call auditing to audit the events properly.")
        	runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /' "+file_path)

	#Clear previous rules set. 
	runOnShell("auditctl -D")
	#Obtaining the data from file_path	
	audit_handler = open(file_path, "r")
	audit_file_rules = audit_handler.readlines()
	audit_handler.close()
	#Removing redundant entries from data
	filter_unique_audit_rule_list = []	
	for line in list(set(audit_file_rules)):
		line1 = line.strip('\n')
		if (('-b 320' in line1) or ('-D' in line1) or ('#' in line1)):
			continue
		final_line = re.sub("\s+" , " ", line1)
		filter_unique_audit_rule_list.append(final_line.strip())

		
	startup_line = "# This file contains the auditctl rules that are loaded\n # whenever the audit daemon is started via the initscripts.\n # The rules are simply the parameters that would be passed\n# to auditctl.\n # First rule - delete all\n-D\n\n # Increase the buffers to survive stress events.\n # Make this bigger for busy systems\n -b 320\n"
	
	with open(file_path, "w") as fhandler:
		rule = "-w /etc/sudoers -p wa -k actions"
		fhandler.write(startup_line)
		unique_data = '\n'.join(filter_unique_audit_rule_list)
		fhandler.write(unique_data)
		if rule not in filter_unique_audit_rule_list:
			logging("Configuring the system to audit changes to the /etc/sudoers file.")
			fhandler.write('\n#Cloud Raxak updated next line #action\n')
			fhandler.write("\n"+rule+"\n")

	fhandler.close()
	runOnShell("auditctl -R "+file_path)
    	RunService("auditd")

def checkRule38579():
	if OsName.lower() == "ubuntu":
		file_path = '/etc/default/grub'
	elif OsVersion >= (7,0):
		file_path = '/boot/grub2/grub.cfg'
	else:
		file_path = '/etc/grub.conf'
	if os.path.exists(file_path):
		logging("Checking the ownership of boot loader configuration file.")
		check_owner = runOnShell("ls -lL " + file_path)
        	if strcmp(check_owner.split(" ")[2], "root"):
			logging("The system boot loader configuration file is owned by root.")
			return True
		else:
			logging("The system boot loader configuration file is not owned by root.")
			return False
	logging("The system boot loader configuration file does not exist.")
	return True

def fixRule38579():
	if OsName.lower() == "ubuntu":
		file_path = '/etc/default/grub'
	elif OsVersion >= (7,0):
		file_path = '/boot/grub2/grub.cfg'
	else:
		file_path = '/etc/grub.conf'
	logging("Changing the owner of file the system boot loader configuration file.")
        runOnShell('chown root ' + file_path)

def checkRule38580():
    	if not CheckService("auditd"):
		return False

	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Checking for keyword never,task.
    	logging("Checking if system call auditing is disabled.")
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
        	return False

    	#Checking for any error in file.
    	if "error" in runOnShell('auditctl -R '+file_path):
		logging("There is an error in "+file_path+", please fix it manually before remediating the rule.")
		return None

	res1 = runOnShell("egrep -e '(-w |-F path=)/sbin/insmod' " + file_path + " | grep -v '^#'") 
	res2 = runOnShell("egrep -e '(-w |-F path=)/sbin/rmmod' " + file_path + " | grep -v '^#'")
	res3 = runOnShell("egrep -e '(-w |-F path=)/sbin/modprobe' " + file_path + "| grep -v '^#'")
	del_module_match = runOnShell("grep -w 'delete_module' "+file_path + " | grep -v '^#'")
	init_module_match = runOnShell("grep -w 'init_module' "+file_path + " | grep -v '^#'")
	if (res1 == "" or res2 == "" or res3 == "" or del_module_match == "" or init_module_match == ""):
		logging("System is not configured to audit the loading and unloading of dynamic kernel modules.")
		return False

	logging("System is configured to audit the loading and unloading of dynamic kernel modules.")
	return True


def fixRule38580():
        if not InstallPackage("audit"):
            return None

	file_path = '/etc/audit/audit.rules'
    	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    		file_path = '/etc/audit/rules.d/audit.rules'

    	#Removing for keyword never,task
    	if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        	logging(" Disabling the system call auditing to audit the events properly.")
        	runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /' "+file_path)

	rule_list = []
	if runOnShell("egrep -e '(-w |-F path=)/sbin/insmod' " + file_path + " | grep -v '^#'") == "":
		rule_list.append("-w /sbin/insmod -p x -k modules") 
	if runOnShell("egrep -e '(-w |-F path=)/sbin/rmmod' " + file_path + " | grep -v '^#'") == "":
		rule_list.append("-w /sbin/rmmod -p x -k modules") 
	if runOnShell("egrep -e '(-w |-F path=)/sbin/modprobe' " + file_path+ " | grep -v '^#'") == "":
		rule_list.append("-w /sbin/modprobe -p x -k modules") 
		
	if "64" in  runOnShell("uname -m"):
		arch = "b64"
	else:
		arch = "b32"
		
	for module in ["delete_module","init_module" ]:
		if runOnShell("grep -w "+ module+" "+file_path + " | grep -v '^#'") == "":
			rule_list.append("-a always,exit -F arch=%s -S init_module -S delete_module -k modules " % arch) 
			break
	with open(file_path, "a") as f:
		logging("Configuring the system to audit the loading and unloading of dynamic kernel modules.")
		result = "\n".join(rule_list)
		f.write(result)
    
	runOnShell('auditctl -R '+file_path)
    	RunService("auditd")

def checkRule38581():
        if OsName.lower() == "ubuntu":
	    grubfilePath = "/etc/default/grub"
        elif OsVersion >= (7,0):
            grubfilePath =  "/etc/grub2.cfg"
        else:
	    grubfilePath = "/etc/grub.conf"

        if not os.path.exists(grubfilePath):
            logging("The boot loader configuration file does not exist.")
            return True

	logging("Checking the group ownership of boot loader configuration file.")
        groupOwner = runOnShell("ls -lL " + grubfilePath)
        if strcmp(groupOwner.split(" ")[3], "root"):
	    logging("The system boot loader configuration file is group owned by root.")
	    return True
        logging("The system boot loader configuration file is not group owned by root.")
	return False

def fixRule38581():
        logging("Changing the group owner of system boot loader configuration file.")
	if OsName.lower() == "ubuntu":
            runOnShell("chgrp root /etc/default/grub")
        elif OsVersion >= (7,0):
            runOnShell('chgrp root /etc/grub2.cfg')
        else:
            runOnShell('chgrp root /etc/grub.conf')

def checkRule38582():
	logging("Checking the installation of xinetd service.")
	if not os.path.exists('/usr/sbin/xinetd'):
		logging("The extended Internet services daemon (xinetd) service is not installed.")
		return True

	#Checking the listening port at all protcols
	if OsVersion >= (7,0):
	    xinetd_listening_port = runOnShell('ss -taupln | grep -w xinetd')
	else:
	    xinetd_listening_port = runOnShell('netstat -atunlp | grep -w xinetd')
	if xinetd_listening_port != "":
	    logging("Network service(s) is using the extended Internet services daemon (xinetd), hence can not disable the xinetd service.")
	    return True

	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		service_status = runOnShell('systemctl is-active xinetd.service').replace('\n','')
		if service_status in ["inactive", "unknown","failed"]:
			return True
		service_at_runlevel = runOnShell("systemctl is-enabled xinetd.service").replace('\n','')
		if service_status == "active" or service_at_runlevel == "enabled":
			logging("xinted service is running.")
			return False

	else:   
		if OsName.lower() == "ubuntu":
			service_at_level = 'sysv-rc-conf --list xinetd'
			token_match = "stop/waiting"
		else:
			service_at_level = 'chkconfig --list xinetd'
			token_match = "stopped"
		
		logging("Checking the status of extended Internet services daemon (xinetd).")
		service_status = runOnShell('service xinetd status').translate(string.maketrans("\n\t\r", "   "))
		if "unrecognized service" not in service_status:
			if "Unknown job" in service_status:
				logging("xinetd configuration error.Need to correct it manually.")
				return None  
			if not tokenMatchIC(token_match, service_status):
				logging("The extended Internet services daemon (xinetd) service is running.")
				return False

			logging("Checking the status of extended Internet services daemon (xinetd) at runlevel.")
			service_at_level = runOnShell(service_at_level)
			service_at_level = service_at_level.translate(string.maketrans("\n\t\r", "   "))
			if OsName.lower() == "ubuntu":
				service_at_level_repl = service_at_level.replace(" ",'')
				if len(service_at_level_repl) == len("xinetd") and tokenMatchIC("xinetd",service_at_level):
				 	outputList = runOnShell("initctl show-config xinetd").split('\n')
					for line in outputList:
						start_obj = re.match(r'\s*start\s*on\s*runlevel\s*\[(\d+)\]', line)
						stop_obj = re.match(r'\s*stop\s*on\s*runlevel\s*\[(\d+)\]', line)
						if start_obj is not None:
							if any(runlevel in ['1','2','3','4','5','6','S'] for runlevel in start_obj.group(1)):
								logging("The extended Internet services daemon (xinetd) is on at runlevel.")
								return False
						if stop_obj is not None:
							if all(int(runlevel) in [2,3,4,5] for runlevel in stop_obj.group(1)):
								logging("The extended Internet services daemon (xinetd) is off at runlevel.")
								return True
					logging("The extended Internet services daemon (xinetd) configuration file has not corrected runlevel.")
					return False

				if "on" in service_at_level_repl:
					logging("The extended Internet services daemon (xinetd) is on at runlevel.")
					return False
			else:
				if not(tokenMatchIC("xinetd 0:off 1:off 2:off 3:off 4:off 5:off 6:off", service_at_level)):
					logging("The extended Internet services daemon (xinetd) is not off at runlevel.")
					return False

	logging("The extended Internet services daemon (xinetd) is disabled.")
	return True

def fixRule38582():
	if (( OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat' )):
		runOnShell("systemctl disable xinetd.service ; systemctl stop xinetd.service")
	else:
		logging("Disabling the extended Internet services daemon (xinetd) at all runlevel and in current session.")
		if OsName.lower() == "ubuntu":
			service_status = runOnShell('service xinetd status')
			service_status = service_status.translate(string.maketrans("\n\t\r", "   "))
			if "stop" not in service_status:
				runOnShell('service xinetd stop')
			service_at_level = runOnShell("sysv-rc-conf --list xinetd")
			service_at_level = service_at_level.translate(string.maketrans("\n\t\r", "   "))
			service_at_level_repl = service_at_level.replace(" ",'')
			if len(service_at_level_repl) == len("xinetd") and tokenMatchIC("xinetd",service_at_level):
				fileSplit = open("/etc/init/xinetd.conf").readlines()
				concat_line = ""
				lastLine = ""
				stop_flag = False
				for line in fileSplit:
					start_obj = re.match(r'\s*start\s*on\s*runlevel\s*\[(\d+)\]', line)
					stop_obj = re.match(r'\s*stop\s*on\s*runlevel\s*\[!(\d+)\]', line)
					if start_obj is not None:
				    		if not tokenMatch("# Cloud Raxak updated next line",lastLine):
				    			concat_line += "# Cloud Raxak updated next line\n"
						#Commenting the start runlevel line if exists. 
						concat_line += "# "+line
						continue
					if stop_obj is not None:
						#Modifying the stop runlevel line. 
			    	    		logging("Configuring the file to set the service off at runlevel.")
				    		if not tokenMatch("# Cloud Raxak updated next line",lastLine):
				    			concat_line += "# Cloud Raxak updated next line\n"
						concat_line += "stop on runlevel [2345] \n"
						stop_flag = True
						continue

				        concat_line += line
				        lastLine = line
				if not(stop_flag):
			    	    logging("Configuring the file to set the service off at runlevel.")
				    if not tokenMatch("# Cloud Raxak updated next line",lastLine):
				    	concat_line += "# Cloud Raxak updated next line\n"
				    concat_line += "stop on runlevel [2345] \n"
				fout = open("/etc/init/xinetd.conf", 'w')
				if fout != None:
				    fout.write(concat_line)
				    fout.close()
				
			else:
				runOnShell('sysv-rc-conf --level 0123456S xinetd off')
		else:
			service_status = runOnShell('service xinetd status')
			service_status = service_status.translate(string.maketrans("\n\t\r", "   "))
			if "stopped" not in service_status:
				runOnShell('service xinetd stop')
			runOnShell('chkconfig --level 0123456 xinetd off')

def checkRule38583():
        logging("Checking the permission of Grub boot loader configuration file.")
        if OsName.lower() == "ubuntu":
            filePath = "/etc/default/grub"
        elif (OsName.lower() == "redhat" or OsName.lower() == "centos") and OsVersion >= (7,0):
            filePath = "/etc/grub2.cfg"
        else:
            filePath = "/etc/grub.conf"

        if not os.path.exists(filePath):
            logging ("The boot loader configuration file does not exist.")
            return True

        #Converting string type octal to decimal.
        tmpOct = int(runOnShell ('stat -L -c "%a" '+ filePath), 8)
	# 07177 is an octal number which binary ands with tmpOct, it's result is used to decide if permissions are set correctly or not.
        # why 7177? Because when 7177 converted to binary gives 111 001 111 111
        # Linux file permissions                                ugs   x rwx rwx     u=set uid , g=set gid, s=set sticky bit
        # permsissions above are the ones which we don't want the owner,group and others to have.
        if tmpOct & 07177:
            logging("Permission for file "+ filePath +" is not configured correctly.")
            return False

        logging("Permission for file "+ filePath +" is configured correctly.")
        return True

def fixRule38583():
	logging("Changing the permission of Grub boot loader configuration file.")
        if OsName.lower() == "ubuntu":
            runOnShell("chmod 600 /etc/default/grub")
        elif (OsName.lower() == "redhat" or OsName.lower() == "centos") and OsVersion >= (7,0):
            runOnShell('chmod 600 /boot/grub2/grub.cfg')
        else:
            runOnShell('chmod 600 /boot/grub/grub.conf')

def checkRule38584():
	if not CheckPackage("xinetd"):
	    return True
	#Checking the listening port at all protcols
	if OsVersion >= (7,0):
	    xinetd_listening_port = runOnShell('ss -taupln | grep "xinetd"')
	else:
	    xinetd_listening_port = runOnShell('netstat -atunlp | grep "xinetd"')
	if xinetd_listening_port != "":
	    logging("Network service(s) is using the 'xinetd' service, hence can not remove the 'xinetd' service.")
	    return True
	logging("No Network service(s) is using the 'xinetd' service but service is installed, need to remove the package.")
	return False

def fixRule38584():
	logging("Uninstalling the 'xinetd' package.")
	if OsName.lower() == "ubuntu":
		runOnShell('dpkg -r --force-all xinetd')
	else:
		runOnShell('rpm -e xinetd --nodeps')


def checkRule38585():
	if OsName.lower() == "ubuntu":
		file_name = "/boot/grub/grub.cfg"
	elif (OsName.lower() == "centos" or OsName.lower() == "redhat") and (OsVersion >= (7,0)):
		file_name = "/etc/grub2.cfg"
	else:
		file_name = "/etc/grub.conf"

	if not os.path.exists(file_name):
		logging ("The grub file does not exist, hence fix it manually.")
		return None

	if OsName.lower() == "ubuntu" or "grub2" in file_name:
                logging ("Checking boot loader authentication.")
		user_value = runOnShell('grep "set superuser" ' + file_name + '| grep -v "^#"')
		if not user_value:
			logging("The system boot loader does not have authentication. So please fix it manually.")
			return None
		else:
			pass_value_usercfg = ""
			user_name = re.findall(r'"([^"]*)"', user_value)
			if(OsName.lower() == "centos" or OsName.lower() == "redhat") and (OsVersion >= (7,0)):
				#Checking the hash password in "/boot/grub2" directory.
				logging ("Checking the grub protection hash password based on default script file existance.")
				pass_value_usercfg = runOnShell('sudo grep -r "\s*GRUB2_PASSWORD=grub.pbkdf2.sha512" /boot/grub2')

			logging ("Checking the grub protection hash password in grub configuration file.")
			for superuser_name in user_name:
				# Checking the hash password in grubfile based on setsuper.
				pass_value = runOnShell('grep "password_pbkdf2 \s*'+ superuser_name +'\s* grub.pbkdf2.sha512" ' + file_name +' | grep -v "^#"')
			if pass_value_usercfg or pass_value:
				logging("The system boot loader is correctly authenticated.")
				return True
			else:
				logging("The system boot loader does not have authentication. So please fix it manually.")
				return None
	else:
		open_system = open(file_name,"r")
		check_passwd_flag = False
		title_flag = False
		filtered_list = filter (lambda ele: not ele.isspace(), open_system.readlines())
                # Checking the paasword configuration in grub file.
		for grubElement in filtered_list:
			# Supporting sha256, sha512, md5 password encrypted algorithms.
			# Ex: sha256 --> "$6$....."
			# sha512 -->  "$5$......."
			# md5 -->  "$1$......."
			if (re.search(r'password\s*--encrypted\s*[$][156][$]\w', grubElement)) or (re.search(r'password\s*--md5\s*[$][1][$]\w', grubElement)):
				check_passwd_flag = True
				password_line_index = filtered_list.index(grubElement)
			if re.search(r'^title\s', grubElement):
				title_flag = True
				title_line_index =  filtered_list.index(grubElement)

		if not title_flag:
			logging ("The kernel title line is missing in grub file, please check it manually.")
			return None

		if check_passwd_flag:
			if password_line_index > title_line_index:
				logging ("The position of the system boot loader is not configured correctly, so need to fix the rule manually.")
				return None
			else:
				logging ("The system boot loader is correctly authenticated.")
				return True
	logging ("The system boot loader does not have authentication. So please fix it manually.")
	return None

def fixRule38585():
        # TODO : It should be handled manually : how to enter password?
	if(OsName.lower() == "centos") and (OsVersion >= (7,0)):
		logging("Since password can't be set during run time after issuing the command 'grub2-mkpasswd-pbkdf2', so can't fix this \
rule. Hence, we need to manually fix this rule.")
		return None
	logging ("Since password can't be set during run time after issuing the command 'grub-crypt --sha-512', so can't fix this rule.\
 Hence, we need to manually fix this rule.")
	return None

def checkRule69():
        res = runOnShell("grep SINGLE /etc/sysconfig/init | grep -v '#' ")
        return strcmp(res, "SINGLE=/sbin/sulogin")

def checkRule38586():
	if OsName.lower() == "ubuntu":
		logging ("Checking if a password is set for the root user.")
		root_password = runOnShell("grep ^root:[*!]: /etc/shadow")
		if root_password:
			logging ("Requiring authentication in single user mode prevents an unauthorized user from \
rebooting the system into single user mode. The root account is disabled, then root can able to login single user mode without authentication. So please set the password to root account to prevent the unathentication login of single user mode.")
			return None

		logging("Checking if authentication is required for single-user mode.")
		res_console = runOnShell("grep -w console /etc/init/rcS.conf | grep -v '^#'")
		res_login = runOnShell("grep -w /sbin/sulogin  /etc/init/rcS.conf | grep -v '^#'")
                res_console = ' '.join(res_console.split())
		if tokenMatch("owner", res_console) and (res_login != ""):
			res_login1 = res_login.split()
			flag = False
			for res_string in res_login1:
				if tokenMatch('exec', res_string):
					flag = True
				if flag and tokenMatch('/sbin/sulogin', res_string):
					logging("The system authentication is set for single-user mode.")
					return True
		logging("The system authentication is not set for single-user mode.")
		return False
	else:
		if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
			logging ("Single-user mode is intended as a system recovery method, providing a single user root access \
to the system by providing a boot option at startup. By default authentication is performed if single-user mode is selected, \
so this rule in not apllicable for this OS.")
			return True
		if not os.path.exists("/etc/sysconfig/init"):
			logging('The file path "/etc/sysconfig/init" does not exist. Hence fix it manually.')
			return None
		logging("Checking if authentication is required for single-user mode.")
		res = runOnShell("grep -w SINGLE=/sbin/sulogin /etc/sysconfig/init | grep -v '^#'")
		if res != "":
			logging("The system authentication is set for single-user mode.")
			return True
		else:
			logging("The system authentication is not set for single-user mode.")
			return False

def fixRule38586():
	token_match_console_line = "console owner\n"
	token_match_console = "console"
	if OsName.lower() == "ubuntu":
		file_path = "/etc/init/rcS.conf"
		token_match = "exec"
		authenticated_value = "exec /sbin/sulogin\n"
	else:
		file_path = "/etc/sysconfig/init"
		token_match = "SINGLE"
		authenticated_value = "SINGLE=/sbin/sulogin\n"

	with open(file_path) as initFile:
		suloginLine = ""
		lastLine = ""
		not_any_single_key = True
		not_any_console_key = True
		for line in initFile:
			if ((token_match_console in line) and (isL(line)) and (OsName.lower() == "ubuntu")):
				if not tokenMatch('Cloud Raxak updated next line', lastLine):
					suloginLine += "# Cloud Raxak updated next line\n"
				suloginLine += token_match_console_line
				not_any_console_key = False
			elif token_match in line and isL(line):
				if not tokenMatch('Cloud Raxak updated next line', lastLine):
					suloginLine += "# Cloud Raxak updated next line\n"
				logging("Updating the system authentication for single-user mode.")
				suloginLine += authenticated_value
				not_any_single_key = False
			else:
				suloginLine += line
				lastLine = line
		if ((not_any_console_key) and (OsName.lower() == "ubuntu")):
			if not tokenMatch('Cloud Raxak updated next line', lastLine):
				suloginLine += "# Cloud Raxak updated next line\n"
			suloginLine += token_match_console_line
		if not_any_single_key:
			if not tokenMatch('Cloud Raxak updated next line', lastLine):
				suloginLine += "# Cloud Raxak updated next line\n"
			logging("Configuring the system authentication for single-user mode.")
			suloginLine += authenticated_value

	fout = open(file_path, "wt")
	if fout != None:
		fout.write(suloginLine)
		fout.close()


def checkRule38587():
	if OsName.lower() == "ubuntu":
		logging("Checking whether 'telnetd' package is installed on system.")
		res = runOnShell('dpkg -s telnetd')
	else:
		logging("Checking whether 'telnet-server' package is installed on system.")
		res = runOnShell('rpm -q telnet-server')
	if ("not installed" in res) or ("deinstall ok" in res):
		return True
	logging("'telnet-server' package is installed on system. Please remove the 'telnet-server' package.")
	return False

def fixRule38587():
	if OsName.lower() == "ubuntu":
		logging("Removing 'telnetd' package.")
		runOnShell('dpkg -r --force-all telnetd')
	else:
		logging("Removing 'telnet-server' package.")
		runOnShell('rpm -e telnet-server --nodeps')


def checkRule38588():
	if OsName.lower() == "ubuntu":
		logging("Interactive boot does not exist in Ubuntu, hence this rule is not applicable.")
		return 3

	if not os.path.exists('/etc/sysconfig/init'):
		logging("The system init file was not found. Please fix this manually.")
		return None

	logging("Checking if ability for users to perform interactive boot is disabled.")
	res = runOnShell('grep -w PROMPT /etc/sysconfig/init | grep -v "^#"')
	if not res:
		logging("Configuration for disabling interactive boot was not found.")
		return False
	res = res.strip()
        if res == "PROMPT=no":
		logging("The ability for users to perform interactive boot is disabled.")
		return True
	logging("The ability for users to perform interactive boot is not disabled.")
	return False

def fixRule38588():
	if OsName.lower() == "ubuntu":
		logging("Interactive boot does not exist in Ubuntu, hence this rule is not applicable.")
		return 3

	if not os.path.exists('/etc/sysconfig/init'):
		logging("The system init file was not found. Please fix this manually.")
		return None

	flag_prompt = False
	prompt = ""
        lastLine = ""
        with open('/etc/sysconfig/init') as file_data:
		for line in file_data:
			if isL(line) and "PROMPT" in line:
				if not flag_prompt:
					logging("Updating configuration for disabling interactive boot.")
					if not tokenMatch('Cloud Raxak updated next line', lastLine):
						prompt += "# Cloud Raxak updated next line\n"
					prompt += "PROMPT=no\n"
					flag_prompt = True
			else:
				lastLine = line
				prompt += line
	if not flag_prompt:
		logging("Adding configuration for disabling interactive boot.")
		if not tokenMatch('Cloud Raxak updated next line', lastLine):
			prompt += "# Cloud Raxak updated next line\n"
		prompt += "PROMPT=no\n"
	writeFile('/etc/sysconfig/init', prompt, "wt")

def checkRule38589():
    # checking telnet package is installed.
    logging("Checking if telnet package is installed.")
    if not os.path.exists('/usr/sbin/in.telnetd'):
        logging("telnet package is not installed.")
        return True

    if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
        res = runOnShell("systemctl is-active telnet.socket").replace('\n','')
        if re.match(r'.*\s*(\bactive\b)\s*', res):
            logging("Telnet server is running.")
            return False
        #checking whether telnet is on at run level.
        telnet_runlevel = runOnShell("systemctl is-enabled telnet.socket").translate(string.maketrans("\n\t\r", "   ")).replace(" ",'')
        if "disable" in telnet_runlevel:
            logging("Telnet daemon is disable in system boot configuration.")
            return True
        logging("Telnet daemon is enable in system boot configuration.")
        return False
    elif OsName.lower() == "ubuntu":
        telnetConfFlag = True
        #checking xinetd package is installed.
        logging("Checking if xinetd package is installed.")
        if os.path.exists('/usr/sbin/xinetd'):
            telnetPort = runOnShell("sudo grep -w ^telnet /etc/services | cut -f3 |grep -v '^#'")
            if not telnetPort:
                logging("Default port for telnet is not defined. Hence, telnet is not working.")
                return True
            telnetPort = telnetPort.split("/")
            logging("Checking telnet is configured through xinetd.")
            telnetConfigFile = runOnShell("sudo grep /usr/sbin/in.telnetd /etc/xinetd.d/*")
            if telnetConfigFile or os.path.exists('/etc/inetd.conf'):
                telnetConfFlag = False

            #checking default port 23 is running or not.
            if not telnetConfFlag:
                telnetRunStatus = runOnShell('netstat -plnt | grep :'+ str(telnetPort[0]))
                if telnetRunStatus != "":
                    logging("Telnet service is running through xinetd.")
                    return False
                else:
                    logging("Telnet server is not configured. Hence, telnet is not running.")
                    return True
            
        #checking inetd package is install.
        else:
            logging('Since xinetd package is not installed hence checking whether telnet service is configured using inetd.')
            if os.path.exists('/usr/sbin/inetd'):
                if os.path.exists('/etc/inetd.conf'):
                    match_telnetd = runOnShell('grep "in.telnetd" /etc/inetd.conf | grep -v "#"')
                    if match_telnetd != "" and os.path.exists('/usr/sbin/in.telnetd'):
                        logging("Telnet service is running through inetd.")
                        return False
            else:
                logging("inetd service is not installed.")

        logging("Telnet daemon is not running.")
        return True
    else:
        logging("Checking the status of telnet service in system boot configuration.")
        res = runOnShell("chkconfig --list telnet")
        res_trans = res.translate(string.maketrans("\n\t\r", "   "))
        res_replace = res_trans.replace(" ",'')
        if "off" in res_replace:
            logging("telnet daemon is off in system boot configuration.")
            return True
        logging("telnet daemon is on in system boot configuration.")
        return False

def fixRule38589():
    if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat' )):
        runOnShell("systemctl disable telnet.socket ; systemctl stop telnet.socket")
    elif OsName.lower() == "ubuntu":
        lastLine = ""
        #telnetd is install using xinetd
        if os.path.exists('/usr/sbin/xinetd'):
            telnetConfigFile = runOnShell("sudo grep -w /usr/sbin/in.telnetd /etc/xinetd.d/*")
            for fileNameList in telnetConfigFile.splitlines():
                fileName = fileNameList.split(":")[0]
                if os.path.exists(fileName):
                    newline = ""
                    list_of_lines = open(fileName).readlines()
                    for line in list_of_lines:
                       fileContentLine = line.translate(string.maketrans("\n\t\r", "   "))
                       if isL(fileContentLine) and tokenMatchIC("disable", fileContentLine):
                           continue
                       #Parameter is missing throughout the file.
                       elif isL(fileContentLine) and tokenMatchIC("}", fileContentLine):
                           if "Cloud Raxak updated next line" not in lastLine:
                               newline += "# Cloud Raxak updated next line\n"
                           newline += "disable = yes\n"
                       newline += line
                       lastLine = line
                    fout = open(fileName, 'w')
                    if fout != None:
                        fout.write(newline)
                        fout.close()

            #kill the ps id for xinetd.
            telnetPort = runOnShell("sudo grep -w ^telnet /etc/services | cut -f3 |grep -v '^#'")
            telnetPort = telnetPort.split("/")
            psId = runOnShell("netstat -plnt | grep :"+ str(telnetPort[0]))
            for psIDList in psId.split():
                if "xinetd" in psIDList:
                    processID = psIDList.split("/")
                    runOnShell("kill -9 " + processID[0] + " 2>/dev/null")

        #telnetd is install using inetd.
        #In case of xinetd if /etc/inetd.conf file exist and telnet is configured in the file 
        #then the service will start running when xinetd network is restarted even though inetd is not install.
        if os.path.exists('/etc/inetd.conf'):
            newline = ""
            list_of_lines = open("/etc/inetd.conf").readlines()
            for line in list_of_lines:
                if isL(line) and tokenMatch("telnetd", line):
                    if "Cloud Raxak updated next line" not in lastLine:
                        newline += "# Cloud Raxak updated next line\n"
                    newline += "#" + line
                else:
                    newline += line
                lastLine = line
            fout = open("/etc/inetd.conf", 'w')
            if fout != None:
                fout.write(newline)
                fout.close()

        #restart the network service to apply the chnages.
        if os.path.exists('/usr/sbin/inetd'):
            runOnShell("service openbsd-inetd restart")
        else:
            runOnShell("service xinetd restart")
            runOnShell("/etc/init.d/xinetd restart")
    else:
        runOnShell("chkconfig telnet off")

def checkRule38590():
	logging("Checking whether 'screen' package is installed on system.")
	if OsName.lower() == "ubuntu":
	   res = runOnShell("dpkg -s screen")
	   if ("not installed" in res) or ("deinstall ok" in res):
	       logging("'screen' package is not installed on system. Please install the 'screen' package.")
	       return False
	   logging("'screen' package is installed on system.")
	   return True
	else:
           res = runOnShell("rpm -q screen")
           #return not(tokenMatchIC("not installed", res))
	   if res.find('package screen is not installed') == 0:
	      logging("'screen' package is not installed on system. Please install the 'screen' package.")
	      return False
	   logging("'screen' package is installed on system.")
	   return True

def fixRule38590():
	logging("Installing 'screen' package.")
	InstallPackage("screen")

def checkRule38591():
	logging("Checking whether 'rsh-server' package is installed on system.")
	if OsName.lower() == "ubuntu":
		res = runOnShell('dpkg -s rsh-server')
	else:
		res = runOnShell('rpm -q rsh-server')
	if ("not installed" in res) or ("deinstall ok" in res):
		logging("'rsh-server' package is not installed on system.")
		return True
	logging("'rsh-server' package is installed on system. Please remove the 'rsh-server' package.")
	return False

def fixRule38591():
	logging("Removing 'rsh-server' package from system.")
	if OsName.lower() == "ubuntu":
		runOnShell('dpkg -r --force-all rsh-server')
	else:
		runOnShell('rpm -e rsh-server --nodeps')

def checkRule38592(val=604800):
    logging("Checking the configuration to unlock the account after a number of incorrect logon attempts.")
    if OsName.lower() == "ubuntu":
	listPath = ['/etc/pam.d/common-auth']
	checkCommonAuthFile = runOnShell('grep "auth\s*required\s*pam_tally2.so" /etc/pam.d/common-auth | grep -v "^#"')
	checkCommonAccount = runOnShell('grep "account\s*required\s*pam_tally2.so" /etc/pam.d/common-account | grep -v "^#"')
	if (checkCommonAuthFile == "") or (checkCommonAccount == ""):
                logging("Failed password attempt policy is not configured correctly.")
		return False

	data = [checkCommonAuthFile]
    else:
	listPath = ['/etc/pam.d/system-auth','/etc/pam.d/password-auth']

    returnFlag = True
    for fileName in listPath:
	if not OsName.lower() == "ubuntu":
            # Checking for the auth and account lines in the system-auth and pawword-auth files.
            systemAuthReq = runOnShell('grep "auth\s*required\s*pam_faillock.so" '+ fileName + ' | grep -v "^#"')
	    systemAuthDefault = runOnShell('grep "auth\s*\[default\=die\]\s*pam_faillock.so" '+ fileName + ' | grep -v "^#"') 
            systemAccReq = runOnShell('grep "account\s*required\s*pam_faillock.so" '+ fileName + ' | grep -v "^#"')

            if (systemAuthReq == "") or (systemAccReq == "") or (systemAuthDefault == ""):
                logging("Failed password attempt policy is not configured correctly.")
                return False
            data = [systemAuthReq, systemAuthDefault]

        for line in data:
	    if OsName.lower() == "ubuntu":
                if re.match(r'.*\s*(\bauth\s*required\s*pam_tally2.so\b)\s*', line):
		    line = line.translate(string.maketrans("\n\t\r", "   "))
            else:
		if re.match(r'.*\s*(\bauth\s*required\s*pam_faillock.so\b)\s*', line) or \
		    re.match(r'.*\s*(\bauth\s*\[default\=die\]\s*pam_faillock.so\b)\s*', line):
		    line = line.translate(string.maketrans("\n\t\r", "   "))
	    matchObjs = re.match(r'.*\s*(\bunlock_time=\w*\b)\s*', line)
            if matchObjs != None:
                parameter = matchObjs.group(1)
                actualParam,paramValue =  parameter.split("=")
                try:
                    if (int(paramValue) < val):
                        returnFlag = False
                        break
                except:
                    returnFlag = False
                    break
            else:
                returnFlag = False
                break
        if not returnFlag:
            logging("Failed password attempt policy is not configured correctly.")
            return False
    logging("Failed password attempt policy is configured correctly.")
    return True


def fixRule38592(val=604800):
    logging("Modifying the configuration to unlock the account after a number of incorrect logon attempts, \
the DoD recommends largest acceptable value is 604800 seconds (one week).")
    if OsName.lower() == "ubuntu":
	listPath = ['/etc/pam.d/common-auth','/etc/pam.d/common-account']
	systemAuthReq = runOnShell('grep "auth\s*required\s*pam_tally2.so" /etc/pam.d/common-auth | grep -v "^#"')
	systemAccReq = runOnShell('grep "account\s*required\s*pam_tally2.so" /etc/pam.d/common-account | grep -v "^#"')
    else:
	listPath = ['/etc/pam.d/system-auth','/etc/pam.d/password-auth']

    moduleSearchAuthDefault = ""
    systemAuthDefault = ""
    for fileName in listPath:
	if not OsName.lower() == "ubuntu":
            systemAuthReq = runOnShell('grep "auth\s*required\s*pam_faillock.so" '+ fileName + ' | grep -v "^#"')
            systemAuthDefault = runOnShell('grep "auth\s*\[default\=die\]\s*pam_faillock.so" '+ fileName + ' | grep -v "^#"') 
            systemAccReq = runOnShell('grep "account\s*required\s*pam_faillock.so" '+ fileName + ' | grep -v "^#"')
 
	fileData = open(fileName,"r")
        fileString = ""
	lastLine = ""
	updateValue = False
        for line in fileData:
	    updateValue = False

	    if OsName.lower() == "ubuntu":
                moduleSearchAuthReq = re.search('auth\s*required\s*pam_tally2.so',line)
	    else:
                moduleSearchAuthReq = re.search('auth\s*required\s*pam_faillock.so',line)
	        moduleSearchAuthDefault = re.search('auth\s*\[default\=die\]\s*pam_faillock.so',line)
            moduleSearchAccReq = re.search('account\s*required\s*pam_faillock.so',line)

	    if (moduleSearchAuthReq != None and systemAuthReq) or (moduleSearchAuthDefault != None and systemAuthDefault):
		# Updating the unlock_time parameter if not configured properly.
		checkValue = False
		if isL(line) and "unlock_time" in line:
		    line = line.translate(string.maketrans("\n\t\r", "   ")).strip()
		    matchObjs = re.match(r'.*\s*(\bunlock_time=\w*\b)\s*', line)
		    systemAuthReq = systemAuthReq.translate(string.maketrans("\n\t\r", "   "))
		    systemAuthDefault = systemAuthDefault.translate(string.maketrans("\n\t\r", "   "))
		    if tokenMatchIC("unlock_time", systemAuthReq) or tokenMatchIC("unlock_time=", systemAuthReq):
			checkValue = True
		    elif tokenMatchIC("unlock_time", systemAuthDefault) or tokenMatchIC("unlock_time=", systemAuthDefault):
			checkValue = True
		    elif matchObjs != None:
			parameter = matchObjs.group(1)
			actualParam,paramValue = parameter.split("=")
			try:
                            if (int(paramValue) < val):
				checkValue = True
			    else:
				pass
			except:
			    checkValue = True
		    else:
			updateValue = True
		else:
		    updateValue = True
		if checkValue:
		    start = line.index("unlock_time")
		    new = line[start:]
		    try:
		        end = new.index(" ")
		        line = line[0:start] + "unlock_time=604800" + line[start+end:]
		    except:
		        end = 6
		        line = line[0:start] + "unlock_time=604800" + line[start+end:len(line[start:])]

		if updateValue:
		    line = line.translate(string.maketrans("\n", " ")).strip()
		    line = line+' unlock_time=604800'
		fileString += line + '\n'
	    # Adding the auth and account lines if the lines does not exist.
	    elif systemAuthReq == "" or systemAuthDefault == "" or systemAccReq == "":
		# If the auth line does not exist.
		if systemAuthReq == "":
		    if OsName.lower() == "ubuntu":
                        if re.search('^auth.*pam_unix.so',line):
			    if not tokenMatch('Cloud Raxak updated next line', lastLine):
                                fileString += "# Cloud Raxak updated next line\n"
                            fileString += "auth required pam_tally2.so unlock_time=604800 onerr=fail" +"\n"
	            else:
                        if re.search('^auth\s*sufficient\s*pam_unix.so',line):
                            if not tokenMatch('Cloud Raxak updated next line', lastLine):
                                fileString += "# Cloud Raxak updated next line\n"
                            fileString += "auth required pam_faillock.so preauth silent unlock_time=604800" +"\n"

		# If the auth default line does not exist.
		if systemAuthDefault == "":
                        if re.search('^auth\s*sufficient\s*pam_unix.so',line):
                            fileString += line + "# Cloud Raxak updated next line\nauth [default=die] pam_faillock.so authfail unlock_time=604800" +"\n"
                            continue

		# If the account line does not exist.
		if systemAccReq == "":
		    if OsName.lower() == "ubuntu":
                        checkLine = re.search('^account.*pam_unix.so',line)
		    else:
                        checkLine = re.search('^account\s*required\s*pam_unix.so',line)
		    if checkLine:  
                        if not tokenMatch('Cloud Raxak updated next line', lastLine):
                            fileString += "# Cloud Raxak updated next line\n"
			if OsName.lower() == "ubuntu":
			    fileString += "account required pam_tally2.so" +"\n"
			else:
			    fileString += "account required pam_faillock.so" +"\n"
		fileString += line
	    else:
	        fileString += line
	    lastLine = line
        fout = None
        fout = open(fileName, 'wt')
        if fout != None:
            fout.write(fileString)
            fout.close()

def checkRule38593():
    #Checking ssh configuration file validity
    #If there are any errors, not restarting ssh
    if checkSSHDSyntax() == None:
	return None

    logging("Checking if the system login banner is compliant.")
    try:
	bannerFileName = runOnShell('grep -wi Banner /etc/ssh/sshd_config | grep -v "^#"').splitlines()[0]
	bannerFileName = bannerFileName.translate(string.maketrans("\n\t\r", "   "))
	bannerFileName = bannerFileName.split()[1]
    except IndexError:
	logging("Warning banner is not consistent across the system.")
	return False

    if os.path.isdir(bannerFileName):
	logging("Warning banner is not consistent across the system.")
        return False

    if os.path.exists(bannerFileName):
	bannerFileContent = runOnShell ("cat " + bannerFileName)
        bannerFileContent = bannerFileContent.translate(string.maketrans("\n\t\r", "   "))
        bannerFileContent = re.sub(' +', '', bannerFileContent)
        if bannerFileContent:
	    logging("Warning banner is consistent across the system.")
            return True

    logging("Warning banner is not consistent across the system.")
    return False


def fixRule38593():
    if checkSSHDSyntax() == None:
	return None

    logging ("Checking banner file existence.")
    if not os.path.exists('/etc/issue'):
        logging("Creating banner file.")
        runOnShell ("touch /etc/issue")

    bannerFlag = False
    with open('/etc/ssh/sshd_config', "r") as data:
        sshConfigFileLine = ""
        lastLine = ""
        for line in data:
            if isL(line) and "Banner" in line:
                if not bannerFlag:
                    logging("Updating the SSH daemon configuration for login banner.")
                    if not tokenMatch("Cloud Raxak updated next line", lastLine):
                        sshConfigFileLine += "# Cloud Raxak updated next line\n"
                    sshConfigFileLine += "Banner /etc/issue\n"
                    bannerFlag = True
            else:
                sshConfigFileLine += line
                lastLine = line

    if not(bannerFlag):
	if not tokenMatch("Cloud Raxak updated next line", lastLine):
            sshConfigFileLine += "\n# Cloud Raxak updated next line\n"
        logging("Adding SSH daemon configuration for login banner.")
        sshConfigFileLine += "Banner /etc/issue\n"

    fout = open('/etc/ssh/sshd_config', "wt")
    if fout != None:
	fout.write(sshConfigFileLine)
        fout.close()

    fout = open('/etc/issue', "wt")
    if fout != None:
	fout.write("I've read & consent to terms in IS user agreem't.\n")
	fout.close()

    # Reloading the ssh service
    RunService("ssh")


def checkRule38594():
	#Centos-7 for running the some systemd services,
	#First required to enable the socket of that service.
	#TODO There is required to do RnD for starting the rlogin@.service.
	#systemctl start rsh@.service -> not working.
	#systemctl start rsh@.socket -> working
	if OsName.lower() == "ubuntu":
		if not CheckPackage("rsh-server") and not CheckPackage("rsh-redone-server"):
			return True
		packageInstalled = False
		if CheckPackage("xinetd"):
			nameof_service = "xinetd"
			token_match = "xinetdstop/waiting"
		        packageInstalled = True
		elif CheckPackage("inetutils-inetd"):
			nameof_service = "inetutils-inetd"
			nameof_service_runlevel = "inetutils-inet"
			token_match = "*inetdisrunning"
		        packageInstalled = True
		elif CheckPackage("openbsd-inetd"):
			nameof_service = "openbsd-inetd"
			nameof_service_runlevel = "openbsd-inet"
			token_match = "*inetdisrunning"
		        packageInstalled = True
		if packageInstalled and os.path.exists('/etc/inetd.conf'):
			    logging("Checking if remote shell server settings exist in the file.")
		            check_rshd = runOnShell("grep -w rshd /etc/inetd.conf | grep -v '^#'")
		            if check_rshd != "":
				service_status = runOnShell('service '+ nameof_service + ' status')
				service_status_trans = service_status.translate(string.maketrans("\n\t\r", "   "))
				if "unrecognized service" not in service_status:
					return_value = tokenMatchIC(token_match, service_status_trans.replace(" ",''))
					service_at_level = runOnShell("sysv-rc-conf --list " + nameof_service)
					service_trans = service_at_level.translate(string.maketrans("\n\t\r", "   "))
					service_replace = service_trans.replace(" ","")
					if nameof_service == 'xinetd':
					    if "on" in service_replace:
					    	logging("xinetd service is on at runlevel.")
					    	return False
					    if return_value:
						logging(nameof_service + " service is not running.")
						return True
					else:
					    if tokenMatchIC(nameof_service_runlevel + "0:off1:off2:off3:off4:off5:off6:offS:off", service_replace):
						if not return_value:
					    		logging(nameof_service + " service is not running.")
							return True
					    else:
					        logging(nameof_service + " service is on at runlevel.")
					        return False
					logging(nameof_service + " service is running.")
					return False
	elif (( OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		logging("Checking the rsh service status in system boot configuration.")
		serviceStatus = runOnShell('systemctl is-active rsh.socket').replace('\n','')
		serviceEnabled = runOnShell("systemctl is-enabled rsh.socket").replace('\n','')
		if serviceStatus == "active" and 'enabled' in serviceEnabled:
			logging("rsh service is enabled.")
			return False
	else :
		service_command = "chkconfig --list rsh"
		token_match = "rshon"
		logging("Checking the rsh service status in system boot configuration.")
		ser_runlevel_status = runOnShell(service_command)
		if ser_runlevel_status == "":
			logging("rsh service is not running.")
		if serviceInstalled(ser_runlevel_status):
			ser_runlevel_status = ser_runlevel_status.translate(string.maketrans("\n\t\r", "   "))
			ser_runlevel_status = ser_runlevel_status.replace(" ",'')
			if tokenMatchIC(token_match, ser_runlevel_status):
				logging("rsh service is enabled.")
				return False
	logging("rsh service is disabled.")
	return True
	
def fixRule38594():
	if OsName.lower() == "ubuntu":
		if os.path.exists('/etc/inetd.conf'):
		    check_rshd = runOnShell("grep -w rshd /etc/inetd.conf | grep -v '^#'")
		    with open("/etc/inetd.conf", "r") as file_content:
			file_string = ""
			for line in file_content:
			    if isL(line) and 'rshd' in line:
				file_string += "#" + line
			    else:
				file_string += line 
		    fout = None
		    fout = open("/etc/inetd.conf", 'wt')
		    if fout != None:
			fout.write(file_string)
			fout.close()
		    packageInstalled = False
		    if CheckPackage("xinetd"):
			nameof_service = "xinetd"
			token_match = "xinetdstop/waiting"
		        packageInstalled = True
		    elif CheckPackage("inetutils-inetd"):
			nameof_service = "inetutils-inetd"
			token_match = "*inetdisrunning"
		        packageInstalled = True
		    elif CheckPackage("openbsd-inetd"):
			nameof_service = "openbsd-inetd"
			token_match = "*inetdisrunning"
		        packageInstalled = True
		    if packageInstalled:
			service_status = runOnShell('service '+ nameof_service + ' status')
			service_status_trans = service_status.translate(string.maketrans("\n\t\r", "   "))
			if nameof_service == 'xinetd':
				if not tokenMatchIC(token_match, service_status_trans.replace(" ",'')):
		        	    logging("Restart the xinetd service")
		            	    runOnShell("service "+ nameof_service + " restart")
			else:
			    if tokenMatchIC(token_match, service_status_trans.replace(" ",'')):
		            	runOnShell("service "+ nameof_service + " restart")
		    logging("Disabling the rsh service at default runlevel.")
		    runOnShell("sysv-rc-conf rsh off")
	elif (( OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		logging("Disabling the rsh service in system boot configuration.")
		runOnShell("systemctl disable rsh.socket ; systemctl stop rsh.socket")
	else:
		service_off_command = "chkconfig rsh off"
		logging("Disabling the rsh service at runlevel.")
		runOnShell(service_off_command)

def checkRule38595():
        logging("Interview the SA to determine whether the system is configured to require the use of a CAC, PIV compliant hardware token, \
or Alternate Logon Token (ALT) for authentication, refer to your OS documentation to manually enable smart card authentication and \
enable SSH to authenticate against a Common Access Card (CAC).")
        return None

def fixRule38595():
	logging("To enable smart card authentication and enabling SSH to authenticate against a Common Access Card (CAC) refer to your OS \
documentation.")
        return None

def checkRule38596():

    kernel_value = runOnShell("sysctl kernel.randomize_va_space")
    try:
        setting = kernel_value.split()[2]
    except IndexError:
        logging("System is not configured correctly to implement virtual address space randomization.")
	return False

    if atoi(setting) != 2:
        logging("System is not configured correctly to implement virtual address space randomization.")
	return False

    logging("Loading the setting defined during boot time to verify \
the system configuration for address space randomization after system reboot.")
    random_boot = runOnShell("grep -w kernel.randomize_va_space /etc/sysctl.conf | grep -v '^#'")
    random_boot = random_boot.translate(string.maketrans("\n\t\r", "   "))
    if random_boot == "":
	logging("System is not configured to implement virtual address space randomaization.")
	return False
    	
    if keyValEqMatch_new("kernel.randomize_va_space","2",random_boot):
        logging("System is configured correctly to implement virtual address space randomaization.")
    	return True
    else:
        logging("System is not configured correctly to implement virtual address space randomaization.")
    	return False

	
def fixRule38596():
    runOnShell("sysctl -w kernel.randomize_va_space=2")
    with open("/etc/sysctl.conf", "r") as file_read:
        flag = False
        file_string = ""
        lastLine = ""
        for line in file_read:
            if isL(line) and "kernel.randomize_va_space" in line:
		if not(flag):
                	if not tokenMatch('Cloud Raxak updated next line',lastLine):
                		file_string += "# Cloud Raxak updated next line\n"
                	file_string += "kernel.randomize_va_space = 2\n"
                	flag = True
            else:
                file_string += line
                lastLine = line

        if not flag:
		if not tokenMatch('Cloud Raxak updated next line',lastLine):
            		file_string += "# Cloud Raxak updated next line\n"
		file_string += "kernel.randomize_va_space = 2\n"

    fout = open("/etc/sysctl.conf", 'wt')
    if fout != None:
    	fout.write(file_string)
        fout.close()

def checkRule38597():
	#TODO : We need to implement the function for RHEL 7.
	if OsName.lower() in ["ubuntu","amazon linux ami"]:
	    logging(OsName+" has NX protection enabled by default and uses NX emulation in the kernel (the equivalent of the Red Hat Exec Shield), hence rule is not applicable for "+OsName)
	    return True
	elif (OsName.lower() == "centos") and (OsVersion >= (7,0)):
	    logging("Parameter 'kernel.exec-shield' is by default enabled and cannot be disabled, \
hence rule is not applicable.")
	    return True
	else:
	    kernel_value = runOnShell("grep kernel.exec-shield /etc/sysctl.conf| grep -v '^#' ")
	    if kernel_value != '':
	        try:
		    if kernel_value.split()[2] == "1":
		        return True
		except IndexError:
                    logging("System does not limit the ability of processes to have simultaneous write and execute access to memory.")
		    return False
	    else:
	         kernel_boot_value = runOnShell('/sbin/sysctl -a | grep kernel.exec-shield')
	         if kernel_boot_value != '':
		    value = kernel_boot_value.replace(" ",'')
		    if value.split('=')[1].strip() == '1':
			logging("System limit the ability of processes to have simultaneous write and execute access to memory.")
		        return True
            logging("System does not limit the ability of processes to have simultaneous write and execute access to memory.")
            return False
    
def fixRule38597():
    if OsVersion < (7,0):
	runOnShell("sysctl -w kernel.exec-shield=1")
    with open("/etc/sysctl.conf", "r") as file_read:
        flag = False
        file_string = ""
        lastLine = ""
        for line in file_read:
            if isL(line) and "kernel.exec-shield" in line:
                if not tokenMatch('Cloud Raxak updated next line',lastLine):
                    file_string += "# Cloud Raxak updated next line\n"
                file_string += "kernel.exec-shield = 1\n"
                flag = True
            else:
                file_string += line
                lastLine = line
        if not(flag):
            file_string += "# Cloud Raxak updated next line\n"
            file_string += "kernel.exec-shield = 1\n"
        fout = None
        fout = open("/etc/sysctl.conf", 'wt')
        if fout != None:
            fout.write(file_string)
            fout.close()

def checkRule38598():
	#Centos-7 for running the some systemd services,
	#First required to enable the socket of that service.
	#TODO There is required to do RnD for starting the rlogin@.service.
	#systemctl start rexec@.service -> not working.
	#systemctl start rexec@.socket -> working
	if OsName.lower() == "ubuntu":
		if not CheckPackage("rsh-server") and not CheckPackage("rsh-redone-server"):
			return True
		packageInstalled = False
		if CheckPackage("xinetd"):
			nameof_service = "xinetd"
			token_match = "stop/waiting"
		        packageInstalled = True
		elif CheckPackage("inetutils-inetd"):
			nameof_service = "inetutils-inetd"
			nameof_service_runlevel = "inetutils-inet"
			token_match = "*inetdisrunning"
		        packageInstalled = True
		elif CheckPackage("openbsd-inetd"):
			nameof_service = "openbsd-inetd"
			nameof_service_runlevel = "openbsd-inet"
			token_match = "*inetdisrunning"
		        packageInstalled = True
		if packageInstalled and os.path.exists('/etc/inetd.conf'):
			    logging("Checking if Remote execution client settings exist in the file.")
                            check_rexec = runOnShell("grep -w rexecd /etc/inetd.conf | grep -v '^#'")
                            if check_rexec!= "":
				service_status = runOnShell('service '+ nameof_service + ' status')
				service_status_trans = service_status.translate(string.maketrans("\n\t\r", "   "))
				if "unrecognized service" not in service_status:
					return_value = tokenMatchIC(token_match, service_status_trans.replace(" ",''))
					service_at_level = runOnShell("sysv-rc-conf --list " + nameof_service)
					service_trans = service_at_level.translate(string.maketrans("\n\t\r", "   "))
					service_replace = service_trans.replace(" ","")
					if nameof_service == 'xinetd':
					    if "on" in service_replace:
						logging("xinetd service is on at runlevel.")
						return False
					    if return_value:
						logging(nameof_service + " service is not running.")
						return True
					else:
					    if tokenMatchIC(nameof_service_runlevel + "0:off1:off2:off3:off4:off5:off6:offS:off", service_replace):
						if not return_value:
					    		logging(nameof_service + " service is not running.")
							return True
					    else:
					        logging(nameof_service + " service is on at runlevel.")
					        return False
					logging(nameof_service + " service is running.")
					return False
	elif ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		logging("Checking the Remote execution client service status in system boot configuration.")
		serviceStatus = runOnShell('systemctl is-active rexecd.socket').replace('\n','')
		serviceEnabled = runOnShell("systemctl is-enabled rexecd.socket").replace('\n','')
		if serviceStatus == "active" and 'enabled' in serviceEnabled:
			logging("Remote execution client service is enabled.")
			return False
	else:
		service_command = "chkconfig --list rexec"
		token_match = "rexecon"

		logging("Checking the rexecd service status in system boot configuration.")
		ser_runlevel_status = runOnShell(service_command)
		if ser_runlevel_status == "":
			logging("Remote execution client (rexecd) service is not running.")	
		if serviceInstalled(ser_runlevel_status):
			ser_runlevel_status = ser_runlevel_status.translate(string.maketrans("\n\t\r", "   "))
			ser_runlevel_status = ser_runlevel_status.replace(" ",'')
			if tokenMatchIC(token_match, ser_runlevel_status):
				logging("rexecd service is enabled.")
				return False
	logging("Remote execution client (rexecd) service is disabled.")
	return True

def fixRule38598():
	if OsName.lower() == "ubuntu":
		if os.path.exists('/etc/inetd.conf'):
		    check_rexecd = runOnShell("grep rexecd /etc/inetd.conf | grep -v '^#'")
		    with open("/etc/inetd.conf", "r") as file_content:
		    	file_string = ""
			for line in file_content:
			    if isL(line) and 'rexecd' in line:
				file_string += "#" + line
			    else:
				file_string += line
		    
		    fout = None
		    fout = open("/etc/inetd.conf", 'wt')
		    if fout != None:
			fout.write(file_string)
			fout.close()
		    packageInstalled = False
		    if CheckPackage("xinetd"):
			nameof_service = "xinetd"
			token_match = "xinetdstop/waiting"
		        packageInstalled = True
		    elif CheckPackage("inetutils-inetd"):
			nameof_service = "inetutils-inetd"
			token_match = "*inetdisrunning"
		        packageInstalled = True
		    elif CheckPackage("openbsd-inetd"):
			nameof_service = "openbsd-inetd"
			token_match = "*inetdisrunning"
		        packageInstalled = True
		    if packageInstalled:
			service_status = runOnShell('service '+ nameof_service + ' status')
			service_status_trans = service_status.translate(string.maketrans("\n\t\r", "   "))
			if nameof_service == 'xinetd':
				if not tokenMatchIC(token_match, service_status_trans.replace(" ",'')):
		        	    logging("Restart the xinetd service")
		            	    runOnShell("service "+ nameof_service + " restart")
			else:
			    if tokenMatchIC(token_match, service_status_trans.replace(" ",'')):
		            	runOnShell("service "+ nameof_service + " restart")
		    logging("Disabling the Remote execution client (rexec) service at default runlevel.")
		    runOnShell("sysv-rc-conf rexec off")
	elif ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		logging("Disabling the Remote execution client (rexecd) service in system boot configuration.")
		runOnShell("systemctl disable rexec.socket ; systemctl stop rexec.socket")
	else:
		service_off_command = "chkconfig rexec off"
		logging("Disabling the Remote execution client (rexecd) service in system boot configuration.")
		runOnShell(service_off_command)

def checkRule38599():
	logging("Checking the vsftpd service installation.")
	if not os.path.exists('/usr/sbin/vsftpd'):
		logging("The vsftpd service is not installed, hence this rule is not applicable." )
		return True
	if OsName.lower() == "ubuntu":
		filePath = "/etc/vsftpd.conf"
	else:
		filePath = "/etc/vsftpd/vsftpd.conf"
	if not os.path.exists(filePath):
		logging ("The vsftpd service configuration file does not exist, hence check it manually.")
		return None

	logging("Checking the configuration for the system greeting banner to be used for FTP connections.")
	greetingBanner = runOnShell('grep -w banner_file ' + filePath + '| grep -v "^#"')
	simpleGreetingBanner = runOnShell('grep -w ftpd_banner ' + filePath + '| grep -v "^#"')
	simpleBannerFlag = False
	customBannerFlag = False

	if greetingBanner != "":
		try:
			greetingBannerList = greetingBanner.split("=")
		except IndexError:
			logging("The system is not properly configured for the system greeting banner to be used for FTP connections.")
			return False
		if isL(greetingBanner) and tokenMatch("banner_file", greetingBannerList[0]):
			customBannerFile = greetingBannerList[1].strip()
			if ("banner_file="+customBannerFile in greetingBanner) and os.path.exists(customBannerFile):
				customBannerFlag = True
			if not os.path.exists(customBannerFile):
				logging("The custom banner text file does not exist.")
				return False
	elif simpleGreetingBanner != "":
		try:
			simpleBannerText = simpleGreetingBanner.split("=")[1]
		except IndexError:
			logging("The system is not properly configured for the system greeting banner to be used for FTP connections.")
			return False
		if ("ftpd_banner="+simpleBannerText.strip() in simpleGreetingBanner) and (not simpleBannerText.isspace()):
			simpleBannerFlag = True

	if simpleBannerFlag or customBannerFlag:
		logging("The system is configured for the system greeting banner to be used for FTP connections.")
		return True

	logging("The system is not properly configured for the system greeting banner to be used for FTP connections.")
	return False

def fixRule38599():
	if OsName.lower() == "ubuntu":
		filePath = "/etc/vsftpd.conf"
	else:
		filePath = "/etc/vsftpd/vsftpd.conf"

	if not os.path.exists(filePath):
		logging ("The vsftpd service configuration file does not exist, hence check it manually.")
		return None

	if not os.path.exists('/etc/issue'):
		runOnShell('touch /etc/issue')
		bannerFile = open('/etc/issue', 'wt')
		bannerFile.write("I\'ve read & consent to terms in IS user agreem\'t.\n")
		bannerFile.close()

	with open(filePath, "r") as configFile:
		flag = False
		bannerLine = ""
		lastLine = ""
		for line in configFile:
			if "banner_file" in line and isL(line):
				if not tokenMatch('Cloud Raxak updated next line',lastLine):
					bannerLine += "# Cloud Raxak updated next line\n"
				logging("Updating the vsftpd configuration for the system greeting banner." )
				bannerLine += "banner_file=/etc/issue\n"
				flag = True
			elif "ftpd_banner" in line and isL(line):
				if not tokenMatch('Cloud Raxak updated next line',lastLine):
					bannerLine += "# Cloud Raxak updated next line\n"
				logging("Updating the vsftpd configuration for the system greeting banner." )
				bannerLine += 'ftpd_banner="I\'ve read & consent to terms in IS user agreem\'t".\n'
				flag = True
			else:
				bannerLine += line
				lastLine = line

		if not(flag):
			logging("Configuring the vsftpd configuration file for the system greeting banner." )
			if not tokenMatch('Cloud Raxak updated next line',lastLine):
				bannerLine += "# Cloud Raxak updated next line\n"
			bannerLine += "banner_file=/etc/issue\n"

	fout = None
	fout = open(filePath, 'wt')
	if fout != None:
		fout.write(bannerLine)
		fout.close()

	logging("Restarting the vsftpd service.")
	if (((OsName.lower() == "redhat") or (OsName.lower() == "centos")) and OsVersion >= (7,0)):
		runOnShell('systemctl restart vsftpd.service')
	else:
		runOnShell('service vsftpd restart')


def checkRule38600():
    ip_value = runOnShell("sysctl net.ipv4.conf.default.send_redirects")
    try:
        setting = ip_value.split()[2]
    except IndexError:
	logging("System is not configured to ignore ICMPv4 redirect by default.")
	return False
    if atoi(setting) != 0:
	logging("System is not configured correctly to ignore ICMPv4 redirect by defaults.")
	return False
    logging("Loading the setting defined during boot time to verify the system configuration for ignoring ICMPv4 redirects by default after system reboot.")
    redirect_value_boot = runOnShell("grep -w net.ipv4.conf.default.send_redirects /etc/sysctl.conf | grep -v '^#'")
    redirect_value_boot = redirect_value_boot.translate(string.maketrans("\n\t\r", "   "))
    if redirect_value_boot == "":
        logging("System is not configured to ignore ICMPv4 redirect by default.")
	return False
    	
    if keyValEqMatch_new("net.ipv4.conf.default.send_redirects","0",redirect_value_boot):
        logging("System is configured correctly to ignore ICMPv4 redirect by default.")
    	return True
    else:
        logging("System is not configured correctly to ignore ICMPv4 redirect by default.")
    	return False

 
def fixRule38600():
    runOnShell("sysctl -w net.ipv4.conf.default.send_redirects=0")
    with open("/etc/sysctl.conf", "r") as file_read:
        flag = False
        file_string = ""
        lastLine = ""
        for line in file_read:
            if isL(line) and "net.ipv4.conf.default.send_redirects" in line:
                if not tokenMatch('Cloud Raxak updated next line',lastLine):
                    file_string += "# Cloud Raxak updated next line\n"
                file_string += "net.ipv4.conf.default.send_redirects = 0\n"
                flag = True
            else:
                file_string += line
                lastLine = line
        if not(flag):
            file_string += "# Cloud Raxak updated next line\n"
            file_string += "net.ipv4.conf.default.send_redirects = 0\n"
        fout = None
        fout = open("/etc/sysctl.conf", 'wt')
        if fout != None:
            fout.write(file_string)
            fout.close()

def checkRule38601():
    send_value=runOnShell("sysctl net.ipv4.conf.all.send_redirects")
    try:
        setting = send_value.split()[2]
    except IndexError:
        logging("System is not configured to ignore ICMPv4 redirects form any interface.")
	return False
    if atoi(setting) != 0:
	logging("System is not configured correctly to ignore ICMPv4 redirects form any interface.")
	return False
    logging("Loading the setting defined during boot time to verify the system configuration for ignoring ICMPv6 redirects by default after system reboot.")
    reverse_boot = runOnShell("grep -w net.ipv4.conf.all.send_redirects /etc/sysctl.conf | grep -v '^#'")
    reverse_boot = reverse_boot.translate(string.maketrans("\n\t\r", "   "))
    if reverse_boot == "":
        logging("System is not configured to ignore ICMPv4 redirect from any interface.")
        return False
    if keyValEqMatch_new("net.ipv4.conf.all.send_redirects","0",reverse_boot):
        logging("System is configured correctly to ignore ICMPv4 redirect from any interface.")
    	return True
    else:
        logging("System is not configured correctly to ignore ICMPv4 redirect from any interface.")
    	return False



def fixRule38601():
    runOnShell("sysctl -w net.ipv4.conf.all.send_redirects=0")
    with open("/etc/sysctl.conf", "r") as file_read:
        flag = False
        file_string = ""
        lastLine = ""
        for line in file_read:
            if isL(line) and "net.ipv4.conf.all.send_redirects" in line:
                if not tokenMatch('Cloud Raxak updated next line',lastLine):
                    file_string += "# Cloud Raxak updated next line\n"
                file_string += "net.ipv4.conf.all.send_redirects = 0\n"
                flag = True
            else:
                file_string += line
                lastLine = line
        if not(flag):
            file_string += "# Cloud Raxak updated next line\n"
            file_string += "net.ipv4.conf.all.send_redirects = 0\n"
        fout = None
        fout = open("/etc/sysctl.conf", 'wt')
        if fout != None:
            fout.write(file_string)
            fout.close()

def checkRule38602():
	#Centos-7 for running the some systemd services,
	#First required to enable the socket of that service.
	#TODO There is required to do RnD for starting the rlogin@.service.
	#systemctl start rlogin@.service -> not working.
	#systemctl start rlogin@.socket -> working
	if OsName.lower() == "ubuntu":
		if not CheckPackage("rsh-server") and not CheckPackage("rsh-redone-server"):
			return True
		packageInstalled = False
		if CheckPackage("xinetd"):
			nameof_service = "xinetd"
			token_match = "xinetdstop/waiting"
		        packageInstalled = True
		elif CheckPackage("inetutils-inetd"):
			nameof_service = "inetutils-inetd"
			nameof_service_runlevel = "inetutils-inet"
			token_match = "*inetdisrunning"
		        packageInstalled = True
		elif CheckPackage("openbsd-inetd"):
			nameof_service = "openbsd-inetd"
			nameof_service_runlevel = "openbsd-inet"
			token_match = "*inetdisrunning"
		        packageInstalled = True
		if packageInstalled and os.path.exists('/etc/inetd.conf'):
			    logging("Checking if rlogind exists in the default configuration file for the inetd (super-server) daemon.") 
                            check_rlogind = runOnShell("grep -w rlogind /etc/inetd.conf | grep -v '^#'")
                            if check_rlogind != "":
				service_status = runOnShell('service '+ nameof_service + ' status')
				service_status_trans = service_status.translate(string.maketrans("\n\t\r", "   "))
				if "unrecognized service" not in service_status:
					return_value = tokenMatchIC(token_match, service_status_trans.replace(" ",''))
					service_at_level = runOnShell("sysv-rc-conf --list " + nameof_service)
					service_trans = service_at_level.translate(string.maketrans("\n\t\r", "   "))
					service_replace = service_trans.replace(" ","")
					if nameof_service == 'xinetd':
					    if "on" in service_replace:
					 	logging("xinetd service is on at runlevel.")
					 	return False
					    if return_value:
						logging(nameof_service + " service is not running.")
						return True
					else:
					    if tokenMatchIC(nameof_service_runlevel + "0:off1:off2:off3:off4:off5:off6:offS:off", service_replace):
						if not return_value:
							logging(nameof_service + " service is not running.")
							return True
					    else:
					        logging(nameof_service + " service is on at runlevel.")
					        return False
					logging(nameof_service + " service is running.")
					return False
	elif ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		logging("Checking the status of rlogind service in system boot configuration.")
		#To check the installation of service.. 
		check_service_installation = runOnShell('systemctl list-unit-files | grep rsh')
		if check_service_installation == "":
			return True
		serviceStatus = runOnShell('systemctl is-active rlogin.socket').replace('\n','')
		serviceEnabled = runOnShell("systemctl is-enabled rlogin.socket").replace('\n','')
		if serviceStatus == "active" and 'enabled' in serviceEnabled:
			logging("rlogin service is enabled.")
			return False
	else:
		service_name = "chkconfig"
		token_match = "rloginon"
		##To check the installation of service..
		logging("Checking the status of rlogind service in system boot configuration.")
		ser_runlevel_status = runOnShell(service_name+' --list rlogin')
		if ser_runlevel_status == "":
			logging("rlogind service is not running.")
		if serviceInstalled(ser_runlevel_status):
			ser_runlevel_status = ser_runlevel_status.translate(string.maketrans("\n\t\r", "   "))
			ser_runlevel_status = ser_runlevel_status.replace(" ",'')
			if tokenMatchIC(token_match, ser_runlevel_status):
				logging("rlogind service is enabled.")
				return False

	logging("rlogind service is disabled.")
	return True

	
def fixRule38602():
	if OsName.lower() == "ubuntu":
		if os.path.exists('/etc/inetd.conf'):
			check_rlogind = runOnShell("grep -w rlogind /etc/inetd.conf | grep -v '^#'")
			with open("/etc/inetd.conf", "r") as file_content:
				file_string = ""
				for line in file_content:
				    if isL(line) and 'rlogind' in line:
					file_string += "#" + line
				    else:
					file_string += line 
			fout = None
			fout = open("/etc/inetd.conf", 'wt')
			if fout != None:
			    fout.write(file_string)
			    fout.close()
			packageInstalled = False
		        if CheckPackage("xinetd"):
		            nameof_service = "xinetd"
		            token_match = "xinetdstop/waiting"
		            packageInstalled = True
		        elif CheckPackage("inetutils-inetd"):
		            nameof_service = "inetutils-inetd"
		            token_match = "*inetdisrunning"
		            packageInstalled = True
		        elif CheckPackage("openbsd-inetd"):
		            nameof_service = "openbsd-inetd"
		            token_match = "*inetdisrunning"
		            packageInstalled = True
		        if packageInstalled:
		    	    service_status = runOnShell('service '+ nameof_service + ' status')
		    	    service_status_trans = service_status.translate(string.maketrans("\n\t\r", "   "))
		    	    if nameof_service == 'xinetd':
				if not tokenMatchIC(token_match, service_status_trans.replace(" ",'')):
		    	    	    logging("Restart the xinetd service")
		    	            runOnShell("service "+ nameof_service + " restart")
		    	    else:
				if tokenMatchIC(token_match, service_status_trans.replace(" ",'')):
		    	        	runOnShell("service "+ nameof_service + " restart")
			logging("Disabling the rlogind service at default runlevel.")
			runOnShell("sysv-rc-conf rlogind off")
	elif ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		logging("Disabling the rlogind service in system boot configuration.")
		runOnShell("systemctl disable rlogin.socket ; systemctl stop rlogin.socket")
	else:
		service_off_command = "chkconfig rlogin off"
		logging("Disabling the rlogind service in system boot configuration.")
		runOnShell(service_off_command)

def checkRule38603():
	logging("Checking whether 'ypserv' package is installed on system.")
	if OsName.lower() == "ubuntu":
		res = runOnShell('service ypserv status')
	else:
		res = runOnShell('rpm -q ypserv')
	res = res.translate(string.maketrans("\n\t\r", "   "))
	if tokenMatchIC("unrecognized service", res) or tokenMatchIC("not installed", res):
		logging("ypserv service does not exist.")
		return True
	logging("ypserv service is installed.")
	return False

def fixRule38603():
	if OsName.lower() == "ubuntu":
		logging("Removing 'nis' package since 'ypserv' is part of nis package.")
		if "dpkg was interrupted" in runOnShell('apt-get -y purge nis', False):
			logging("dpkg is not properly configured, it needs to be configured properly using \
command 'dpkg --configure -a'. Please fix this manually.")
			return None
	else:
		logging("Removing 'ypser' package.")
	        runOnShell('rpm -e ypserv --nodeps')

def checkRule38604():
	if os.path.exists('/usr/sbin/ypbind') == False:
		logging("ypbind (NIS binder process) service is not installed.")
		return True
	if ( ( OsVersion >= (7,0) ) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat' ) ):
		service_status = runOnShell('systemctl is-active ypbind.service').replace('\n','')
		if service_status in ["inactive", "unknown","failed"]:
			return True
		service_at_runlevel = runOnShell("systemctl is-enabled ypbind.service").replace('\n','')
		if service_status == "active" or service_at_runlevel == "enabled":
			logging("ypbind service is running.")
			return False
	else:
		if OsName.lower() == "ubuntu":
			service_at_level = 'sysv-rc-conf --list ypbind'
			token_match_list = ["start/running,","running:","start/post-start,"]
		else:
			service_at_level = 'chkconfig --list ypbind'
			token_match_list = ["running..."]
		
		logging("Checking the status of ypbind (NIS binder process) service in runtime configuration.")
		service_status = runOnShell('service ypbind status')
		service_status = service_status.translate(string.maketrans("\n\t\r", "   "))
		if "unrecognized service" not in service_status:
			for token in token_match_list:
				if tokenMatch(token, service_status):
					return False
			logging("Checking the status of ypbind (NIS binder process) service in system boot configuration.")
			service_at_level = runOnShell(service_at_level)
			service_at_level = service_at_level.translate(string.maketrans("\n\t\r", "   "))
			if OsName.lower() == "ubuntu":
				service_at_level_repl = service_at_level.replace(" ",'')
				#This condition work only for fresh system where ypbind service is never used.
				#when you run "#sysv-rc-conf list ypbind" it will give you
				#ypbind with no on/off option for any runlevel.
				#Hence, "service_at_level_repl == ypbind" which will have length=6
				#which will be equal to len("ypbind") which is equal to 6
				#This means that ypbind is disable at system boot configuration.
				if len(service_at_level_repl) == len("ypbind") and tokenMatchIC("ypbind",service_at_level):
					logging("ypbind (NIS binder process) service is disabled in system boot configuration.")
					return True
				if "on" in service_at_level_repl:
					logging("ypbind (NIS binder process) service is enabled in system boot configuration.")
					return False
			else:
				if not(tokenMatchIC("ypbind 0:off 1:off 2:off 3:off 4:off 5:off 6:off", service_at_level)):
					return False

	logging("ypbind (NIS binder process) service is not running.")
	return True


def fixRule38604():
	if ( ( OsVersion >= (7,0) ) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat' ) ):
		runOnShell("systemctl disable ypbind.service ; systemctl stop ypbind.service")
	else:
		if OsName.lower() == "ubuntu":
			service_status = runOnShell('service ypbind status')
			service_status = service_status.translate(string.maketrans("\n\t\r", "   "))
			if "stop" not in service_status:
				runOnShell("service ypbind stop")
			runOnShell("sysv-rc-conf --level 0123456S ypbind off")
		else:
			logging("Disabling the ypbind (NIS binder process) service.")
			runOnShell("chkconfig --level 0123456 ypbind off; service ypbind stop")


def checkRule38605():
	if not CheckService("crond"):
		return False
	return True

def fixRule38605():

    if OsName.lower() == "ubuntu":
        pkgName = "cron"
    else: 
        pkgName = "cronie"

    if not CheckPackage(pkgName):
        InstallPackage(pkgName) 

    RunService("crond")

def checkRule38606():
	statusFlag = False
	if os.path.exists('/etc/xinetd.d/tftp'):
		tftpStatus = runOnShell("grep -w 'disable' /etc/xinetd.d/tftp")
		tftpStatus = re.sub( '\s+', ' ', tftpStatus)
		if re.match(r'.*\s*(\bdisable = no\b)\s*', tftpStatus):
			statusFlag = True
	if OsName.lower() == "ubuntu":
		logging("Checking whether 'tftpd' package is installed on system.")
		tftpdPack = runOnShell('dpkg -s tftpd')
		if ("not installed" in tftpdPack) or ("deinstall ok" in tftpdPack):
			logging("'tftpd' package is not installed on system.")
			return True
		xinetdPack = runOnShell('dpkg -s xinetd')
		if not (("not installed" in xinetdPack) or ("deinstall ok" in xinetdPack)) and statusFlag:
			logging("'tftpd' package is required, hence not removing the 'tftpd' package. So please check it manually.")
			return None
	else:
		logging("Checking if 'tftp-server' package is installed on system.")
		if "not installed" in runOnShell('rpm -q tftp-server'):
			logging("tftp-server does not exist.")
			return True
		logging("Checking if 'xinetd' package is installed on system.")
		# Checking xinetd package existence and status of tftp-server.
		if not ("not installed" in runOnShell('rpm -q xinetd')) and statusFlag:
			logging("'tftp-server' is required, hence not removing the 'tftp-server' package. So please check it manually.")
			return None

	logging("'tftp-server' is installed but it is disabled.")
	return False

def fixRule38606():
        statusFlag = False
        if os.path.exists('/etc/xinetd.d/tftp'):
		tftpStatus = runOnShell("grep -w 'disable' /etc/xinetd.d/tftp")
		tftpStatus = re.sub( '\s+', ' ', tftpStatus)
		if re.match(r'.*\s*(\bdisable = no\b)\s*', tftpStatus):
			statusFlag = True
        if OsName.lower() == "ubuntu":
		tftpPack = runOnShell('dpkg -s tftpd')
		xinetdPack = runOnShell('dpkg -s xinetd')
		if not ((("not installed" in tftpPack) or ("deinstall ok" in tftpPack)) and (("not installed" in xinetdPack) or ("deinstall ok" in xinetdPack))) or not statusFlag:
			logging("Removing 'tftpd' package.")
			runOnShell('dpkg -r --force-all tftpd')
        else:
		tftpPack = runOnShell('rpm -q tftp-server')
		xinetdPack = runOnShell('rpm -q xinetd')
		if not (("not installed" in tftpPack) and ("not installed" in xinetdPack)) or not statusFlag:
			logging("Removing 'tftp-server' package.")
			runOnShell('rpm -e tftp-server --nodeps')

def checkRule38607():
    #Checking ssh configuration file validity
    #If there are any errors, not restarting ssh
    if checkSSHDSyntax() == None:
	return None

    #In case of Ubuntu OS, if ssh package version prior to than 2.3, they are vulnerables.
    if (OsName.lower() == "ubuntu"):
	sshPortNum = 22
	sshProcess = runOnShell ("grep -iw Port /etc/ssh/sshd_config | grep -v '^#'")
	if sshProcess != "":
	    splitsshProcess = sshProcess.split()
	    sshPortNum = splitsshProcess[1]

	sshVersionCheck = runOnShell ("nc localhost " + str(sshPortNum))
	if sshVersionCheck == "":
	    logging ("Please restart SSH service after changing SSH port number in the SSH configuration file. Need to fix this manually.")
	    return None

	sshVersionList = sshVersionCheck.split("SSH-")
	#Checking ssh version
	if (float(sshVersionList[1][0:3]) < 2.0):
	    logging ("The SSH daemon supports Protocol 1, please fix this manually.")
	    return None

    logging("Checking which SSH protocol version is allowed.")
    res = runOnShell('grep -iw Protocol /etc/ssh/sshd_config  | grep -v "^#"')
    if res == "":
	logging ("The SSH daemon is not configured only for SSHv2 Protocol.")
	return False

    if (res.split())[1] == "2":
	logging ("The SSH daemon is configured to use only SSHv2 protocol.")
	return True
    if (res.split())[1] == "1" and (OsName.lower() == "redhat" or OsName.lower() == "centos") and OsVersion <=(7,0):
	logging ("SSH is not configured for Protocol version 2. Please fix this manually.")
	return None
    else:
	logging ("The SSH daemon is not configured to use only SSHv2 Protocol.")
	return False

def fixRule38607():
    #Checking SSH services and runlevels
    if checkSSHDSyntax() == None:
	return None

    with open('/etc/ssh/sshd_config', "r") as sshConfigFile:
        sshConfigFileContent = ""
        flag = False
        lastLine= ""
        for line in sshConfigFile:
            if isL(line) and tokenMatchIC("Protocol", line):
                if not tokenMatch('Cloud Raxak updated next line',lastLine):
                    sshConfigFileContent += "# Cloud Raxak updated next line\n"
    		logging("Updating SSH protocol version.")
                sshConfigFileContent += "Protocol 2\n"
                flag = True
            else:
                sshConfigFileContent += line
                lastLine=line
        if not(flag):
            sshConfigFileContent += "\n# Cloud Raxak updated next line\n"
            sshConfigFileContent += "Protocol 2\n"

    fout = None
    fout = open('/etc/ssh/sshd_config', "wt")
    if fout != None:
        fout.write(sshConfigFileContent)
        fout.close()

    #Enabling ssh service and run leves
    RunService("ssh")

def checkRule38608(val = 900):
    #Checking ssh configuration file validity
    #If there are any errors, not restarting ssh
    if checkSSHDSyntax() == None:
	return None

    #ASG: Search the word ClientAliveInterval and ignore the line that begins with "#"
    logging("Checking whether the SSH timeout interval on idle sessions is properly configured.")
    alive_interval = runOnShell('grep -iw ClientAliveInterval /etc/ssh/sshd_config  | grep -v "^#"')
    if alive_interval ==  "":
	logging("No configuration for SSH timeout interval on idle sessions was found.")
	return False	
    if ((atoi(alive_interval) == val or atoi(alive_interval) < val) and atoi(alive_interval) != 0):
    	logging("To make ssh client to exit automatically after time out interval, need to check if SSH timeout interval on idle sessions is properly configured.")
    	alive_count_max = runOnShell('grep -iw ClientAliveCountMax /etc/ssh/sshd_config  | grep -v "^#"')
	if alive_count_max == "":
		logging("No configuration for SSH timeout count on idle sessions was found, please remediate rule V-38610 to fix this.")
		return None	  		 
	elif atoi(alive_count_max) == 0:
		logging("SSH timeout count on idle sessions is configured properly to make ssh client to exit after time out interval.")
		return True
	else:
		logging("SSH timeout count on idle sessions is not configured properly, please remediate rule V-38610 to fix this.")
		return None
    else:
        logging("SSH timeout interval on idle sessions is not configured properly.")

    return False		 		 

def fixRule38608():
	if checkSSHDSyntax() == None:
            return None

	lastLine = ""
	concat_line = ""
	flag = False

	fileSplit = open("/etc/ssh/sshd_config").readlines()
	logging("Updating the SSH timeout interval on idle sessions.")
	for line in fileSplit:
	     if isL(line) and tokenMatchIC("ClientAliveInterval", line):
	          if not tokenMatch("Cloud Raxak updated next line", lastLine):
	              concat_line += "# Cloud Raxak updated next line\n"
	          concat_line += "ClientAliveInterval 900\n"
	          flag = True
	     else:
	          concat_line += line
	     	  lastLine = line
	if not(flag):
    	    logging("Adding the SSH timeout interval on idle sessions.")
	    if not tokenMatch("Cloud Raxak updated next line",lastLine):
	        concat_line += "\n# Cloud Raxak updated next line\n"
	    concat_line += "ClientAliveInterval 900\n"
	fout = None
	try:
	    fout = open("/etc/ssh/sshd_config", 'w')
	    fout.write(concat_line)
	finally:
	     if fout is not None:
	         fout.close()

	#Enabling ssh service and run leves
	RunService("ssh")

def checkRule38609():
	#Centos-7 for running the some systemd services,
	#First required to enable the socket of that service.
	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		if not CheckPackage("tftp-server"):
			return True
		tftp_skt_status = runOnShell('systemctl is-active tftp.socket').replace('\n','')
		tftp_srv_status = runOnShell('systemctl is-active tftp.service').replace('\n','')
		tftp_skt_level = runOnShell('systemctl is-enabled tftp.socket').replace('\n','')
		if (tftp_skt_status == "active" or tftp_srv_status == "active" or tftp_skt_level == "enabled"):
			logging("tftp service is running.")
			return False
	elif OsName.lower() == "ubuntu":
		#checking xinetd package is installed.
		logging("Checking if xinetd package is installed.")
		if os.path.exists('/usr/sbin/xinetd'):
		    tftpPort = runOnShell("sudo grep -w ^tftp /etc/services | cut -f3 |grep -v '^#'")
		    if not tftpPort:
		        logging("Since the default tftp port is not define. Hence, tftp service is not working.")
		        return True
		    tftpPort = tftpPort.split("/")
		    logging("Checking if tftp is configured through xinetd.")
		    tftpConfigFile = runOnShell("sudo grep -w /usr/sbin/in.tftpd /etc/xinetd.d/*")

		    #checking default port 69 is running or not.
                    if tftpConfigFile:
                        tftpRunStatus = runOnShell('netstat -aunp | grep xinetd |grep :'+ str(tftpPort[0]))
                        if tftpRunStatus != "":
                            logging("Tftp service is running through xinetd.")
                            return False
                        else:
                            logging("Tftp server is not configured. Hence, tftp is not running.")
                            return True

		#checking inetd package is install.
		else:
		    logging('Since xinetd package is not installed, checking if tftp service is configured using inetd.')
		    if os.path.exists('/usr/sbin/inetd'):
		        if os.path.exists('/etc/inetd.conf'):
		            match_tftpd = runOnShell('grep "in.tftpd" /etc/inetd.conf | grep -v "#"')
		            if match_tftpd != "" and os.path.exists('/usr/sbin/in.tftpd'):
		                logging("Tftp service is running through inetd.")
		                return False
	else:
		if not os.path.exists('/etc/xinetd.d/tftp'):
			logging("tftp service is not installed in the system.")
			return True
		logging("Checking the status of tftp service.")
		res = runOnShell("chkconfig --list tftp")
		if serviceInstalled(res):
			if (tokenMatch("on", res)):
				logging("tftp service is not disabled in system boot configuration.")
				return False

	logging("tftp service is disabled.")
	return True


def fixRule38609():
	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		runOnShell("systemctl disable tftp.socket; systemctl stop tftp.socket")
		runOnShell("systemctl disable tftp.service; systemctl stop tftp.service")
	else:
		if OsName.lower() == "ubuntu":
		    lastLine = ""
		    #tftpd is install using xinetd
		    if os.path.exists('/usr/sbin/xinetd'):
		        tftpConfigFile = runOnShell("sudo grep -w /usr/sbin/in.tftpd /etc/xinetd.d/*")
		        for fileNameList in tftpConfigFile.splitlines():
		            fileName = fileNameList.split(":")[0]
		            if os.path.exists(fileName):
		                fileData = ""
		                listOfLines = open(fileName).readlines()
		                for line in listOfLines:
		                    fileContentLine = line.translate(string.maketrans("\n\t\r", "   "))
		                    if isL(fileContentLine) and tokenMatchIC("disable", fileContentLine):
		                        continue
		                    #Parameter is missing throughout the file.
		                    elif isL(fileContentLine) and tokenMatchIC("}", fileContentLine):
		                        if "Cloud Raxak updated next line" not in lastLine:
		                            fileData += "# Cloud Raxak updated next line\n"
		                        fileData += "disable = yes\n"
		                    fileData += line
		                    lastLine = line
		                fout = open(fileName, 'w')
		                if fout != None:
		                    fout.write(fileData)
		                    fout.close()

		        #kill the ps id for xinetd.
		        tftpPort = runOnShell("sudo grep -w ^tftp /etc/services | cut -f3 |grep -v '^#'")
		        tftpPort = tftpPort.split("/")
		        psId = runOnShell("netstat -aunp | grep xinetd | grep :"+ str(tftpPort[0]))
		        for psIDList in psId.split():
		            if "xinetd" in psIDList:
		                processID = psIDList.split("/")
		                runOnShell("kill -9 " + processID[0] + " 2>/dev/null")

		    #tftpd is install using inetd.
		    #In case of xinetd if /etc/inetd.conf file exist and tftp is configured in the file
		    #then the service will start running when xinetd network is restarted even though inetd is not install.
		    if os.path.exists('/etc/inetd.conf'):
		        newline = ""
		        list_of_lines = open("/etc/inetd.conf").readlines()
		        for line in list_of_lines:
		            if isL(line) and tokenMatch("tftp", line):
                                if "Cloud Raxak updated next line" not in lastLine:
                                    newline += "# Cloud Raxak updated next line\n"
		                newline += "#" + line
		            else:
		                newline += line
                            lastLine = line
		        fout = open("/etc/inetd.conf", 'w')
		        if fout != None:
		            fout.write(newline)
		            fout.close()

		    #restart the network service to apply the chnages.
		    if os.path.exists('/usr/sbin/inetd'):
		        runOnShell("service openbsd-inetd restart")
		    else:
		        runOnShell("service xinetd restart")
		        runOnShell("/etc/init.d/xinetd restart")
		else:
			logging("Disabling the tftp service.")
			runOnShell("chkconfig tftp off")

def checkRule38610(val = 0):
    #Checking ssh configuration file validity
    #If there are any errors, not restarting ssh
    if checkSSHDSyntax() == None:
	return None

    #ASG: Search the word ClientAliveCountMax and ignore the line that begins with "#"
    logging("Checking whether SSH timeout count on idle sessions is configured properly.")
    res = runOnShell('grep -iw ClientAliveCountMax /etc/ssh/sshd_config  | grep -v "^#"')
    if atoi(res) == val:
       logging("SSH timeout count on idle sessions is configured properly.")
       return True
    else:
       logging("SSH timeout count on idle sessions is not configured properly.")
       return False

def fixRule38610():
    if checkSSHDSyntax() == None:
            return None

    lastLine = ""
    s = ""
    flag = False

    fileSplit = open("/etc/ssh/sshd_config").readlines()
    logging("Updating SSH timeout count on idle sessions.")
    for line in fileSplit:
        if isL(line) and tokenMatchIC("ClientAliveCountMax", line):
            if not tokenMatch("Cloud Raxak updated next line",lastLine):
               s += "# Cloud Raxak updated next line\n"
            s += "ClientAliveCountMax 0\n"
            flag = True
        else:
            s += line
            lastLine=line
    if not(flag):
	logging("Adding SSH timeout count on idle sessions.")
        s += "\n# Cloud Raxak updated next line\n"
        s += "ClientAliveCountMax 0\n"
    fout = None
    try:
        fout = open("/etc/ssh/sshd_config", 'w')
        fout.write(s)
    finally:
        if fout is not None:
             fout.close()

    #Enabling ssh service and run leves
    RunService("ssh")

def checkRule38611():
    #Checking ssh configuration file validity
    #If there are any errors, not restarting ssh
    if checkSSHDSyntax() == None:
	return None

    logging("Checking whether SSH daemon is configured to ignore '.rhosts' file.")
    res = runOnShell('grep -iw IgnoreRhosts /etc/ssh/sshd_config  | grep -v "^#"')
    if not res or (re.search ("yes", res.split(" ")[1])):
	logging("The SSH daemon is configured to igonre '.rhosts' file.")
        return True
    logging("The SSH daemon is not configured to igonre '.rhosts' file.")
    return False

def fixRule38611():
    if checkSSHDSyntax() == None:
        return None

    lastLine = ""
    s = ""
    flag = False

    fileSplit = open("/etc/ssh/sshd_config").readlines()
    for line in fileSplit:
        if isL(line) and tokenMatchIC("IgnoreRhosts", line):
            if not tokenMatch("Cloud Raxak updated next line",lastLine):
               s += "# Cloud Raxak updated next line\n"
	    logging("Updating configuration for ignoring '.rhosts' file.")
            s += "IgnoreRhosts yes\n"
            flag = True
        else:
            s += line
            lastLine=line
    if not(flag):
        s += "\n# Cloud Raxak updated next line\n"
        s += "IgnoreRhosts yes\n"
    fout = None
    try:
        fout = open("/etc/ssh/sshd_config", 'w')
        fout.write(s)
    finally:
        if fout is not None:
             fout.close()

    #Enabling ssh service and run leves
    RunService("ssh")

def checkRule38612():
    #Checking ssh configuration file validity
    #If there are any errors, not restarting ssh
    if checkSSHDSyntax() == None:
	return None

    logging("Checking whether SSH daemon does not allow host-based authentication.")
    res = runOnShell('grep -iw HostbasedAuthentication /etc/ssh/sshd_config  | grep -v "^#"')
    if (not res) or (re.search("no", res.split(" ")[1])):
	logging("The SSH daemon does not allow host-based authentication.")
	return True
    logging("The SSH daemon allows host-based authentication.")
    return False

def fixRule38612():
    if checkSSHDSyntax() == None:
        return None

    lastLine = ""
    s = ""
    flag = False

    fileSplit = open("/etc/ssh/sshd_config").readlines()
    for line in fileSplit:
        if isL(line) and tokenMatchIC("HostbasedAuthentication", line):
            if not tokenMatch("Cloud Raxak updated next line",lastLine):
               s += "# Cloud Raxak updated next line\n"
	    logging("Updating settings for not permitting host-based authentication.")
            s += "HostbasedAuthentication no\n"
            flag = True
        else:
            s += line
            lastLine=line
    if not(flag):
        s += "\n# Cloud Raxak updated next line\n"
        s += "HostbasedAuthentication no\n"
    fout = None
    try:
        fout = open("/etc/ssh/sshd_config", 'w')
        fout.write(s)
    finally:
        if fout is not None:
             fout.close()

    #Enabling ssh service and run leves
    RunService("ssh")

def checkRule38613():
    #Checking ssh configuration file validity
    #If there are any errors, not restarting ssh
    if checkSSHDSyntax() == None:
	return None

    logging("Checking if system permits root login using remote access programs.")
    checkPermit = runOnShell('grep -iw PermitRootLogin /etc/ssh/sshd_config  | grep -v "^#"')
    if checkPermit:
	if (re.search("no", checkPermit.split(" ")[1])):
	    logging("System does not permit root login using remote access programs such as ssh.")
	    return True
    userAccounts = runOnShell("awk -F'[/ : ]' '{if ($3 >= '" + uid_value + "' && $3 <= '"+ uid_max_value +"' ) print $1}' /etc/passwd", False)
    userAccounts = userAccounts.splitlines()
    for userAcc in userAccounts:
        passwdSet = False
        sudoUser = False
        accExpire = False
	if userAcc != username:
            # Checking if the password is set for the user.
            checkPasswd = runOnShell("passwd -S " + userAcc, False)
	    if tokenMatchIC('PS', checkPasswd) or tokenMatchIC('P', checkPasswd):
                passwdSet = True

            # Checking if user is having sudo privilleges.
            if not 'not allowed' in runOnShell("sudo -l -U " + userAcc, False):
                sudoUser = True
            #check user account is expired or not.
            checkAccExpiry = runOnShell('chage -l ' + userAcc, False)
            if checkAccExpiry != '':
		    checkList = checkAccExpiry.splitlines()
                    for element in checkList:
			splitElement = element.translate(string.maketrans("\n\t\r", "   "))
                        if tokenMatchIC('Account expires', splitElement):
                            accountExpireValue = element.split(':')[1]
                            accountExpireValue = accountExpireValue.translate(string.maketrans("\n\t\r", "   ")).strip()
		    if not "never" in accountExpireValue:
		        changeDateFormat = runOnShell("date -d '" + accountExpireValue + "' +%Y-%m-%d", False)
		        changeDateFormatStr = datetime.strptime(changeDateFormat[:-1], "%Y-%m-%d").date()	
		        if changeDateFormatStr > datetime.today().date():
				accExpire = True
		    else:
			accExpire = True
        if passwdSet and sudoUser and accExpire:
	    if username == "root":
                logging("Since you are logged-in as a 'root' user so after remediation the root ssh will be \
restricted, then you can login with '" + userAcc + "' user. Please fix it manually.")
                return None
            logging("'"+ userAcc + "' is a valid user account in the system for login other than root and " + username + " accounts,\
 so root should be restricted for using remote access.")
            return False
    logging("Do not force remediate the rule unless you have valid user account to login other than root and " + username + " user accounts.")
    return None

def fixRule38613():
        with open('/etc/ssh/sshd_config', "r") as fileContent:
            fileString = ""
            updatedString = False
            lastLine= ""
            for line in fileContent:
                if isL(line) and tokenMatchIC("PermitRootLogin" , line):
                    if not "# Cloud Raxak updated next line" in lastLine:
                        fileString += "# Cloud Raxak updated next line\n"
	    	    logging("Updating settings for permitting root login using remote access programs such as ssh.")
                    fileString += "PermitRootLogin no\n"
                    updatedString = True
                else:
                    fileString += line
                    lastLine=line
            if not(updatedString):
		if not tokenMatch('Cloud Raxak updated next line',lastLine):
			fileString += "\n# Cloud Raxak updated next line\n"
                fileString += "PermitRootLogin no\n"
        fout = None
	fout = open('/etc/ssh/sshd_config', "wt")
        if fout != None:
            fout.write(fileString)
            fout.close()

	#Enabling ssh service and run leves
	RunService("ssh")

def checkRule38614():
    #Checking ssh configuration file validity
    #If there are any errors, not restarting ssh
    if checkSSHDSyntax() == None:
	return None

    logging("Checking whether SSH daemon does not permit authentication using an empty password.")
    res = runOnShell('grep -iw PermitEmptyPasswords /etc/ssh/sshd_config  | grep -v "^#"')
    if (not res) or (re.search("no", res.split(" ")[1])):
	logging("The SSH daemon does not permit authentication using an empty password.")
	return True
    logging("The SSH daemon permits authentication using an empty password.")
    return False

def fixRule38614():
    if checkSSHDSyntax() == None:
        return None

    with open('/etc/ssh/sshd_config', "r") as f:
        s = ""
        flag = False
        lastLine= ""
        for line in f:
            if isL(line) and tokenMatch("PermitEmptyPasswords", line):
                if not tokenMatch("Cloud Raxak updated next line",lastLine):
                    s += "# Cloud Raxak updated next line\n"
		logging("Updating settings for not permitting authentication using an empty password.")
                s += "PermitEmptyPasswords no\n"
                flag = True
            else:
                s += line
                lastLine=line
        if not(flag):
            s += "\n# Cloud Raxak updated next line\n"
            s += "PermitEmptyPasswords no\n"
        fout = None
        try:
            fout = open('/etc/ssh/sshd_config', "wt")
            fout.write(s)
        except:
            pass
        finally:
            if (fout is not None):
                fout.close()

    #Enabling ssh service and run leves
    RunService("ssh")

def checkRule38615():
    #Checking ssh configuration file validity
    #If there are any errors, not restarting ssh
    if checkSSHDSyntax() == None:
        return None

    try:
	bannerFileName = runOnShell('grep -iw Banner /etc/ssh/sshd_config | grep -v "^#"').splitlines()[0]
	bannerFileName = bannerFileName.translate(string.maketrans("\n\t\r", "   "))
	bannerFileName = bannerFileName.split()[1]
    except IndexError:
        logging("The SSH daemon is not configured with a login banner.")
	return False

    if os.path.isdir(bannerFileName):
        logging("The SSH daemon is not configured with a login banner.")
        return False

    if os.path.exists(bannerFileName):
        logging("The SSH daemon is configured with a login banner.")
        return True
    else:
        logging("The SSH daemon is not configured with a login banner.")
        return False

def fixRule38615():
    if checkSSHDSyntax() == None:
        return None

    logging ("Checking banner file existence.")
    if not os.path.exists('/etc/issue'):
        logging("Creating banner file.")
        runOnShell ("touch /etc/issue")

    bannerFlag = False
    with open('/etc/ssh/sshd_config', "r") as data:
        sshConfigFileLine = ""
        lastLine = ""
        for line in data:
            if isL(line) and "Banner" in line:
                if not bannerFlag:
                    logging("Updating the SSH daemon configuration for login banner.")
                    if not tokenMatch("Cloud Raxak updated next line", lastLine):
                        sshConfigFileLine += "# Cloud Raxak updated next line\n"
                    sshConfigFileLine += "Banner /etc/issue\n"
                    bannerFlag = True
            else:
                sshConfigFileLine += line
                lastLine = line

    if not(bannerFlag):
	if not tokenMatch("Cloud Raxak updated next line", lastLine):
            sshConfigFileLine += "\n# Cloud Raxak updated next line\n"
        logging("Adding SSH daemon configuration for login banner.")
        sshConfigFileLine += "Banner /etc/issue\n"

    fout = open('/etc/ssh/sshd_config', "wt")
    if fout != None:
	fout.write(sshConfigFileLine)
        fout.close()

    #Enabling ssh service and run leves
    RunService("ssh")

def checkRule38616():
    # Checking ssh configuration file validity
    # If there are any errors, not restarting ssh
    if not checkSSHDSyntax():
	return None

    logging("Checking whether SSH daemon permits user for environment configuration changes.")
    res = runOnShell('grep -iw PermitUserEnvironment /etc/ssh/sshd_config | grep -v "^#"')
    res = res.translate(string.maketrans("\n\t\r", "   "))
    # 'PermitUserEnvironment' if commented in file functionality wise the rule works.
    if not res:
        logging("SSH daemon does not permit user for environment configuration changes.")
        return True
    checkPerm = res.split()
    if len(checkPerm) != 2:
        logging("SSH daemon configuration for permitting user environment configuration changes is not configured properly.")
        return False
    elif checkPerm[1] == "no":
        logging("SSH daemon does not permit user for environment configuration changes.")
        return True
    else:
        logging("SSH daemon permits user for environment configuration changes.")
        return False

def fixRule38616():
    if not checkSSHDSyntax():
        return None

    with open('/etc/ssh/sshd_config', "r") as fileData:
        changeLine = ""
        permitFlag = False
	lastLine = ""
        for line in fileData:
            if isL(line) and "PermitUserEnvironment" in line:
                if not permitFlag:
                    if not tokenMatch("Cloud Raxak updated next line",lastLine):
                        changeLine += "# Cloud Raxak updated next line\n"
		    logging("Updating configuration for not permitting users to change environment settings.")
                    changeLine += "PermitUserEnvironment no\n"
                    permitFlag = True
            else:
                changeLine += line
		lastLine = line
    if not permitFlag:
        logging("Adding configuration for not permitting users to change environment settings.")
        if not tokenMatch("Cloud Raxak updated next line",lastLine):
            changeLine += "\n# Cloud Raxak updated next line\n"
        changeLine += "PermitUserEnvironment no\n"
    writeFile('/etc/ssh/sshd_config',changeLine,'wt')
    # Enabling ssh service and run leves
    RunService("ssh")

def checkRule38617():
    # Checking ssh configuration file validity
    # If there are any errors, not restarting ssh
    if checkSSHDSyntax() == None:
        return None

    logging("Checking that only FIPS-approved ciphers are in use.")
    res = runOnShell('grep -iw Ciphers /etc/ssh/sshd_config | grep -v "^#"')

    if res == "":
        logging("The SSH daemon is not configured to use FIPS 140-2 approved ciphers.")
        return False

    res = res.split()
    result = res[1].split(",")
    result = filter(lambda ele: ele != "", result)
    # common cipher list
    commonSuportedCipherList = ["aes128-ctr","aes192-ctr","aes256-ctr","arcfour256", "arcfour128","aes128-cbc","3des-cbc",\
 "blowfish-cbc", "cast128-cbc","aes192-cbc","aes256-cbc", "arcfour"]
    if OsName.lower() == "ubuntu" or ((OsVersion >= (7,2)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
        # List of available Ciphers algorithems in Centos or Redhat >= 7.2 and ubuntu
        ciphersList = ["aes128-gcm@openssh.com", "aes256-gcm@openssh.com", "chacha20-poly1305@openssh.com"]
    elif(OsVersion >= (7,0) and OsVersion < (7,2) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
         ciphersList = ["aes128-gcm@openssh.com", "aes256-gcm@openssh.com"]
    else:
        # List of available Ciphers algorithems in Centos and Redhat 6.x
        ciphersList = ["rijndael-cbc@lysator.liu.se"]

    supportedCiphersList = ciphersList + commonSuportedCipherList
    for cipherElem in result:
        if cipherElem not in supportedCiphersList:
            logging("The SSH daemon is not configured to use FIPS 140-2 approved ciphers.")
            return False

    logging("The SSH daemon is configured to use FIPS 140-2 approved ciphers.")
    return True


def fixRule38617():
        if checkSSHDSyntax() == None:
            return None
        commonSuportedCipher = "Ciphers aes128-ctr,aes192-ctr,aes256-ctr,arcfour256,arcfour128,aes128-cbc,3des-cbc,blowfish-cbc,\
cast128-cbc,aes192-cbc,aes256-cbc,arcfour,"
        if OsName.lower() == "ubuntu" or ((OsVersion >= (7,2)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
            ciphersString = "aes128-gcm@openssh.com,aes256-gcm@openssh.com,chacha20-poly1305@openssh.com"
        elif(OsVersion >= (7,0) and OsVersion < (7,2) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
            ciphersString = "aes128-gcm@openssh.com,aes256-gcm@openssh.com"
        else:
            ciphersString = "rijndael-cbc@lysator.liu.se"

        supportedCiphersData = commonSuportedCipher + ciphersString
        with open('/etc/ssh/sshd_config', "r") as filehandler:
            ciphersData = ""
            flag = False
            lastLine = ""
            for cipherLine in filehandler:
                if isL(cipherLine) and cipherLine.lower() == "ciphers":
                    if not tokenMatch("Cloud Raxak updated next line",lastLine):
                        ciphersData += "# Cloud Raxak updated next line\n"
                    ciphersData += supportedCiphersData + "\n"
                    flag = True
                else:
                    ciphersData += cipherLine
                    lastLine = cipherLine
            if not(flag):
                if not tokenMatch("Cloud Raxak updated next line",lastLine):
                    ciphersData += "\n# Cloud Raxak updated next line\n"
                ciphersData += supportedCiphersData + "\n"

        fout = open('/etc/ssh/sshd_config', "wt")
        if fout != None:
            fout.write(ciphersData)
            fout.close()

        # Reloading the ssh service to effect configuration file changes.
        RunService("ssh")


def checkRule38618():
	if os.path.exists('/usr/sbin/avahi-daemon') == False:
		logging("avahi-daemon service is not installed.")
		return True

	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		avh_skt_status = runOnShell('systemctl is-active avahi-daemon.socket').replace('\n','')
		avh_srv_status = runOnShell('systemctl is-active avahi-daemon.service').replace('\n','')
		avh_skt_lvl = runOnShell('systemctl is-enabled avahi-daemon.socket').replace('\n','')
		avh_srv_lvl = runOnShell('systemctl is-enabled avahi-daemon.service').replace('\n','')

		if (avh_skt_status == "active" or avh_srv_status == "active" or avh_skt_lvl == "enabled" or avh_srv_lvl == "enabled"):
			logging("avahi service is running.")
			return False
	else:
		if OsName.lower() == "ubuntu":
			service_at_level = "sysv-rc-conf --list avahi-daemon"
			logging("service and init.d are used for start/stop/restart/reload the service, hence checking the status of service using both commands.")	
			status_from_service_cmd = runOnShell('service avahi-daemon status')
			status_from_service_cmd = status_from_service_cmd.translate(string.maketrans("\n\t\r", "   "))
			for token in ["start/running,","running:"]:
				if token in status_from_service_cmd:
					return False 

			status_from_init_cmd = runOnShell('/etc/init.d/avahi-daemon status')	
			status_from_init_cmd = status_from_init_cmd.translate(string.maketrans("\n\t\r", "   "))
			for token in ["start/running,","is running"]:
				if token in status_from_init_cmd:
					return False 
		else:
			service_at_level = "chkconfig --list avahi-daemon"
			logging("Checking the status of avahi-daemon service in runtime configuration.")
			service_status = runOnShell('service avahi-daemon status')
			service_status = service_status.translate(string.maketrans("\n\t\r", "   "))
			if "unrecognized service" not in service_status:
				if tokenMatch("running...", service_status):
					return False
			#As init.d command is working same as service command in case of red hat
			#hence not using this in case of redhat.	
			if not OsName.lower() == 'redhat':
				status_from_init_cmd = runOnShell('/etc/init.d/avahi-daemon status')	
				status_from_init_cmd = status_from_init_cmd.translate(string.maketrans("\n\t\r", "   "))
				if tokenMatch("running...", status_from_init_cmd):
					return False

		logging("Checking the status of avahi-daemon service in system boot configuration.")
		service_at_level = runOnShell(service_at_level)
		service_at_level = service_at_level.translate(string.maketrans("\n\t\r", "   "))
		if OsName.lower() == "ubuntu":
			service_at_level_repl = service_at_level.replace(" ",'')
			if len(service_at_level_repl)  == len('avahi-daemon') and tokenMatchIC("avahi-daemon",service_at_level):
				logging("avahi-daemon service is disabled in system boot configuration.")
				return True
			if "on" in service_at_level_repl.replace("avahi-daemon",''):
				logging("avahi-daemon service is enabled in system boot configuration.")
				return False
		else:
			if not(tokenMatchIC("avahi-daemon 0:off 1:off 2:off 3:off 4:off 5:off 6:off", service_at_level)):
				return False

	logging("avahi service is disabled.")
	return True

def fixRule38618():
	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		runOnShell("systemctl disable avahi-daemon.socket ; systemctl stop avahi-daemon.socket")
		runOnShell("systemctl disable avahi-daemon.service ; systemctl stop avahi-daemon.service")
	else:
		if OsName.lower() == "ubuntu":
			logging("Disabling the avahi daemon service in system boot and runtime configuration.")
			runOnShell('sysv-rc-conf --level 0123456S avahi-daemon off') 
			if 'stop/waiting' not in runOnShell('service avahi-daemon status'):
				runOnShell('service avahi-daemon stop')
		else:
			logging("Disabling the avahi daemon service in system boot and runtime configuration.")
			runOnShell('chkconfig --level 0123456 avahi-daemon off') 
			if 'stopped' not in runOnShell('service avahi-daemon status'):
				runOnShell('service avahi-daemon stop')

		if not OsName.lower() == 'redhat':
			status =  runOnShell('/etc/init.d/avahi-daemon status')
			for token in ["start/running,","is running"]:
				if token in status:	
				    runOnShell('/etc/init.d/avahi-daemon stop')


def checkRule38619():
    # According to stig the command was "find /root /home -xdev -name .netrc"
    # which was only searching file in root directory but not in /home directory 
    # hence removed -xdev and included -iname and type f to find files in both /root and /home all users directory. 
    logging("Checking file name '.netrc' exists inside a user's home directory.")
    res = runOnShell('find /root /home -iname ".netrc" -type f')
    if res == "":
        logging("No file name with extension '.netrc' exists inside user's home directory.")
        return True
    logging("File(s) with extension '.netrc' exist inside user's home directory.")
    return False

def fixRule38619():
    logging("Checking file name '.netrc' exist inside a user's home directory.")
    res = runOnShell('find /root /home -iname ".netrc" -type f')
    for line in res.splitlines():
        if isL(line):
            logging("Removing file '.netrc' from user's home directory.")
            runOnShell('rm -f %s' % line)


def checkRule38620():
    if not CheckService("ntpd"):
	return False

    # Restart is required before checking NTP servers availability in NTP configuration file
    if OsName.lower() == "ubuntu":
        runOnShell("service ntp restart", False)
    elif OsVersion >= (7,0):
        runOnShell("systemctl restart ntpd.service", False)
    else:
        runOnShell("service ntpd restart", False)

    logging("Checking if ntp servers are available in NTP configuration file.")
    try:
        if int(runOnShell("ntpq -p | wc -l")) == 1:
            logging("NTP servers are not available in NTP configuration file to synchronize the system clock. Please re-mediate \
the rule V-38621 to get NTP servers in NTP configuration file.")
            return None
    except ValueError:
        logging("NTP servers are restricted in NTP configuration file or due to outside of NTP configuration file. Please fix it manually.")
        return None

    logging("The system clock is synchroized daily once with NTP server.")
    return True

def fixRule38620():
    if not CheckPackage("ntpd", True):
        InstallPackage("ntp")

    #Enabling all ntp service and run levels too.
    RunService("ntpd")

    logging("Checking if ntp servers are available in NTP configuration file.")
    try:
        if int(runOnShell("ntpq -p | wc -l")) == 1:
            logging("NTP configuration file is not configured with NTP servers.")
            return None
    except ValueError:
        logging("NTP servers should not be restricted in NTP configuration file.")
        return None

def checkRule38621():
    if not CheckPackage("ntpd", True):
	logging("NTP package is not avaialble on the system. Please re-mediate the rule V-38620 to install the ntp package.")
	return None

    logging ("Checking if NTP configuration file is available on the system.")
    if not os.path.exists("/etc/ntp.conf"):
        logging("NTP configuration file is not available. Please fix it manually.")
        return None

    # Restart is required before servers existence check
    # Which is useful for 'ntpq -p' command
    if OsName.lower() == "ubuntu":
        runOnShell("service ntp restart", False)
    elif OsVersion >= (7,0):
        runOnShell("systemctl restart ntpd.service", False)
    else:
        runOnShell("service ntpd restart", False)

    logging("Checking 'ntp' server configuration for time synchronization.")
    try:
        if int(runOnShell("ntpq -p | wc -l")) == 1:
            logging("'ntp' server configuration for time synchronization does not exist.")
            return False
    except ValueError:
        logging("NTP servers are restricted in NTP configuration file or due to outside of NTP configuration file. Please fix it manually.")
        return None

    logging("'ntp' server configuration for time synchronization exists.")
    return True

def fixRule38621():
    if not CheckPackage("ntpd", True):
	logging("NTP package is not avaialble on the system. Please re-mediate the rule V-38620 to install the ntp package.")
	return None

    logging ("Checking if NTP configuration file is available on the system.")
    if not os.path.exists("/etc/ntp.conf"):
        logging("NTP configuration file is not available. Please fix it manually.")
        return None

    machineName = OsName.lower()
    if OsName.lower() == "redhat":
	machineName = "rhel"

    logging("Checking 'ntp' server configuration for time synchronization.")
    try:
        if int(runOnShell("ntpq -p | wc -l")) == 1:
            with open("/etc/ntp.conf", "a") as ntpFileRef:
                logging("Adding server configuration for time synchronization inside the ntp configuration file.")
                # default to centOS pool NTP files. Can be changed to other free servers
	        # Should add servers inside the NTP configuration file along with CloudRaxak's comment
                ntpFileRef.write("# Cloud Raxak updated next block.\n")
                ntpFileRef.write("server 0."+ machineName  + ".pool.ntp.org iburst\n")
                ntpFileRef.write("server 1."+ machineName  + ".pool.ntp.org iburst\n")
                ntpFileRef.write("server 2."+ machineName  + ".pool.ntp.org iburst\n")
                ntpFileRef.write("server 3."+ machineName  + ".pool.ntp.org iburst\n")
                if machineName == "ubuntu":
                    ntpFileRef.write("# Use Ubuntu's ntp server as a fallback.\n")
                    ntpFileRef.write("server ntp.ubuntu.com\n")
                ntpFileRef.write("\n")
                ntpFileRef.close()
    except ValueError:
        logging("NTP servers are restricted on the system.")
        return None

    # We have to open, save, and quit in vi editor to affect the changes before restart the ntp service 
    os.system('echo ":wq" | vi /etc/ntp.conf > /dev/null 2>&1')
    RunService("ntpd")

def checkRule38622():
	# The File "/etc/postfix/main.cf" is not existed mark the rule as successful
	logging("Checking if postfix (Mail Transfer Agent) service is installed.")
	if not os.path.exists('/etc/postfix/main.cf'):
	    logging("The postfix (Mail Transfer Agent) service is not installed or The file path /etc/postfix/main.cf does not exist." )
	    return True

	logging("Checking whether the system is an authorized mail relay host.")
	if OsName.lower() == "ubuntu":
	    relayRestriction = runOnShell("grep -w ^smtpd_relay_restrictions /etc/postfix/main.cf | grep -w permit_mynetworks | grep -v '^#'")
	else:
	    relayRestriction = "This is dummy relay restriction for other OS."

	defaultNetworkFlag = True
	defaultNetwork = runOnShell("grep -w ^mynetworks /etc/postfix/main.cf | awk -F= '{print $2}'")
	if defaultNetwork == '':
	    logging("System is not an authorized mail relay host.")
	    defaultNetworkFlag = False
	defaultNetwork = defaultNetwork.translate(string.maketrans("\n\t\r", "   ")).strip()
	if relayRestriction != '' and defaultNetworkFlag:
	    defaultNetwork_list = defaultNetwork.split()
	    count = 0
	    for defaultNetwork_value in defaultNetwork_list:
	        if OsName.lower() == "ubuntu":
	            if "127.0.0.0/8" in defaultNetwork_value or \
                       "[::ffff:127.0.0.0]/104" in defaultNetwork_value or \
                       "[::1]/128" in defaultNetwork_value:
	                count += 1
	        else:
	            if "127.0.0.0/8" in defaultNetwork_value or "127.0.0.1" in defaultNetwork_value or "localhost" in defaultNetwork_value:
	                count += 1

	    if len(defaultNetwork_list) != count:
	        logging("System is an authorized mail relay host. Hence this rule is not applicable.")
	        return True
	elif defaultNetworkFlag:
	    logging("'postfix' is not configured properly. Please configure it manually.")
	    return None

	res = runOnShell("grep -w ^inet_interfaces /etc/postfix/main.cf | grep -v '^#'")
	if len(res.strip().splitlines()) > 1:
	    logging("Duplicate entry found of 'postfix' for configuration to accept message from local system.")
	    return False

	if res == "":
	    logging("postfix' is not configured to accept message from local system.")
	    return False
	res = "".join(res.split())
	if res == "inet_interfaces=localhost":
	    logging("'postfix' is configured to accept message from local system.")
	    return True

	logging("'postfix' is not configured to accept message from local system.")
	return False

def fixRule38622():
        logging("Checking whether the system is an authorized mail relay host.")
        if OsName.lower() == "ubuntu":
            relayRestriction = runOnShell("grep -w ^smtpd_relay_restrictions /etc/postfix/main.cf | grep -w permit_mynetworks | grep -v '^#'")
        else:
            relayRestriction = "This is dummy relay restriction for other OS."
	defaultNetworkFlag = True
        defaultNetwork = runOnShell("grep -w ^mynetworks /etc/postfix/main.cf | awk -F= '{print $2}'")
        if defaultNetwork == '':
            logging("System is not an authorized mail relay host.")
	    defaultNetworkFlag = False
        defaultNetwork = defaultNetwork.translate(string.maketrans("\n\t\r", "   ")).strip()
        if relayRestriction != '' and defaultNetworkFlag:
            defaultNetwork_list = defaultNetwork.split()
            count = 0
            for defaultNetwork_value in defaultNetwork_list:
                if OsName.lower() == "ubuntu":
                    if "127.0.0.0/8" in defaultNetwork_value or \
                       "[::ffff:127.0.0.0]/104" in defaultNetwork_value or \
                       "[::1]/128" in defaultNetwork_value:
                        count = count + 1
                else:
                    if "127.0.0.0/8" in defaultNetwork_value or "127.0.0.1" in defaultNetwork_value or "localhost" in defaultNetwork_value:
                        count = count + 1

            if len(defaultNetwork_list) != count:
                logging("System is an authorized mail relay host. Hence this rule is not applicable.")
                return True
        elif defaultNetworkFlag:
            logging("'postfix' is not configured properly. Please configure it manually.")
            return None

        # Updating the inet_interface paramter value.
        with open('/etc/postfix/main.cf', "r") as fileContent:
            newLine = ""
            flag = False
            lastLine = ""
            for line in fileContent:
                if isL(line) and re.search("inet_interfaces", line):
	            if not flag:
                        if not tokenMatch("inet_interfaces=localhost\n",line.strip()) and not tokenMatch("# Cloud Raxak updated next line",lastLine): 
                            newLine += "# Cloud Raxak updated next line\n"
                        newLine += "inet_interfaces = localhost\n"
                        flag = True
                else:
                    newLine += line
                    lastLine = line
            if not flag:
                if not tokenMatch("# Cloud Raxak updated next line",lastLine):
                    newLine += "# Cloud Raxak updated next line\n"
                newLine += "inet_interfaces = localhost\n"

        fout = None
        try:
            fout = open('/etc/postfix/main.cf', "wt")
            fout.write(newLine)
        finally:
            if (fout is not None):
                fout.close()

def checkRule38623():
	logging("Checking the file permissions for all log files generated by rsyslog.")
	if OsName.lower() == "ubuntu":
		check_log_file = runOnShell("cat /etc/rsyslog.d/*.conf | grep /var/log | grep -v '#'")
	else:
		if not os.path.exists('/etc/rsyslog.conf'):
			logging("The file path /etc/rsyslog.conf does not exist.")
			return True
		check_log_file = runOnShell("cat /etc/rsyslog.conf | grep /var/log | grep -v '#'")

	permission_flag = True
	for line in check_log_file.splitlines():
	    try:
		if (OsName.lower() == 'ubuntu' and isL(line)):
			line = line.translate(string.maketrans("\n\t\r", "   "))
			rfile = line.split(" ", 1)[1].lstrip(' -,"')
		elif isL(line) :
			rfile = line.split(" ", 1)[1].lstrip(" -")
		if os.path.exists(rfile):
			perm = runOnShell ('stat -c "%a" '+ rfile)
			tmpOct = int(perm, 8)
			if tmpOct & 07177:
				permission_flag = False
	    except:
		continue
	if not permission_flag:
		logging("File permissions for log files are not configured correctly.")
		return False
	logging("File permissions for all log files are configured correctly.")
	return True 
    
def fixRule38623():
	logging("Checking the file permissions for all log files generated by rsyslog.")
        if OsName.lower() == "ubuntu":
                check_log_file = runOnShell("cat /etc/rsyslog.d/*.conf | grep /var/log | grep -v '#'")
        else:
                check_log_file = runOnShell("cat /etc/rsyslog.conf | grep /var/log | grep -v '#'")
        logging("Changing the file permissions for log files generated by rsyslog.")
        for line in check_log_file.splitlines():
            try:
                if (OsName.lower() == 'ubuntu' and isL(line)):
                        line = line.translate(string.maketrans("\n\t\r", "   "))
                        rfile = line.split(" ", 1)[1].lstrip(' -,"')
                elif isL(line):
                        rfile = line.split(" ", 1)[1].lstrip(" -")
                if os.path.exists(rfile):
                        perm = runOnShell ('stat -c "%a" '+ rfile)
                        tmpOct = int(perm, 8)
                        if tmpOct & 07177:
                                runOnShell('chmod 0600 ' + rfile)
                                if '/var/log/boot.log' in rfile:
                                        logging("The permissions of file '/var/log/boot.log' will revert after reboot.")
            except:
                continue

def checkRule38624():
	logging("Checking whether system is configured to rotate logs daily.")
	if not CheckService("crond") or not CheckPackage("logrotate"):
		return False

	if not os.path.exists('/etc/cron.daily/logrotate'):
		if OsName.lower() == "ubuntu":
                        logging("File path /etc/cron.daily/logrotate does not exist. The logrotate script is necessary to be available \
inside the cron.daily directory. The daily cron job invokes this script to rotate system logs. Please fix this manually.")
		        return None
		# In case of Centos, Redhat, and Amazon Linux ami Machines, if logrotate is not available in /etc/cron.daily
		# then reinstalling logrotate can fix this.
		logging("File path /etc/cron.daily/logrotate does not exist.")
		return False
	
	# If the files below are not available, we can purge the respective package and reinstall it. In case of centos,redhat
        # and Amazon linux ami we can reinstall the packages to fix this.
	for filePath in ['/etc/crontab', '/etc/logrotate.conf']:
		if not os.path.exists(filePath):
			logging("File path " + filePath + " does not exist.")
			return False
	
	checkAnacron = runOnShell('grep -w /etc/cron.daily /etc/anacrontab | grep -v "^#"')
	checkCronString = runOnShell('grep -w /etc/cron.daily /etc/crontab | grep -v "^#"')
	checkCron = checkCronString.splitlines()
	if not checkCron and not checkAnacron:
                logging("The system is not scheduled for daily rotation of logs.")
		return False
        if (not re.search(r'(\/etc\/cron.daily\/logrotate)|(\/etc\/cron.daily\n?\s+)', checkCronString, re.M|re.I) and 
            not re.search(r'(\/etc\/cron.daily\/logrotate)|(\/etc\/cron.daily\n?\s+)', checkAnacron, re.M|re.I)):
		logging("Cron is not scheduled for daily rotation of logs.")
     		return False
        anacronFlag = False
        if checkAnacron:
        	checkAnacronSplit = checkAnacron.split()
		if len(checkAnacronSplit) > 2:
			if checkAnacronSplit[0].isdigit() and checkAnacronSplit[1].isdigit() and checkAnacronSplit[0] == '1':
				anacronFlag = True
	cronFlag = False
	if checkCronString:
		hourExpOne = "\*\/\d?\d"
		hourExpTwo = "\d?\d,\d?\d"
		hourExpThree = "\d?\d-\d?\d"
		hourExpFour = "\d?\d-\d?\d\/\d?\d"
		hourExpFive = "\d?\d"
		countWrongEntry = 0
		for line in checkCron:
			checkTime = line.split()
			try:
				if (re.search(hourExpOne, checkTime[1], re.M|re.I) or re.search(hourExpTwo, checkTime[1], re.M|re.I) or 
					re.search(hourExpThree, checkTime[1], re.M|re.I) or re.search(hourExpFour, checkTime[1], re.M|re.I) or 
					re.search(hourExpFive, checkTime[1], re.M|re.I)):
					checkDigitList = re.findall('\d+', checkTime[1])
					for digit in checkDigitList:
						if int(digit) > 23 or int(digit) < 0:
							countWrongEntry += 1
				# If the expression does not match with the configuration it is also a wrong entry.
				else:
					countWrongEntry += 1
			except (ValueError, IndexError):
				logging("The cron job for rotation of logs is not configured properly.")
				return False
		if not countWrongEntry:
			cronFlag = True
	checkDaily = runOnShell('grep -w daily /etc/logrotate.conf | grep -v "^#"')
	if (cronFlag or anacronFlag) and checkDaily:
		logging("The system is configured to rotate logs daily.")
		return True
	elif not cronFlag and not anacronFlag:
                logging("The cron job for rotation of logs is not configured properly.")
		return False
	else:
		logging("The system is not configured to rotate logs daily.")
		return False

def fixRule38624():
    # Handling yum plugins so that yum works properly.
    if OsName.lower() == "amazon linux ami":
        yumFlag = False                        # To know whether yum is enabled or not
        yumFlagStr = "plugins=0"               # yumFlag enabling string
        # open the /etc/yum.conf file for searching yumString
        with open("/etc/yum.conf", "r") as yumConfigFile:
            file_data = ""
            lines = yumConfigFile.readlines()
            for line in lines:
                if isL(line) and tokenMatchIC(yumFlagStr, line):
                    yumFlag = True
                    break

        if not yumFlag:
            # If YUM flag is not enabled, enable it
            setPluginParamYum(False)

    if OsName.lower() == "ubuntu":
        packageList = ['cron', 'logrotate']
    else:
        packageList = ['crontabs', 'logrotate']
    for package in packageList:
        if not CheckPackage(package):
            if not InstallPackage(package):
                return None

    if not CheckService("crond"):
        RunService("crond")
    
    if not os.path.exists('/etc/cron.daily/logrotate'):
        if OsName.lower() == "ubuntu":
            logging("File path /etc/cron.daily/logrotate does not exist. The logrotate script is necessary to be available \
#inside the cron.daily directory. The daily cron job invokes this script to rotate system logs. Please fix this manually.")
            return None
        else:
            runOnShell("yum -y reinstall logrotate", False)

    if not os.path.exists('/etc/crontab'):
        if OsName.lower() == "ubuntu":
            if "dpkg was interrupted" in runOnShell('apt-get -y purge cron', False):
                logging("dpkg is not properly configured, it needs to be configured properly using \
command 'dpkg --configure -a'. Please fix this manually.")
                return None
            if not InstallPackage("cron"):
                logging("Something went wrong while installing package cron. Please fix this manually.")
                return None
            # Need to run service after installation since it is off on other runlevels.
            RunService("cron")
        else:
             runOnShell("yum -y reinstall crontabs", False)

    if not os.path.exists('/etc/logrotate.conf'):
        if OsName.lower() == "ubuntu":
            if "dpkg was interrupted" in runOnShell('apt-get -y purge logrotate', False):
                logging("dpkg is not properly configured, it needs to be configured properly using \
command 'dpkg --configure -a'. Please fix this manually.")
                return None
            if not InstallPackage("logrotate"):
                logging("Something went wrong while installing package logrotate. Please fix this manually.")
                return None
        else:
            runOnShell("yum -y reinstall logrotate", False)

    checkDaily = runOnShell('grep -w daily /etc/logrotate.conf | grep -v "^#"')
    
    if not checkDaily:
        dailyFlag = False
        with open('/etc/logrotate.conf','r') as fileData:
            changeLine = ""
            lastLine = ""
            for line in fileData:
                if isL(line) and ("weekly" in line or "hourly" in line):
                    if not dailyFlag:
                        logging("Updating the logrotate configuration for rotating log files daily.")
                        if not tokenMatch('Cloud Raxak updated next line', line):
                            changeLine += "# Cloud Raxak updated next line\n"
                        changeLine += "daily\n"
                        dailyFlag = True
                else:
                    changeLine += line
                    lastLine = line  
        if not dailyFlag:
            changeLine = "# Cloud Raxak updated next line\n" + "daily\n" + changeLine
        writeFile('/etc/logrotate.conf', changeLine , 'wt')


    checkCron = runOnShell('grep -w cron.daily /etc/crontab | grep -v "^#"').splitlines()
    hourExpOne = "\*\/\d?\d"
    hourExpTwo = "\d?\d,\d?\d"
    hourExpThree = "\d?\d-\d?\d"
    hourExpFour = "\d?\d-\d?\d\/\d?\d"
    hourExpFive = "\d?\d"
    cronFlag = False
    # The below flag is used to alter /etc/crontab file only when any one of the entry is wrong. File remains untouched if every entry is alright.
    dndFlag = False
    with open('/etc/crontab', "r") as fileData:
        changeLine = ""
        lastLine = ""
        for line in fileData:
            if isL(line) and "cron.daily" in line:
                checkTime = line.split()
                searchIndex = re.search(r'\*', line, re.M|re.I)
                charIndex = str(searchIndex.group(0))
                getIndex = line.index(charIndex)
                new = line[getIndex:]
                if (re.search(hourExpOne, checkTime[1], re.M|re.I) or re.search(hourExpTwo, checkTime[1], re.M|re.I) or 
                    re.search(hourExpThree, checkTime[1], re.M|re.I) or re.search(hourExpFour, checkTime[1], re.M|re.I) or 
                    re.search(hourExpFive, checkTime[1], re.M|re.I)):
                    checkDigitList = re.findall('\d+', checkTime[1])
                    for digit in checkDigitList:
                        if int(digit) >= 24 or int(digit) < 0:    
                            if not tokenMatch("Cloud Raxak updated next line",lastLine):
                                changeLine += "# Cloud Raxak updated next line\n"
                            logging("Scheduling cron for rotating logs daily at 3.00 am.")
                            changeLine += "0 3 " + new + "\n"
                            cronFlag = True
                        else:
                            changeLine += line
                            lastLine = line
                            dndFlag = True
                else:
                    if not tokenMatch("Cloud Raxak updated next line",lastLine):
                        changeLine += "# Cloud Raxak updated next line\n"
                    logging("Scheduling cron for rotating logs daily at 3.00 am.")
                    changeLine += "0 3 " + new + "\n"
                    cronFlag = True
            else:
                changeLine += line
                lastLine = line
    checkCronString = runOnShell('grep -w /etc/cron.daily /etc/crontab | grep -v "^#"', False)
    if (not cronFlag and not dndFlag) or (not re.search(r'(\/etc\/cron.daily\/logrotate)|(\/etc\/cron.daily\n?\s+)', checkCronString , re.M|re.I)):
        logging("Scheduling cron for rotating logs daily at 3.00 am.")
        if not tokenMatch("Cloud Raxak updated next line",lastLine):
            changeLine += "# Cloud Raxak updated next line\n"
        if OsName.lower() == "centos" or OsName.lower() == "redhat":
            changeLine += "0 3 * * * root bash /etc/cron.daily/logrotate\n"
        else:
            changeLine += "0 3   * * *   root  bash /etc/cron.daily/logrotate \n"
    writeFile('/etc/crontab', changeLine, 'wt')

    # Reverting yum flag
    if (OsName.lower() == "amazon linux ami") and (not yumFlag):
        setPluginParamYum(True)

def checkRule38625():
	logging("Checking if LDAP is configured on system.")
	res = runOnShell('ldapsearch -x -ZZ')
	if ("Can't contact LDAP server (-1)" in res) or ("not found" in  res) or ("not installed" in res):
	    #If LDAP server is not configured, return True because we no need to go forward
	    logging ("LDAP server is not configured on the system.")
	    return True

	if OsName.lower() == "ubuntu":
	    if "Protocol error (2)" in res:
	        logging("LDAP is not configured to use TLS for all transactions. Please configure TLS manually.")
	        return None
	    logging("LDAP is configured to use TLS for all transactions.")
	    return True
	else:
	    if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		if not os.path.exists("/etc/nslcd.conf"):
		    logging("nslcd configuration file does not exist, so the rule is not applicable.")
		    return 3
		configFileName = "/etc/nslcd.conf"
	    else: 
		if not os.path.exists("/etc/pam_ldap.conf"):
		    logging("The system LDAP configuration file does not exist, so the rule is not applicable.")
		    return 3
		configFileName = "/etc/pam_ldap.conf"
	    logging("Checking if LDAP is configured to use TLS for all transactions.")
	    res = runOnShell('grep -w start_tls ' + configFileName + ' | grep -v "^#"')
	    if not(res == ""):
                logging("LDAP is configured to use TLS for all transactions.")
                return True
            logging("LDAP is not configured to use TLS for all transactions.")
            return False

def fixRule38625():
	logging("TLS configuration is missing for LDAP, Please contact ldap Administrator for the same and configure TLS manually.")
	return None

def checkRule38626():
	logging("Checking if LDAP is configured on system.")
	res = runOnShell('ldapsearch -x')
	if ("Can't contact LDAP server (-1)" in res) or ("not found" in  res) or ("not installed" in res):
	    #If LDAP server is not configured, return True because we no need to go forward
	    logging ("LDAP server is not configured on the system.")
	    return True

	if OsName.lower() == "ubuntu":
		if not os.path.exists("/etc/ldap/ldap.conf"):
		    logging("The system LDAP configuration file does not exist, so the rule is not applicable.")
		    return 3
		logging("Checking if TLS is configured with trust certificates.")
		res = runOnShell('grep -w TLS_CACERT /etc/ldap/ldap.conf| grep -v "^#"')
		if res == "":
			logging("TLS is not configured with trust certificates.")
			return False
		logging("TLS is configured with trust certificates.")
		return True	
	else:
	    if ( ( OsVersion >= (7,0) ) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat' ) ):
		if not os.path.exists("/etc/nslcd.conf"):
		    logging("The system LDAP configuration file does not exist, so the rule is not applicable.")
		    return 3
		logging("Checking if TLS is configured with trust certificates.")
		res = runOnShell('grep -w tls_cacertdir /etc/nslcd.conf | grep -v "^#"')
            else:
		if not os.path.exists("/etc/pam_ldap.conf"):
		    logging("The system LDAP configuration file does not exist, so the rule is not applicable.")
		    return 3
		logging("Checking if TLS is configured with trust certificates.")
		res = runOnShell('grep -w tls_cacertdir /etc/pam_ldap.conf | grep -v "^#"')
	    if not(res == ""):
                logging("TLS is configured with trust certificates.")
                return True
            logging("TLS is not configured with trust certificates.")
            return False

def fixRule38626():
	if OsName.lower() == "ubuntu":
		file_name = "/etc/ldap/ldap.conf"
		token_add = "TLS_CACERT /etc/ssl/certs/ca-certificates.crt"
	else:
	    if ( ( OsVersion >= (7,0) ) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat' ) ):
		file_name = "/etc/nslcd.conf"
		token_add = "tls_cacertdir /etc/pki/tls/CA"
	    else: 
		file_name = "/etc/pam_ldap.conf"
		token_add = "tls_cacertdir /etc/pki/tls/CA"
	if not os.path.exists(file_name):
	    logging("The system LDAP configuration file does not exist, so the rule is not applicable.")
	    return 3
        with open(file_name, "r") as f:
            flag = False
            s = ""
            lastLine = ""
	    logging("Updating TLS configuration with trust certificates.")
            for line in f:
                if isL(line) and "cert" in line:
                    if not tokenMatch('Cloud Raxak updated next line',lastLine):
                        s += "# Cloud Raxak updated next line\n"
                    s += token_add + "\n"
                    flag = True
                else:
                    s += line
                    lastLine = line
            if not(flag):
                s += "# Cloud Raxak updated next line\n"
                s += token_add + "\n"
            fout = None
            try:
                fout = open(file_name, 'wt')
                fout.write(s)
            finally:
                if fout is not None:
                    fout.close()
        
def checkRule38627():
    logging("Checking 'openldap-servers' package is installed on system.")
    if OsName.lower() == "ubuntu":
        ldap_server_package = runOnShell('dpkg -s slapd >/dev/null 2>&1; echo $?')
        default_domain = 'dc=nodomain'
        ldap_service_status = "is running"
    else:
        ldap_server_package = runOnShell('rpm -q openldap-servers >/dev/nul 2>&1; echo $?')
        default_domain = 'dc=my-domain'
        ldap_service_status = "running"
    # check for Package openldap-servers install or not.
    if not int(ldap_server_package):
        # service slapd is running or not.
        logging("Check whether ldap is configured on your system.")
	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat' )):
            res = runOnShell('systemctl status slapd.service')
            slpad_service = filter(lambda element:re.search(r'Active', element), res.split('\n'))[0]
        else:
            slpad_service = runOnShell('service slapd status')
        if ldap_service_status in slpad_service:
            #Check for domain name is default demain name or not.
            check_domain = runOnShell('ldapsearch -Y EXTERNAL -H ldapi:/// -b cn=config |grep olcRootDN |grep "dc="')
            for line in check_domain.split("\n"):
                if "olcRootDN" in line:
                    domain_name = line.split(" ")
                    domain_name = "".join(domain_name[1])
                    domain_name = domain_name.split(',')
                    if default_domain in domain_name:
                        if "dc=com" in domain_name or OsName.lower() == "ubuntu":
                            logging("'openldap-servers' is installed but it is not configured in the system.")
                            return False
                    logging("'openldap-servers' is installed and configured in the system. Please remove it manually.")
                    return None
        else:
            logging("Slapd package is installed but openldap-servers is not in use as the slapd service is not working.")
            return False
    else:
        logging("'openldap-servers' is not installed on the system.")
        return True

def fixRule38627():
    logging("Checking 'openldap-servers' package is installed on system.")
    if OsName.lower() == "ubuntu":
        ldap_server_package = runOnShell('dpkg -s slapd >/dev/null 2>&1; echo $?')
        default_domain = 'dc=nodomain'
        ldap_service_status = "is running"
        remove_server_package = "dpkg -P --force-all slapd"
    else:
        ldap_server_package = runOnShell('rpm -q openldap-servers >/dev/nul 2>&1; echo $?')
        default_domain = 'dc=my-domain'
        ldap_service_status = "running"
        remove_server_package = "rpm -e openldap-servers --nodeps"
    # check for Package openldap-servers install or not.
    if not int(ldap_server_package):
        # service slapd is running or not.
        logging("Check whether ldap is configured on your system.")
	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat' )):
            res = runOnShell('systemctl status slapd.service')
            slpad_service = filter(lambda element:re.search(r'Active', element), res.split('\n'))[0]
        else:
            slpad_service = runOnShell('service slapd status')
        if ldap_service_status in slpad_service:
            #Check for domain name is default demain name or not.
            check_domain = runOnShell('ldapsearch -Y EXTERNAL -H ldapi:/// -b cn=config |grep olcRootDN |grep "dc="')
            for line in check_domain.split("\n"):
                if "olcRootDN" in line:
                    domain_name = line.split(" ")
                    domain_name = "".join(domain_name[1])
                    domain_name = domain_name.split(',')
                    if default_domain in domain_name:
                        if "dc=com" in domain_name or OsName.lower() == "ubuntu":
                            logging("Since the ldap configuration has default domain name that means ldap is not configured on your system. Removing 'openldap-servers' from your system.")
                            runOnShell(remove_server_package)
                            break
                    logging("'openldap-servers' is installed and configured on the system. Please remove it manually.")
                    return None
        else:
            logging("Since the slapd service is not working that means 'openldap-servers' is not in use. Hence, removing the 'openldap-servers package'.")
            runOnShell(remove_server_package)


def checkRule38628():
	if CheckService("auditd"):
		return True

	return False		

def fixRule38628():
        if not InstallPackage("audit"):
            return None

	RunService("auditd",False)


def checkRule38629(val = 15):
    if check_gui_system():
        return True
    logging("Checking if the idle time-out value is more than 15 minutes.")
    if OsName.lower() == "ubuntu" or ((OsName.lower() == "redhat" or OsName.lower() == "centos") and OsVersion >= (7,0)):
        getIdledelay = "gsettings get org.gnome.desktop.session idle-delay | awk -F\" \" '{ print $2 }'"
        getLockdelay = "gsettings get org.gnome.desktop.screensaver lock-delay | awk -F\" \" '{ print $2 }'"
        # To Check the screensaver mandatory use status.
        gconf_golbal_users(getIdledelay)
        idledelayDict = commandsOutDict
        gconf_golbal_users(getLockdelay)
        lockdelayDict = commandsOutDict
        usersInfo = ""
        usersIdleTime = ""
        usersLockTime = ""
        for (lockUserName, idleDelay), (idleUserName, lockDelay) in zip(idledelayDict.items(), lockdelayDict.items()):
            if lockUserName == idleUserName:
                if "not found" in idleDelay or "not found" in lockDelay:
                    logging( "GSettings schemas are not installed on the system.")
                    return False
                elif "No value set" in idleDelay or "No value set" in lockDelay:
                    logging("The current idle time-out value does not exist.")
                    return False
                try:
                    idledelayTimeOfGuser = int(idleDelay)
                    # Checking the idle-delay time is set to "Never".
                    if(idledelayTimeOfGuser == 0):
                         usersIdleTime += ", " + idleUserName
                except(ValueError, TypeError):
                    logging("The idle-delay time is not configured properly need to fix it manually.")
                    return None
	        try:
                    lockdelayTimeOfGuser = int(lockDelay)
                    # Checking the lock-delay time is set to "Screen turns off".
                    if(lockdelayTimeOfGuser == 0):
                        usersLockTime += ", " + lockUserName
                except(ValueError, TypeError):
                    logging("The lock-delay time is not configured properly need to fix it manually.")
                    return None
                # Checking the total dleay time is morethan 15 min.
                totaldelayTimeOfGuser = idledelayTimeOfGuser + lockdelayTimeOfGuser
                logging ("The current idle time-out value of " + lockUserName + " user : " + str(totaldelayTimeOfGuser/60) + "min.")
                if totaldelayTimeOfGuser > 900:
                    usersInfo += ", " + lockUserName

        if usersLockTime:
            logging('The lock-delay option has set to "Screen turns off" for these user account(s)'\
 + usersLockTime.lstrip(",") +', i.e., disable the screen locking entirely.')
            return False
        if usersIdleTime:
            logging('The idle-delay option has set to "Never" for these user account(s)'\
+ usersIdleTime.lstrip(",") +', i.e., disable the screen blanking entirely.')
            return False
        if usersInfo:
            logging("The current idle time-out value is more than 15 minutes for these user account(s)" + usersInfo.lstrip(",") + ".")
            return False
        logging("The current idle time-out value is not more than 15 minutes.")
        return True
    else:
        idledelayTime = runOnShell('gconftool-2 --get /desktop/gnome/session/idle_delay')
        if "No value set" in idledelayTime:
            logging("The current idle time-out value does not exist.")
            return False
        try:
            if int(idledelayTime) <= val and int(idledelayTime) != 0:
                logging("The current idle time-out value is not more than 15 minutes.")
                return True
        except(ValueError, TypeError):
            logging("The lock-delay time is not configured properly need to fix it manually.")
            return None

        logging("The current idle time-out value is more than 15 minutes.")
        return False


def fixRule38629():
    if OsName.lower() == "ubuntu" or ((OsName.lower() == "redhat" or OsName.lower() == "centos") and OsVersion >= (7,0)):
        # To check and install the gsetting package if does not exist.
        gsetting_package_check()
        getIdledelay = "gsettings get org.gnome.desktop.session idle-delay | awk -F\" \" '{ print $2 }'"
        getLockdelay = "gsettings get org.gnome.desktop.screensaver lock-delay | awk -F\" \" '{ print $2 }'"
        # To Check the idel-delay time.
        gconf_golbal_users(getIdledelay)
        idledelayDict = commandsOutDict
        # To Check the lock-delay time.
        gconf_golbal_users(getLockdelay)
        lockdelayDict = commandsOutDict
        for (lockUserName, idleDelay), (idleUserName, lockDelay) in zip(idledelayDict.items(), lockdelayDict.items()):
            if lockUserName == idleUserName:
                idledelayTimeOfGuser = int(idleDelay)
                lockdelayTimeOfGuser = int(lockDelay)
                totaldelayTimeOfGuser = idledelayTimeOfGuser + lockdelayTimeOfGuser
                if (totaldelayTimeOfGuser > 900 or idledelayTimeOfGuser == 0 or lockdelayTimeOfGuser == 0):
                    logging("Updating the current idle time-out value to 15 minutes.")
                    if (OsName.lower() == "ubuntu" and lockUserName == username) or lockUserName == "root":
                        runOnShell('dbus-launch gsettings set org.gnome.desktop.session idle-delay 600')
                        runOnShell('dbus-launch gsettings set org.gnome.desktop.screensaver lock-delay 300')
                    else:
                        runOnShell('sudo -u ' + lockUserName + ' -H dbus-launch gsettings set org.gnome.desktop.session idle-delay 600')
                        runOnShell('sudo -u ' + lockUserName + ' -H dbus-launch gsettings set org.gnome.desktop.screensaver lock-delay 300')

        logging ("Copying the dconf database  values to local dconf database.")
        runOnShell("cp -u ~/.config/dconf/user /etc/dconf/db/local")
    else:
        logging("Updating the current idle time-out value to 15 minutes.")
        runOnShell('gconftool-2 --direct --config-source xml:readwrite:/etc/gconf/gconf.xml.mandatory --type int --set /desktop/gnome/session/idle_delay 15')

    logging("Please reboot the system to complete the process of Gnome desktop setting.")


def checkRule38630():
    # Checking If system is GUI or NON-GUI
    if check_gui_system():
        return True
    logging("Checking the screensaver mandatory use status.")
    if OsName.lower() == "ubuntu" or ((OsName.lower() == "redhat" or OsName.lower() == "centos") and OsVersion >= (7,0)):
        getCommand = "gsettings get org.gnome.desktop.screensaver idle-activation-enabled"
        # To Check the screensaver mandatory use status.
        gconf_golbal_users(getCommand)
        usersInfo = ""
        for nameOfUser, idleActivationVar in commandsOutDict.items():
            if "not found" in idleActivationVar:
                logging("GSettings schemas are not installed on the system.")
                return False
            if "false" in idleActivationVar:
                usersInfo += ", " + nameOfUser
        if usersInfo:
            logging("Screensaver idle-activation is not enabled for these user account(s)" + usersInfo.lstrip(",") + ".")
            return False
        logging("Screensaver idle-activation is enabled.")
        return True
    else:
        idleActivationVar = runOnShell('gconftool-2 --get /apps/gnome-screensaver/idle_activation_enabled')
        idleActivationVar = idleActivationVar.translate(string.maketrans("\n\t\r", "   "))
        if "true" in idleActivationVar:
            logging("Screensaver idle-activation is enabled.")
            return True
        logging("Screensaver idle-activation is not enabled.")
        return False

def fixRule38630():
    # /apps/gnome-screensaver/idle_activation_enabled: Set this to TRUE to activate the screensaver when the session is idle. 
    if OsName.lower() == "ubuntu" or ((OsName.lower() == "redhat" or OsName.lower() == "centos") and OsVersion >= (7,0)):
        # To check and install the gsetting package if does not exist.
        gsetting_package_check()
        getCommand = "gsettings get org.gnome.desktop.screensaver idle-activation-enabled"
        # Check the users which is having idle-activation disabled.
        gconf_golbal_users(getCommand)
        usersInfo = ""
        # Iterating the commandsOutDict dictionary to check the idle-activation status.
        for nameOfUser, idleActivationVar in commandsOutDict.items():
            if "false" in idleActivationVar:
                logging("Activating the screensaver in the GNOME desktop after a period of inactivity.")
                if (OsName.lower() == "ubuntu" and nameOfUser == username) or nameOfUser == "root":
                    runOnShell("dbus-launch gsettings set org.gnome.desktop.screensaver idle-activation-enabled 'true'")
                else:
                    runOnShell("sudo -u " + nameOfUser + " -H dbus-launch gsettings set org.gnome.desktop.screensaver \
idle-activation-enabled 'true'")
        logging ("Copying the dconf database values to local dconf.")
        runOnShell("cp -u ~/.config/dconf/user /etc/dconf/db/local")
    else:
        logging("Activating the screensaver in the GNOME desktop after a period of inactivity.")
        runOnShell('gconftool-2 --direct --config-source xml:readwrite:/etc/gconf/gconf.xml.mandatory --type bool \
--set /apps/gnome-screensaver/idle_activation_enabled true')

    logging("Please reboot the system to complete the process of Gnome desktop setting.")


def checkRule38631():
    if CheckService("auditd"):
	return True

    return False		

def fixRule38631():
        if not InstallPackage("audit"):
            return None

	RunService("auditd", False) 	

def checkRule38632():
    if CheckService("auditd"):
	return True

    return False		

def fixRule38632():
        if not InstallPackage("audit"):
            return None

	RunService("auditd", False) 	

def checkRule38633(val = 6):
	if not CheckService("auditd"):
		return False
	logging("Checking the maximum audit log file size.")
	res = runOnShell('grep -w max_log_file /etc/audit/auditd.conf | grep -v "^#"')
	if not res:
		logging("The maximum audit log file size flag was not found in audit configuration file.")
		return False
	converted_max_log_int = 0
	value_max_log_file = ""
	try:
		value_max_log_file = getValueOfKey("max_log_file", res.rstrip('\n'))
		converted_max_log_int = int(value_max_log_file)
	except (ValueError, TypeError) as e:
		logging("The system value for max_log_file is not correctly configured, hence need to fix it manually.")
		return None

	if value_max_log_file is not None:
		if not int(value_max_log_file) >= val:
			logging("In audit configuration file, the maximum audit log file size flag is not set.")
			return False
		res = res.translate(string.maketrans("\n\t\r", "   "))
		res = res.split(" ")
		for element in res:
			if ("max_log_file=" in element) or ("="+value_max_log_file in element):
				logging("The maximum audit log file size flag value is correct but extra arguments are there in the line.")
				return False
		logging ("The maximum system audit log file size is configured correctly.")
	return True
	logging ("The maximum system audit log file size is not configured correctly.")
	return False

def fixRule38633():
        if not InstallPackage("audit"):
            return None

	lastLine = ""
	s = ""
	flag = False
	fileSplit = open("/etc/audit/auditd.conf").readlines()
	for line in fileSplit:
		if isL(line) and ("max_log_file" in line):
			value = line.split("_")
			if len(value)>3:
				s += line
				lastLine = line
				continue
			line = line.translate(string.maketrans("\n\t\r", "   "))
			line = line.split("=")
			if tokenMatch("max_log_file",line[0]):
				if not tokenMatch("Cloud Raxak updated next line",lastLine):
					s += "# Cloud Raxak updated next line\n"
				logging ("Updating the system audit maximum log file size.")
				s += "max_log_file = 6\n"
				flag = True
		else:
			s += line
			lastLine=line
	if not(flag):
	    s += "# Cloud Raxak updated next line\n"
	    logging ("Updating the system audit maximum log file size.")
	    s += "max_log_file = 6\n"
	fout = None
	try:
	     fout = open('/etc/audit/auditd.conf', "w")
	     fout.write(s)
	finally:
	     if (fout is not None):
	            fout.close()

        RunService("auditd")

def checkRule38634():
	if not CheckService("auditd"):
		return False

	logging ("Checking if the system is configured to rotate audit logs files when they reach their maximum file size.")
	res = runOnShell('grep -w max_log_file_action /etc/audit/auditd.conf | grep -v "^#"' )
	if not res:
		logging ("The system will not rotate audit log files that will reach the maximum file size because related argument is \
not available in audit configuration file.")
		return False

	value = res.split("=")[1]
	value = value.rstrip('\n\t')
	value = value.replace(" ", "")
	if value is not None:
		if not (value.lower() == "rotate"):
			logging ("The system will not rotate audit log files that will reach the maximum file size because related \
argument is not correctly set.")
			return False
		res = res.translate(string.maketrans("\n\t\r", "   "))
		res = res.split(" ")
		for element in res:
			if ("max_log_file_action=" in element) or ("="+value in element):
				logging ("The system will not rotate audit log files that will reach the maximum file size because\
 more arguments are there in the same.")
				return False
		logging ("The system will rotate audit log files that reach the maximum file size.")
		return True
	logging ("The system will not rotate audit log files that reach the maximum file size.")
	return False


def fixRule38634():
        if not InstallPackage("audit"):
            return None

        lastLine = ""
        s = ""
        flag = False
        fileSplit = open("/etc/audit/auditd.conf").readlines()
        for line in fileSplit:
	      if isL(line) and ("max_log_file_action" in line):
			line = line.translate(string.maketrans("\n\t\r", "   "))
			line = line.split("=")
			if tokenMatch("max_log_file_action",line[0]):
				if not tokenMatch(" Cloud Raxak updated next line",lastLine):
					s += "# Cloud Raxak updated next line\n"
				logging("Setting the audit configuration file, so system will rotate audit log files that will\
 reach the maximum file size .")
				s += "max_log_file_action = ROTATE\n"
				flag = True
              else:
                    s += line
                    lastLine=line
        if not(flag):
            s += "# Cloud Raxak updated next line\n"
	    logging("Updating the audit configuration file, so system will rotate audit log files that will reach the maximum file size.")
            s += "max_log_file_action = ROTATE\n"
        fout = None
        try:
             fout = open('/etc/audit/auditd.conf', "w")
             fout.write(s)
        finally:
             if (fout is not None):
                    fout.close()
        RunService("auditd")

def checkRule38635():
    if not CheckService("auditd"):
	return False

    file_path = '/etc/audit/audit.rules'
    if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    	file_path = '/etc/audit/rules.d/audit.rules'

    #Checking for keyword never,task.
    logging("Checking if system call auditing is disabled.")
    if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
        return False

    #Checking for any error in file.
    if "error" in runOnShell('auditctl -R '+file_path):
	logging("There is an error in "+file_path+", please fix it manually before remediating the rule.")
	return None

    if runOnShell("grep -w adjtimex "+file_path +" | grep -v '^#'") == "":
	logging("System is not configured to audit the alter system time through adjtimex.")
	return False

    logging("System is configured to audit the alter system time through adjtimex.")
    return True			

def fixRule38635():
    if not InstallPackage("audit"):
        return None

    file_path = '/etc/audit/audit.rules'
    if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
    	file_path = '/etc/audit/rules.d/audit.rules'

    #Removing for keyword never,task
    if (OsName.lower() == 'amazon linux ami') and (runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" ):
        logging(" Disabling the system call auditing to audit the events properly.")
        runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /' "+file_path)

    #Clear previous rules set. 
    runOnShell("auditctl -D")
    #Obtaining the data from file_path	
    audit_handler = open(file_path, "r")
    audit_file_rules = audit_handler.readlines()
    audit_handler.close()
    #Removing redundant entries	from data
    filter_unique_audit_rule_list = []	
    for line in list(set(audit_file_rules)):
        line1 = line.strip('\n')
    	if (('-b 320' in line1) or ('-D' in line1) or ('#' in line1)):
		continue
	final_line = re.sub("\s+" , " ", line1)
	filter_unique_audit_rule_list.append(final_line.strip())

    startup_line = "# This file contains the auditctl rules that are loaded\n # whenever the audit daemon is started via the initscripts.\n # The rules are simply the parameters that would be passed\n# to auditctl.\n # First rule - delete all\n-D\n\n # Increase the buffers to survive stress events.\n # Make this bigger for busy systems\n -b 320\n"
    
    with open(file_path, "w") as fhandler:
    	res = runOnShell("uname -m")
       	if "64" in res:
	    rule = "-a always,exit -F arch=b64 -S adjtimex -k audit_time_rules"	
       	else:
	    rule = "-a always,exit -F arch=b32 -S adjtimex -k audit_time_rules"
    	fhandler.write(startup_line)
	unique_data = '\n'.join(filter_unique_audit_rule_list)
	fhandler.write(unique_data)
	if rule not in filter_unique_audit_rule_list:
    		logging("Configuring the system to audit the alter system time through adjtimex.")
    	    	fhandler.write('\n#Cloud Raxak updated next line\n#audit_time_rules\n')
		fhandler.write("\n"+rule+"\n")
		
    fhandler.close()  					
    runOnShell("auditctl -R "+file_path)
    RunService("auditd")

def checkRule38636(minval = 2, maxval = 99):
	if not CheckService("auditd"):
		return False

	logging("Checking the number of logs the system is configured to retain after rotation.")
	res = runOnShell('grep -w num_logs /etc/audit/auditd.conf | grep -v "^#"')
	if not res:
		logging("The system is not configured to retain enough audit logs to cover the required log retention period.")
		return False
	converted_num_log_int = 0
	value_num_logs = ""

	try:
		value_num_logs = getValueOfKey("num_logs", res.rstrip('\n'))
		converted_num_log_int = int(value_num_logs)
	except (ValueError, TypeError) as e:
		logging("The system value for num_logs is not configured correctly, need to fix it manually.")
		return None

	if value_num_logs is not None:
		if (int (value_num_logs) < minval) or (int (value_num_logs) > maxval):
			logging("The system is not configured to retain enough audit logs to cover the required log retention period.")
			return False
		res = res.translate(string.maketrans("\n\t\r", "   "))
		res = res.split(" ")
		for element in res:
			if ("num_logs=" in element) or ("="+value_num_logs in element):
				logging("The parameter value is correct but wrong number of arguments are defined for it, needs to be fixed.")
				return False
		logging("The system is configured to retain enough audit logs to cover the required log retention period.")
		return True
	logging("The system is not configured to retain enough audit logs to cover the required log retention period.")
	return False

def fixRule38636():
        if not InstallPackage("audit"):
            return None

        lastLine = ""
        s = ""
        flag = False
        fileSplit = open("/etc/audit/auditd.conf").readlines()
        for line in fileSplit:
	     if isL(line) and ("num_logs" in line):
	          line = line.translate(string.maketrans("\n\t\r", "   "))
		  line = line.split("=")
		  if tokenMatch("num_logs",line[0]):
                       if not tokenMatch("# Cloud Raxak updated next line",lastLine):
                            s += "# Cloud Raxak updated next line\n"
		       logging("Updating the system configuration to retain enough audit logs to cover the required log retention period.")
		       s += "num_logs = 5\n"
                       flag = True
             else:
                  s += line
                  lastLine=line
        if not(flag):
	     if not tokenMatch("# Cloud Raxak updated next line",lastLine):
		s += "# Cloud Raxak updated next line\n"
	     logging("Updating the system configuration to retain enough audit logs to cover the required log retention period.")
	     s += "num_logs = 5\n"
        fout = None
        try:
             fout = open('/etc/audit/auditd.conf', "w")
             fout.write(s)
        finally:
             if (fout is not None):
                    fout.close()

        RunService("auditd")

def checkRule38637():
	if not CheckPackage("auditd", True):
	    return True

	if OsName.lower() == "ubuntu":
	    if not CheckPackage ("debsums"):
	        logging("debsums package is required to verify all installed packages on the system.")
	        return False

	    logging ("Checking if audit files contents are matching with the given database or not.")
	    #It will list all changed packages except configuration files
	    auditMismatchFiles = runOnShell("debsums -c auditd")
	else:
	    auditMismatchFiles = runOnShell("rpm -V audit | awk '$1 ~ /..5/ && $2 != \"c\"'")

	if auditMismatchFiles == "":
	    logging ("All files contents are verified and matching with the given database.")
            return True

	splitRes = auditMismatchFiles.splitlines()
	for ele in splitRes:
	    if "prelink" in ele:
		continue
	    else:
		logging ("All files contents are not matching with the given database.")
		return False

	logging ("All files contents are verified and matching with the given database.")
	return True

def fixRule38637():
	if OsName.lower() == "ubuntu":
	    if not CheckPackage ("debsums"):
	        logging ("Checking if apt-get command is installed on the system.")
                if not InstallPackage("debsums"):
			return None

	    # To re-install audit package
	    reinstallPkgTool = "apt-get -y install --reinstall auditd"
        else:
	    if OsName.lower() == "amazon linux ami":
               yumFlag = False #To know whether yum is enabled or not
               yumFlagStr = "plugins=0" #yumFlag enabling string
	       #open the /etc/yum.conf file for searching yumString
               with open("/etc/yum.conf", "r") as yumConfigFile:
                   lines = yumConfigFile.readlines()
                   for line in lines:
                       if isL(line) and tokenMatchIC(yumFlagStr, line):
                           yumFlag = True
                           break
	
	    if OsName.lower() == "amazon linux ami" and not yumFlag:
		#If YUM flag is not enabled, enable it
                setPluginParamYum(False)

	    # To re-install audit package
	    reinstallPkgTool = "yum -y reinstall audit"

	logging("Reinstalling the audit package on the system.")
	reinstallPkgRes = runOnShell(reinstallPkgTool, False)
        if "dpkg was interrupted" in reinstallPkgRes:
		logging("dpkg is not properly configured, it needs to be configured properly using command \
'dpkg --configure -a'. Please fix this manually.")
		return None
	if ("not available" in reinstallPkgRes) or ("Error" in reinstallPkgRes):
	    logging("'audit' package could not be reinstalled on the system due to system issues. Please fix it manually.")
	    return None

	if OsName.lower() == "amazon linux ami" and not yumFlag:
	    # After using YUM, disable the flag
            setPluginParamYum(True)

def checkRule38638():
    # Checking If system is GUI or NON-GUI
    if check_gui_system():
        return True
    logging("Checking the status of idle screen lock activation.")
    if OsName.lower() == "ubuntu" or ((OsName.lower() == "redhat" or OsName.lower() == "centos") and OsVersion >= (7,0)):
        getCommand = "gsettings get org.gnome.desktop.screensaver lock-enabled"
        # To Check the lock activation status.
        gconf_golbal_users(getCommand)
        usersInfo = ""
        for nameOfUser, lockEnable in commandsOutDict.items():
            if "not found" in lockEnable:
                logging( "GSettings schemas are not installed on the system.")
                return False
            if "false" in lockEnable:
                usersInfo += ", " + nameOfUser

        if usersInfo:
            logging("The status of the idle screen lock activation is disabled for these user accounts " + usersInfo.lstrip(",") + ".")
            return False
    else:
        lockEnable = runOnShell( 'gconftool-2 --get /apps/gnome-screensaver/lock_enabled')
        lockEnable = lockEnable.translate(string.maketrans("\n\t\r", "   "))
        if "false" in lockEnable:
            logging("The status of the idle screen lock activation is disabled.")
            return False
    logging("The status of the idle screen lock activation is enabled.")
    return True

def fixRule38638():
    if OsName.lower() == "ubuntu" or ((OsName.lower() == "redhat" or OsName.lower() == "centos") and OsVersion >= (7,0)):
        # To check and install the gsetting package if does not exist.
        gsetting_package_check()
        getCommand =  "gsettings get org.gnome.desktop.screensaver lock-enabled"
        # Check the users which is having lock activation is disabled.
        gconf_golbal_users(getCommand)
        usersInfo = ""
        # Iterating the commandsOutDict dictionary to check the lock activation status.
        for nameOfUser, lockEnable in commandsOutDict.items():
            if "false" in lockEnable:
                logging("Activating the screensaver in the GNOME desktop after a period of inactivity.")
                if (OsName.lower() == "ubuntu" and nameOfUser == username) or nameOfUser == "root":
                    runOnShell("dbus-launch gsettings set org.gnome.desktop.screensaver lock-enabled 'true'")
                else:
                    runOnShell("sudo -u " + nameOfUser + " -H dbus-launch gsettings set org.gnome.desktop.screensaver lock-enabled 'true'")

        logging ("Copying the dconf database values to local dconf.")
        runOnShell("cp -u ~/.config/dconf/user /etc/dconf/db/local")
    else:
        logging("Activating the screensaver in the GNOME desktop after a period of inactivity.")
        runOnShell('gconftool-2 --direct --config-source xml:readwrite:/etc/gconf/gconf.xml.mandatory --type bool \
--set /apps/gnome-screensaver/lock_enabled true')

    logging("Please reboot the system to complete the process of Gnome desktop setting.")


def checkRule38639():
    if check_gui_system():
        return True
    logging("Checking the screensaver is configured to be blank only.")
    if OsName.lower() == "ubuntu" or ((OsName.lower() == "redhat" or OsName.lower() == "centos") and OsVersion >= (7,0)):
        getCommandIdledelay = "gsettings get org.gnome.desktop.session idle-delay | awk -F\" \" '{ print $2 }'"
        # To Check the lock activation status.
        gconf_golbal_users(getCommandIdledelay)
        usersIdleTime = ""
        for nameOfUser, idleDelay in commandsOutDict.items():
            try:
                # Checking the idle-delay time is set to "Never".
                if(idleDelay == "0"):
                    usersIdleTime += ", " + nameOfUser
            except(ValueError, TypeError):
                logging("The idle-delay time is not configured properly need to fix it manually.")
                return None
            if "not found" in idleDelay:
                logging('The Gsettings schemas are not installed on the system. Please remediate the \
V-38629 rule to install the Gsettings schemas and enable the screen blanking after a period of screen inactivity.')
                return None
            elif "No value set" in idleDelay:
                logging('The idle-delay value is not configured. Please remediate the V-38629 rule to enable the \
screen blanking after a period of screen inactivity.')
                return None
        if usersIdleTime:
            logging('The idle-delay option has set to "Never" for these user account(s)' + usersIdleTime.lstrip(",") +', i.e., \
disable the screen blanking entirely. Please remediate the V-38629 rule to enable the screen blanking after a period of screen inactivity.')
            return None
        logging('Once the idle-delay time has passed, blank screen will appear. The idle-delay option does not set with "Never", i.e.,\
 enable the screen blanking entirely.')
        return True
    else:
        idleDelay = runOnShell('gconftool-2 --get /apps/gnome-screensaver/mode')
        if tokenMatch("blank-only", idleDelay):
            logging("The screensaver is configured to blank-only.")
            return True
        logging("The screensaver is not configured to blank-only.")
        return False

def fixRule38639():
    if OsName.lower() == "ubutnu" or ((OsName.lower() == "redhat" or OsName.lower() == "centos") and OsVersion >= (7,0)):
        logging('The idle-delay option has set with "Never", i.e., disable the screen blanking entirely. \
Please remediate the V-38629 rule to enable the screen blanking after a period of screen inactivity.')
        return None
    else:
        logging ("Setting the screensaver mode in the GNOME desktop to a blank screen.")
        runOnShell('gconftool-2 --direct --config-source xml:readwrite:/etc/gconf/gconf.xml.mandatory --type string --set /apps/gnome-screensaver/mode blank-only')
        logging("Please reboot the system to reflect these changes.")

def checkRule38640():
	success_msg = "abrtd service is not running."
	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		logging("Checking the installation of abrtd (Automated Bug-Reporting Tool) service.")
		if not os.path.exists('/usr/sbin/abrtd'):
			logging("Automated Bug-Reporting Tool service is not installed.")
			return True
		logging("Checking the status of abrtd (Automated Bug-Reporting Tool) service.")
		service_status = runOnShell('systemctl is-active abrtd.service').replace('\n','')
		if service_status in ["inactive", "unknown","failed"]:
			return True
		service_at_runlevel = runOnShell("systemctl is-enabled abrtd.service").replace('\n','')
		if service_status == "active" or service_at_runlevel == "enabled":
			logging("abrtd (Automated Bug-Reporting Tool) service is running.")
			return False
	else:
		if OsName.lower() == "ubuntu":
			if not CheckPackage('apport'):
				return True
			success_msg = "apport service is not running."
			service_command = "service apport status" 
			token_match = "stop/waiting"
			service_at_level = "sysv-rc-conf --list apport"
	    		if os.path.exists('/usr/share/apport') == False:
				logging("The apport service is not installed or The file path /usr/share/apport does not exist ")
				return True
			logging("Checking the status of apport service.")
		else:
		    	if not os.path.exists('/usr/sbin/abrtd'):
				logging("abrtd service is not installed")
				return True
			service_command = "service abrtd status" 
			token_match = "stopped"
			service_at_level = "chkconfig --list abrtd"
			logging("Checking the status of abrtd (Automated Bug-Reporting Tool) service.")

		service_status = runOnShell(service_command)
		service_status = service_status.translate(string.maketrans("\n\t\r", "   "))
		if "unrecognized service" not in service_status:
			if not tokenMatchIC(token_match, service_status):
				return False
			logging("Checking the status of service in system boot configuration.")
			service_at_level = runOnShell(service_at_level)
			service_at_level = service_at_level.translate(string.maketrans("\n\t\r", "   "))
			if OsName.lower() == "ubuntu":
				service_at_level_repl = service_at_level.replace(" ",'')
				if len(service_at_level_repl) == len("apport") and tokenMatchIC("apport",service_at_level):
					logging("apport service is disabled in system boot configuration.")
					return True
				if "on" in service_at_level_repl:
					logging("apport service is enabled in system boot configuration.")
					return False
			else:
				if not(tokenMatchIC("abrtd 0:off 1:off 2:off 3:off 4:off 5:off 6:off", service_at_level)):
					return False
	logging(success_msg)
	return True


def fixRule38640():
	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		runOnShell("systemctl disable abrtd ; systemctl stop abrtd")
	elif OsName.lower() == 'ubuntu':
		logging("Disabling the apport service in system boot time and runtime configuration.")
		service_status = runOnShell('service apport status')
		service_status = service_status.translate(string.maketrans("\n\t\r", "   "))
		if "stop" not in service_status:
			runOnShell('service apport stop')
		runOnShell('sysv-rc-conf --level 0123456S apport off')
	else:
		logging("Disabling the abrtd (Automated Bug-Reporting Tool) service in system boot time and runtime configuration.")
		runOnShell('chkconfig --level 0123456 abrtd off') 
		if 'stopped' not in runOnShell('service abrtd status'):
			runOnShell('service abrtd stop')


def checkRule38641():
    if not CheckPackage("atd", True):
        return True
    logging("Checking the runtime status of atd service.")
    if (OsName.lower() == 'ubuntu') or (OsVersion < (7, 0) and (OsName.lower() == 'redhat' or OsName.lower() == 'centos')) or (OsName == "Amazon Linux AMI"):
        serviceStatus = runOnShell("service atd status")
        if ("not running" not in serviceStatus) and ("stopped" not in serviceStatus) and ("stop/waiting" not in serviceStatus):
            logging ("Checking atd service scheduler jobs existence.")
            atd_sheduler = runOnShell("atq")
            if atd_sheduler != "":
                logging ('The system using the "atd" service, So this rule is not applicable.')
                return True
            else:
                logging ("atd service is enabled.")
                return False

        if OsName.lower() == "ubuntu":
            serviceStatus = runOnShell("/etc/init.d/atd status")
            if ("not running" not in serviceStatus) and ("stopped" not in serviceStatus) and ("stop/waiting" not in serviceStatus):
                logging ("Checking atd service scheduler jobs existence.")
                atd_sheduler = runOnShell("atq")
                if atd_sheduler != "":
                    logging ('The system using the "atd" service, So this rule is not applicable.')
                    return 3
                else:
                    logging ("atd service is enabled.")
                    return False

        if OsName.lower() == "ubuntu":
            runLevelFilePath = "/etc/init/rc-sysinit.conf"
            runLevelCmd = "sysv-rc-conf --list atd"
        else:
            runLevelFilePath = "/etc/inittab"
            runLevelCmd = "chkconfig --list atd"

        # Need to append all run levels which are need to be checked
        runLevelList = []

        # To find the service run level status
        serviceLevelStatus = runOnShell(runLevelCmd)

        runLevel = runOnShell("runlevel").split()

        #We need to check current run level, default run level, and run level - 3
        runLevelList.append(runLevel[1])
        runLevelList.append(3)

        if os.path.exists(runLevelFilePath):
            try:
                # Finding default run level. If not available in the file, considering 3 is the default run level.
                if OsName.lower() == "ubuntu":
                    defaultRunLevel = runOnShell("grep -v '^#' {0} | grep -w DEFAULT_RUNLEVEL | grep env | cut -d '=' -f2".format(runLevelFilePath))
                else:
                    defaultRunLevel = runOnShell("grep -v '^#' {0} | grep -w initdefault: | cut -d ':' -f2".format(runLevelFilePath))

                defaultRunLevel = int(defaultRunLevel)
            except Exception:
                defaultRunLevel = 3

            runLevelList.append(defaultRunLevel)

        # Removing duplicate run levels from the run level list
        runLevelList = list(set(runLevelList))

        for checkRunLevel in runLevelList:
            if str(checkRunLevel) + ":" not in serviceLevelStatus:
                logging("run level {0} is not available".format(checkRunLevel))
                return False
            elif str(checkRunLevel) + ":on" in serviceLevelStatus:
                logging("Log run level {0} is on".format(checkRunLevel))
                return False
    else:
	service_status = runOnShell('systemctl is-active atd.service').replace('\n','')
	service_at_runlevel = runOnShell("systemctl is-enabled atd.service").replace('\n','')
	if service_status == "active" or service_at_runlevel == "enabled":
            logging ("Checking atd service scheduler jobs existence.")
            atd_sheduler = runOnShell("atq")
            if atd_sheduler != "":
                logging ('The system using the "atd" service, So this rule is not applicable.')
                return True
            else:
                logging ("atd service is enabled.")
                return False

    logging("atd service is disabled in system boot configuration.")
    return True

def fixRule38641():
    if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
        runOnShell("systemctl disable atd ; systemctl stop atd")
    elif OsName.lower() == 'ubuntu':
        logging ("Disabling the atd service.")
        if "stop/waiting" not in runOnShell('service atd status'):
            runOnShell('service atd stop')
        if OsVersion == (14,4):
            token = "not running"
        elif OsVersion == (14,10):
            token = "stop/waiting"
        if token not in runOnShell('/etc/init.d/atd status'):
            runOnShell( '/etc/init.d/atd stop')
        # Updating the atd.conf file to stop the service at boot time.
        with open("/etc/init/atd.conf", "r") as atdconfFile:
            flag = False
            runlevelLine = ""
            lastLine = ""
            for line in atdconfFile:
                if isL(line) and "start" in line:
                    if not tokenMatch('Cloud Raxak updated next line',lastLine):
                        runlevelLine += "# Cloud Raxak updated next line\n"
                    logging ('Modifying the "/etc/init.d/atd" file to Stop the "atd service" at boot time.')
                    runlevelLine +=  "# " + line
                else:
                    runlevelLine += line
        fout = None
        fout = open("/etc/init/atd.conf", "wt")
        if fout != None:
            fout.write(runlevelLine)
            fout.close()
        logging("Disabling the atd service runlevels.")
        runOnShell('sysv-rc-conf --level 2345 atd off')
    else:
        runOnShell('chkconfig --level 2345 atd off; service atd stop')


def checkRule38642():
	if OsName.lower() == "ubuntu":
	    logging("Checking the system default umask settings.")
	    res = runOnShell('grep umask /etc/init.d/rc | grep -v "#" ')
	else:
	    logging("Checking the system default umask settings.")
            res = runOnShell('grep umask /etc/init.d/functions | grep -v "#" ')

        if res == "":
	    logging("Umask is not configured.")
            return False
	only_com_line = True
	lis = res.split("\n")
	#Modified list after removing the empty '' element.
	modify_list=filter(lambda elem:elem != '', lis)
        for line in modify_list:
            if line[0]!='#':
	    	only_com_line=False
                fil = filter(lambda a: a != "", line.split(" "))
                if "022" not in fil and "027" not in fil:
		    logging("Umask is not configured correctly.")
                    return False
	#This condition satisfy if it only finds commented line. 
	if only_com_line:
	    logging("The system default umask settings is not configured correctly.")
	    return False		    
	logging("The system default umask settings is configured correctly.")
        return True

def fixRule38642():
	if OsName.lower() == "ubuntu":
	    filePath = "/etc/init.d/rc"
	else:
	    filePath = "/etc/init.d/functions"
	with open(filePath, "r") as f:
            flag = False
            s = ""
            lastLine = ""
	    logging("Updating the system default umask settings.")
            for line in f:
                if isL(line) and "umask" in line:
                    if not tokenMatch('Cloud Raxak updated next line',lastLine):
                        s += "# Cloud Raxak updated next line\n"
                    s += "umask 022\n"
                    flag = True
                else:
                    s += line
                    lastLine = line
            if not(flag):
                s += "# Cloud Raxak updated next line\n"
                s += "umask 022\n"
            fout = None
            try:
                fout = open(filePath, 'wt')
                fout.write(s)
            finally:
                if fout is not None:
                    fout.close()

def checkRule38643():
        #Find world writable file which can be accessed by outsiders excluding "/proc", "/selinux", and "/sys" directories
        logging("Finding all world writable files in the system.")
        res = runOnShell('find / -type f -perm -002 -print 2>>/dev/null | grep -v -e ^"/proc" -e ^"/selinux" -e ^"/sys"')
        if res == "":
                logging('There are no world writable file which can be accessed by outsiders excluding "/proc", "/selinux", and "/sys" directories.')
		return True
	else:
		logging("If there are any applications(example: games), that application's world write permissions should not be changed because user has to use that application properly.\
\nIf there are any configuration files, that configuration file's world write permissions should not be changed because if user wants to change their configuration as per his requirements, he can't change.\
\nIf there are any miscellaneous files, we are not sure why exactly those files are used and we should not change their world writable permissions.")
		logging("Hence, not fixing this rule and need to do it manually.")
		return None

def fixRule38643():
        #We can change world writable permissions for any files, if there are any but, issues as follows
        #1) If there are applications, we should not suppose to change write permissions of that application 
        #2) If there are configuration files, we should not suppose to change their write permissions 
        #3) If there are any miscellaneous files as well, and etc..
        #                       .
        #                       .
        #                       .
        #Because of these reasons, not changing world writable file permissions. Hence not fixing this rule
	listOfFile = runOnShell('find / -type f -perm -002 -print 2>>/dev/null | grep -v -e ^"/proc" -e ^"/selinux" -e ^"/sys"').splitlines()
	for filePath in listOfFile:
	    runOnShell("chmod o-w "+filePath)

def checkRule38644():
    if not CheckPackage("ntpdate"):
        return True

    return False

def fixRule38644():
    logging("The functionality of the ntpdate service is now available in the ntpd program and should be considered \
deprecated hence removing the only ntpdate package.")
    if OsName.lower() == 'ubuntu':
        # Uninstalling ntpdate package as ntp is preferred to sync the time
        if "dpkg was interrupted" in runOnShell('apt-get -y purge ntpdate', False):
            logging("dpkg is not properly configured, it needs to be configured properly using command 'dpkg --configure -a'. \
Please fix this manually.")
            return None
    else:
        # Uninstalling ntpdate package without dependency packages
        runOnShell('rpm -e --nodeps ntpdate', False)
		
def checkRule38645():
	if OsName.lower() == 'ubuntu':
	    logging ("Checking whether the pam_module is installed on the system.")
	    check_pam = runOnShell("dpkg -s libpam-modules")
	    if "dpkg was interrupted" in check_pam:
		logging ("dpkg is not properly configured.\nRun 'dpkg --configure -a' command to configure dpkg properly. Need to fix this manually.")
	    	return None
	    elif ("is not installed" in check_pam) or ("deinstall" in check_pam) or ('error' in check_pam ):
		logging("Pam-modules package is not installed on the system.")
	    	return False
	    logging("Checking the pam_umask module in the pam session file.")
	    if os.path.exists('/etc/pam.d/common-session'):
		res_session = runOnShell('grep -w "session\s*optional\s*pam_umask.so" /etc/pam.d/common-session | grep -v "^#"')
		res_session_split = res_session.translate(string.maketrans("\n\t\r", "   "))
		if res_session == "":
			logging("The pam_umask module settings in the session file is not configured.")
			return False
		elif not tokenMatchIC("pam_umask.so", res_session_split):
			logging("The pam_umask module does not exist in the pam session file.")
			return False
	    else:
		logging("File path /etc/pam.d/common-session does not exist. Please fix this manually.")
	    	return None
	logging("Checking whether the user file creation mask is configured correctly.")
	res = runOnShell('grep -v "^#" /etc/login.defs | grep -w UMASK')
	res = res.translate(string.maketrans("\n\t\r","   "))
	res = res.split()
	# UMASK value has to be set to 077, values other than that will not be acceptable. The condition below takes care of situations if UMASK has a wrong value or 
	# it has been set multiple times in the same file, the condition also works for typo errors by user such as "UMASK    077    077"
	if len(res) != 2:
		logging("The user file creation mask is not configured correctly.")
		return False
	elif res[0] == "UMASK" and res[1] == "077":
		logging("The user file creation mask is configured correctly.")
		return True
	else:
		logging("The user file creation mask is not configured correctly.")
		return False

def fixRule38645():
	if OsName.lower() == 'ubuntu':
		logging ("Checking whether pam-module is installed on the system.")
		if not CheckPackage("libpam-modules"):
		    if not InstallPackage("libpam-modules"):
                        return None	

		logging("Checking the pam_umask module in the pam session file.")
		if os.path.exists('/etc/pam.d/common-session'):
			res_session = runOnShell('grep -w "session\s*optional\s*pam_umask.so" /etc/pam.d/common-session | grep -v "^#"')
			wrong_mod = False
			if res_session != "" :
				res_session_split = res_session.translate(string.maketrans("\n\t\r", "   "))
				if not tokenMatchIC("pam_umask.so", res_session_split):
					wrong_mod = True
			if res_session == "" or wrong_mod:
				with open(filePath,'a') as session_file:
					session_file.write("session optional                       pam_umask.so\n")
		else:
			logging("File path /etc/pam.d/common-session does not exist. Please fix this manually.")
			return None
	flag = False
	changeline = ""
	lastLine = ""
	with open("/etc/login.defs", "r") as file_data:
		logging("Updating the user file creation mask.")
		for line in file_data:
			line_split = line.translate(string.maketrans("\n\t\r", "   "))
			if isL(line) and "UMASK" in line_split:
				if flag == False:
					if not tokenMatch('Cloud Raxak updated next line',lastLine):
						changeline += "# Cloud Raxak updated next line\n"
					changeline += "UMASK           077\n"
					flag = True
			else:
                        	lastLine = line
				changeline += line 
	if not(flag):
	        logging("Adding the user file creation mask.")
                if not tokenMatch('Cloud Raxak updated next line',lastLine):
                        changeline += "# Cloud Raxak updated next line\n"
		changeline += "UMASK           077\n"
	fout = None
	try:
		fout = open("/etc/login.defs", 'wt')
                fout.write(changeline)
        finally:
		if fout is not None:
			fout.close()

def checkRule38646():
        if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
	    logging ("Checking if 'oddjobd' service is installed on system.")
	    oddjob_package = runOnShell ('rpm -qa | grep oddjob')
	    if oddjob_package == "":
		logging("'oddjobd' service is not installed on system.")
		return True

	    service_status = runOnShell('systemctl is-active oddjobd.service').replace('\n','')
	    if service_status in ["inactive", "unknown","failed"]:
	    	return True

	    service_at_runlevel = runOnShell("systemctl is-enabled oddjobd.service").replace('\n','')
	    if service_status == "active" or service_at_runlevel == "enabled":
	    	logging("oddjobd service is running.")
	    	return False

        elif OsName.lower() == "ubuntu":
            logging("There is no package oddjobd available for ubuntu hence this rule is not applicable.")
            return 3
        else:
	    if not os.path.exists('/usr/sbin/oddjobd'):
		logging("oddjobd service is not installed.")
		return True
            ser_runlevel_status = runOnShell('chkconfig "oddjobd" --list')
            if serviceInstalled(ser_runlevel_status):
                ser_runlevel_status=ser_runlevel_status.translate(string.maketrans("\n\t\r", "   "))
                if not (tokenMatchIC("oddjobd 0:off 1:off 2:off 3:off 4:off 5:off 6:off", ser_runlevel_status)):
                    return False

                ser_run_status = runOnShell('service oddjobd status')
                ser_run_status=ser_run_status.translate(string.maketrans("\n\t\r", "   "))
                if not(tokenMatchIC("stopped", ser_run_status)):
                    return False

        return True


def fixRule38646():
	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
	    runOnShell("systemctl disable oddjobd ; systemctl stop oddjobd")
	else:
	    logging("Disabling the oddjobd service in system boot time and runtime configuration.")
	    runOnShell('chkconfig --level 0123456 oddjobd off')
	    if 'stopped' not in runOnShell('service oddjobd status'):
		runOnShell('service oddjobd stop')

def checkRule38647():
	if not os.path.exists('/etc/profile'):
		logging("The configuration file for setting user file creation mask was not found. Please fix this manually.")
		return None

	logging("Checking whether the user file creation mask is configured correctly.")
	# Reloading /etc/profile.
	check_syntax = runOnShell('. /etc/profile')
	if "syntax error" in check_syntax:
		logging("The configuration file for setting user file creation mask has a syntax error. Please fix this manually.")
		return None
	check_umask = runOnShell("grep umask /etc/profile | grep -v '^#'")
	if check_umask == "":
		logging("The configuration for user file creation mask does not exist.")
		return False
	check_umask = check_umask.splitlines()
	count_wrong_entry = 0
	for element in range(len(check_umask)):
		check_umask_element = check_umask[element].split()
		try:
			if len(check_umask_element) != 2 or check_umask_element[0] != "umask" or check_umask_element[1] != "077":
				count_wrong_entry += 1            # Value is incremented if umask value is not properly configured
		except IndexError:
			logging("The user file creation mask is not configured correctly.")
			return False
	if count_wrong_entry > 0:
		logging("The user file creation mask is not configured correctly.")
		return False
	else:
		logging("The user file creation mask is configured correctly.")
		return True

def fixRule38647():
	if not os.path.exists('/etc/profile'):
                logging("The configuration file for setting user file creation mask was not found. Please fix this manually.")
                return None
	# Reloading /etc/profile
	check_syntax = runOnShell('. /etc/profile')
	if "syntax error" in check_syntax:
                logging("The configuration file for setting user file creation mask has a syntax error. Please fix this manually.")
                return None

	flag_umask = False
	with open("/etc/profile", "r") as file_data:
		change_umask_value = ""
		lastLine = ""
		for line in file_data:
			if isL(line) and "umask" in line:
				logging("Updating the user file creation mask.")
				if not tokenMatch('Cloud Raxak updated next line',lastLine):
					change_umask_value += "# Cloud Raxak updated next line.\n"
				change_umask_value += "    umask 077\n"
				flag_umask = True
			else:
				change_umask_value += line
				lastLine = line
	if not(flag_umask):
		logging("Adding the user file creation mask.")
		if not tokenMatch('Cloud Raxak updated next line',lastLine):
			change_umask_value += "# Cloud Raxak updated next line.\n"
		change_umask_value += "umask 077\n"
	fout = None
	try:
		fout = open("/etc/profile", 'wt')
		fout.write(change_umask_value)
	finally:
		if fout is not None:
			fout.close()

def checkRule38648():
	logging("Checking if Qpid AMQP Message Broker Daemon (qpidd) service is installed.")
	if not os.path.exists('/usr/sbin/qpidd'):
		logging("Qpid AMQP Message Broker Daemon (qpidd) service is not installed.")
		return True
	if (( OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat' )):
		service_status = runOnShell('systemctl is-active qpidd.service').replace('\n','')
		if service_status in ["inactive", "unknown","failed"]:
			logging("qpidd service is not running.")
			return True
		service_at_runlevel = runOnShell("systemctl is-enabled qpidd.service").replace('\n','')
		if service_status == "active" or service_at_runlevel == "enabled":
			logging("qpidd service is running.")
			return False
	elif OsName.lower() == "ubuntu":
		token_match_2 = "...fail!"
		logging("Checking the current status of Qpid AMQP Message Broker Daemon (qpidd) service.")
		logging("service and init.d are used for start/stop/restart/reload the service,\
 hence checking the status of service using both commands.")	
		status_from_service_cmd = runOnShell('service qpidd status').translate(string.maketrans("\n\t\r", "   "))
		status_from_init_cmd = runOnShell('/etc/init.d/qpidd status').translate(string.maketrans("\n\t\r", "   "))

		return_value = tokenMatchIC("...done.", status_from_service_cmd)
		return_value_init = tokenMatchIC("...done.", status_from_init_cmd)
		if return_value_init or return_value:
			return False

		logging("Checking the current status of Qpid AMQP Message Broker Daemon (qpidd) service.")
		service_at_level = runOnShell("sysv-rc-conf --list qpidd").translate(string.maketrans("\n\t\r", "   "))
		service_at_level_repl = service_at_level.replace(" ",'')
		if len(service_at_level_repl) == len("qpidd") and tokenMatchIC("qpidd",service_at_level):
			logging("Qpid AMQP Message Broker Daemon (qpidd) service is disabled in system boot configuration.")
			return True
		if "on" in service_at_level_repl:
			logging("Qpid AMQP Message Broker Daemon (qpidd) service is enabled in system boot configuration.")
			return False
	else:
		return_value_init = False
		logging("Checking the current status of Qpid AMQP Message Broker Daemon (qpidd) service.")
		#As init.d command is working same as service command in case of red hat
		#hence not using this in case of redhat.	
		if not OsName.lower() == 'redhat':
			logging("service and init.d are used for start/stop/restart/reload the service,\
 hence checking the status of service using both commands.")
			status_init =  runOnShell('/etc/init.d/qpidd status').translate(string.maketrans("\n\t\r", "   "))
			return_value_init = tokenMatchIC("running...", status_init)

		service_status = runOnShell('service qpidd status').translate(string.maketrans("\n\t\r", "   "))
		return_value = tokenMatchIC("running...", service_status)
		if return_value or return_value_init:
			return False
		
		logging("Checking the status of Qpid AMQP Message Broker Daemon (qpidd) service in system boot configuration.")
		service_at_level = runOnShell("chkconfig --list qpidd").translate(string.maketrans("\n\t\r", "   "))
		if not(tokenMatchIC("qpidd 0:off 1:off 2:off 3:off 4:off 5:off 6:off", service_at_level)):
			return False

	return True


def fixRule38648():
	if (( OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat' )):
		runOnShell("systemctl stop  qpidd.service; systemctl disable qpidd.service")
	elif OsName.lower() == "ubuntu":
		logging("Disabling the Qpid AMQP Message Broker Daemon (qpidd) service in system boot and runtime configuration.")
		runOnShell('sysv-rc-conf --level 0123456S qpidd off') 
		status =  runOnShell('service qpidd status').translate(string.maketrans("\n\t\r", "   "))
		if '...done.' in status:
			runOnShell('service qpidd stop' )
		status_init =   runOnShell('/etc/init.d/qpidd status').translate(string.maketrans("\n\t\r", "   "))
		if '...done.' in status_init:
			runOnShell('/etc/init.d/qpidd stop' )
	else:
		logging("Disabling the Qpid AMQP Message Broker Daemon (qpidd) daemon service in system boot and runtime configuration.")
		runOnShell('chkconfig --level 0123456 qpidd off') 
		if 'stopped' not in runOnShell('service qpidd status'):
			runOnShell('service qpidd stop')
		
		if not OsName.lower() == 'redhat':
			status_init =  runOnShell('/etc/init.d/qpidd status')
			if 'stopped' not in status_init:
				runOnShell('/etc/init.d/qpidd stop')

def checkRule38649():
    logging ("Checking whether tcsh package is installed on the system.")
    if OsName.lower() == "ubuntu":
	res = runOnShell('dpkg -s tcsh')
    else:
	res = runOnShell('rpm -q tcsh')

    if ("not installed" in res) or ("deinstall ok" in res) or ("error" in res):
	logging ("tcsh package is not installed on the system, so no need to check csh configuration file.")
        #If not installed, return with True because 
        #No need to update umask value, if shell is not available
        return True

    logging ("tcsh package is installed.")

    #If shell is installed and csh.cshrc file is not available
    if not os.path.exists("/etc/csh.cshrc"):
	logging("The file path /etc/csh.cshrc does not exist.")
        return False

    check_umask = runOnShell('grep umask /etc/csh.cshrc | grep -v "^#"')
    if check_umask =="":
        logging("The configuration for user file creation mask was not found in the csh shell configuration file.")
        return False
    split_adjust = check_umask.count("\n",0,len(check_umask))
    check_umask = check_umask.split('\n',split_adjust-1)
    count_wrong_entry = 0
    for element in range(len(check_umask)):
        check_umask_element = check_umask[element].split()
        try:
            if len(check_umask_element) != 2 or check_umask_element[0] != "umask" or check_umask_element[1] != "077":
                count_wrong_entry += 1
        except IndexError:
            logging("The user file creation mask is not configured correctly.")
            return False
    if count_wrong_entry > 0:
        logging("The user file creation mask is not configured correctly.")
        return False
    else:
        logging("The user file creation mask is configured correctly.")
        return True

def fixRule38649():
    #If csh.cshrc file is not available, reinstall tcsh shell
    #so that csh.cshrc file will be available
    if not os.path.exists("/etc/csh.cshrc"):
        if OsName == "Amazon Linux AMI":
            yumFlag = False #To know whether yum is enabled or not
            yumFlagStr = "plugins=0" #yumFlag enabling string
	    #open the /etc/yum.conf file for searching yumString
            with open("/etc/yum.conf", "r") as file_content:
                file_data = ""
                lines = file_content.readlines()
                for line in lines:
                    if isL(line) and tokenMatchIC(yumFlagStr, line):
                        yumFlag = True
                        break
            res = runOnShell('rpm -q tcsh')
            if not("not installed" in res) or not("deinstall ok" in res) or not("error" in res):
                #If yum plugin is not set, enable the flag, install yum, disable the flag
	        if yumFlag == False:
                    setPluginParamYum(False)
                    runOnShell('yum -y remove tcsh')
                    runOnShell('yum -y install tcsh')
		    #Disable the flag
                    setPluginParamYum(True)
	        else:
                    runOnShell('yum -y remove tcsh')
                    runOnShell('yum -y install tcsh')
        elif OsName.lower() == "ubuntu":
	    logging ("Checking whether tcsh package is installed on the system.")
	    res = runOnShell('dpkg -s tcsh')
            #if ("not installed" in res) or ("deinstall ok" in res) or ("error" in res):
            if not("not installed" in res) or not("deinstall ok" in res) or not("error" in res):
		logging ("Installing tcsh shell on the system.")
                if "dpkg was interrupted" in runOnShell('apt-get -y remove tcsh', False):
                    logging("dpkg is not properly configured, it needs to be configured properly using command \
'dpkg --configure -a'. Please fix this manually.")
                    return None
		#purge is required before re-installing in Ubuntu.
                if "dpkg was interrupted" in runOnShell('apt-get -y purge tcsh', False):
                    logging("dpkg is not properly configured, it needs to be configured properly using command \
'dpkg --configure -a'. Please fix this manually.")
                    return None
                if "dpkg was interrupted" in runOnShell('apt-get -y install tcsh', False):
                    logging("dpkg is not properly configured, it needs to be configured properly using command \
'dpkg --configure -a'. Please fix this manually.")
                    return None
        else:
	    res = runOnShell('rpm -q tcsh')
            if not("not installed" in res) or not("deinstall ok" in res) or not("error" in res):
                runOnShell('yum -y remove tcsh')
                runOnShell('yum -y install tcsh')

    # need to manually re-install tcsh, if csh.cshrc file is not available.
    if not os.path.exists("/etc/csh.cshrc"):
	logging("The file path /etc/csh.cshrc is not available. Need to fix this manually.")
	return None

    logging ("Checking user file creation mask.")
    with open("/etc/csh.cshrc", "r") as file_data:
        flag_umask = False
        change_umask_value = ""
        lastLine = ""
        for line in file_data:
            if isL(line) and "umask" in line:
                if not tokenMatch('Cloud raxak updated next line',lastLine):
                    change_umask_value += "# Cloud raxak updated next line\n" 
                change_umask_value += "    umask 077\n"
                flag_umask = True
            else:
                change_umask_value += line
                lastLine = line
    if not(flag_umask):
        logging ("Adding user file creation mask.")
        if not tokenMatch('Cloud raxak updated next line',lastLine):
            change_umask_value += "# Cloud raxak updated next line\n" 
        change_umask_value += "umask 077\n"
    fout = None
    try:
        fout = open("/etc/csh.cshrc", 'wt')
        fout.write(change_umask_value)
    finally:
        if fout is not None:
            fout.close()

def checkRule38650():
	#For ubuntu we need to install ndisc6 package which install ndisc6 and rdisc6 as default. 
	#Moreover Ndisc6 and rdisc6 are command use to find IPv6 router on your network, not a service package 
	#and hence there is no service available as such for rdisc in ubuntu.
	if ( ( OsVersion >= (7,0) ) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat' ) ):
	    logging("Checking the status of network router discovery daemon(rdisc) service.")	
            res= runOnShell('systemctl status rdisc.service')
            match_object=filter(lambda element:re.search(r'Active', element), res.split('\n'))[0]
            if 'running' in match_object:
                return False

            res= runOnShell('systemctl is-enabled rdisc.service')
            res=res.translate(string.maketrans("\n\t\r", "   "))
            if 'enabled' in res:
        	    return False
	elif OsName.lower() == "ubuntu":
	    logging("rdisc service package is not available for Ubuntu hence this rule is not applicable for ubuntu.")
	    return 3
        else:
	    logging("Checking the status of network router discovery daemon(rdisc) service at runlevel.")	
            ser_runlevel_status = runOnShell('chkconfig "rdisc" --list')
            if serviceInstalled(ser_runlevel_status):
                ser_runlevel_status=ser_runlevel_status.translate(string.maketrans("\n\t\r", "   "))
                if not (tokenMatchIC("rdisc 0:off 1:off 2:off 3:off 4:off 5:off 6:off", ser_runlevel_status)):
                    return False

	    	logging("Checking the status of network router discovery daemon(rdisc) service in runtime.")	
            	ser_run_status = runOnShell('service rdisc status')
            	ser_run_status = ser_run_status.translate(string.maketrans("\n\t\r", "   "))
            	if not(tokenMatchIC("stopped", ser_run_status)):
            	    return False
        return True

def fixRule38650():
	#To stop the daemon service permanently.
	if ( ( OsVersion >= (7,0) ) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat' ) ):
	    logging("Disabling the network router discovery daemon (rdisc) service.")
	    runOnShell("systemctl disable rdisc ; systemctl stop rdisc")
	elif OsName.lower() == "ubuntu":
	    logging("rdisc service package is not available for Ubuntu hence this rule is not applicable for ubuntu.")
	    return 3
	else:
	    logging("Disabling the network router discovery daemon (rdisc) service in system boot time and runtime configuration.")
	    if 'stop' not in runOnShell('service rdisc status'):
		runOnShell('service rdisc stop')
	    runOnShell('chkconfig --level 0123456 "rdisc" off')

def checkRule38651():
    logging("Checking if umask is set to 077 for the bash shell.")
    if OsName.lower() == "ubuntu":
        filePath = "/etc/bash.bashrc"
    else:
        filePath = "/etc/bashrc"
    if not os.path.exists(filePath):
        logging("The configuration script for bash shell is not available. Please fix this manually.")
        return None

    checkSyntax = runOnShell('. ' + filePath, False)
    # used .lower() because in case of Ubuntu "S" is uppercase in syntax error.
    if "syntax error" in checkSyntax.lower() :
        logging("The user file creation mask set for the bash shell has a syntax error. Please fix this manually.")
        return None
    elif "command not found" in checkSyntax:
        if "umask" in checkSyntax.lower():
            logging("The Umask is not properly configured.")
            return False
        else:
            logging("There is an unknown command used in " + filePath + " which the system does not recognize. Please fix this manually.")
            return None

    umaskResult = runOnShell("grep -i umask " + filePath + " | grep -v '^\s*#'")
    if not umaskResult:
        logging("The user file creation mask for bash shell is not defined.")
        return False

    # Checking for the umask value.
    splitLine = umaskResult.splitlines()
    for line in splitLine:
        checkLine = line.split()
        try:
            if len(checkLine) != 2 or checkLine[0] != "umask" or checkLine [1] != "077":
                logging("The umask value for bash shell is not set properly.")
                return False
                break
        except IndexError:
            logging("The umask value for bash shell is not set properly.")
            return False

    logging("The umask value for bash shell is set properly.")
    return True

def fixRule38651():
    if OsName.lower() == "ubuntu":
        filePath = "/etc/bash.bashrc"
    else:
        filePath = "/etc/bashrc"

    if not os.path.exists(filePath):
        logging("The configuration script for bash shell is not available. Please fix this manually.")
        return None

    checkSyntax = runOnShell('. ' + filePath, False)
    # Checking the if syntax error exists in bash configuration script.
    # used .lower() because in case of Ubuntu "S" is uppercase in syntax error.
    if "syntax error" in checkSyntax.lower():
        logging("The user file creation mask has a syntax error. Please fix this manually.")
        return None

    logging("Configuring the umask value to 077 for the bash shell.")
    with open(filePath, "r") as file_content:
       umaskCheck = False
       fileStrings = ""
       lastLine = ""
       for line in file_content:
           tmpLine = re.sub(' +', ' ', line)
           if ("umask" in tmpLine.lower()) and not (tmpLine.startswith(" #")):
               if not tokenMatch('Cloud Raxak updated next line', lastLine):
                   fileStrings += "         # Cloud Raxak updated next line\n"
               fileStrings += "         umask 077\n"
               umaskCheck = True
           else:
               fileStrings += line
               lastLine = line
    # If umask does not exist.
    if not umaskCheck:
            if not tokenMatch('Cloud Raxak updated next line', lastLine):
                fileStrings += "# Cloud Raxak updated next line\n"
            fileStrings += "umask 077\n"
    fout = None
    fout = open(filePath, "wt")
    if fout != None:
        fout.write(fileStrings)
        fout.close()

def checkRule38652():
    if not os.path.exists("/etc/fstab"):
	logging("The fstab configuration file does not exist which is required to mount the NFS devices. Please fix it manually.")
	return None

    # 'nodev' is available from the below list of /etc/fstab file
    nodevAvailableList = ['nodev', 'user', 'users', 'owner', 'group']

    fstabAllEntries = open("/etc/fstab", 'r').readlines()

    #To find th integer options are avaialble in any valid entry of the fstab file
    optionIntFlag = False
    #To hold the option integer entry in the fstab file
    optionIntStr = ""

    #It uses to check ONLY first time nodev option
    nodevFlag = True

    #This list is used to differentiate temporary & permamnet mount devices
    permanantMounts = []

    # It contain the nfs entries in fstab file which don't have nodev option
    notnodevEntries = ""

    for entry in fstabAllEntries:
	if isL(entry):
	    entry = entry.translate(string.maketrans("\n\t\r", "   ")).strip()
	    #The below part of code will detrmine if any entry has less than 6 columns
	    entrySplit = entry.split()
	    if (len(entrySplit) < 3):
		logging("The below mentioned fstab configuration file entry has less than 3 columns which is wrong configuration. \
Please fix it manually.\n{0}".format(entry))
		return None
	    elif (not optionIntFlag) and (len(entrySplit) > 3):
		optionList = entrySplit[3].split(",")
		if any (re.match("^\d+", option) for option in optionList):
		    optionIntFlag = True
		    optionIntStr = entry

	    nfsTypeCheck = runOnShell("echo " + entry + " | cut -d' ' -f3", False)
	    if nfsTypeCheck in ["nfs\n", "nfs4\n"]:
		entry = entry.translate(string.maketrans("\n\t\r", "   ")).strip()
		entrySplit = entry.split()
		permanantMounts.append(entrySplit[0] + "-->" + entrySplit[1])

		#Checking this flag to avoid updating flag again
		if nodevFlag:
		    try:
			optionList = entrySplit[3].split(",")
		    except IndexError:
			logging("The below mentioned NFS entry does not have 'nodev' option.\n{0}".format (entry))
			return False

		    for option in xrange(len(optionList) - 1, -1, -1):
			if optionList[option] in nodevAvailableList:
			    nodevFlag = True
			    break
			elif "dev" == optionList[option]:
			    nodevFlag = False
			    break
			else:
			    nodevFlag = None

		    # Here, capturing the nfs entries in fstab which which do not have 'nodev' option.
		    if not nodevFlag:
			notnodevEntries = notnodevEntries + entry + "\n"

    mountDevRes = runOnShell("mount -t nfs4").splitlines()
    nfsMountDevRes = []
    if OsName.lower == "ubuntu" or ((OsName.lower() == "centos" or OsName.lower() == "redhat") and OsVersion < (7,0)):
	nfsMountDevRes = runOnShell("mount -t nfs").splitlines()

    # The below list contains all 'nfs', and 'nfs4' types
    mountDevRes = mountDevRes + nfsMountDevRes

    #Contains NFS temporary entries
    tmpMountList = []

    for mountEle in mountDevRes:
	mountEleSplit = mountEle.split()
	mountPoint = mountEleSplit[0] + "-->" + mountEleSplit[2]

	#Checking whether mount point is available in fstab file or not
	#If not available, considering as temporary mount
	if mountPoint not in permanantMounts:
	    tmpMountList.append(mountPoint)

    if len(permanantMounts) == 0 or nodevFlag:
	if len(permanantMounts) == 0:
	    logging("There are no permanent NFS devices mounted on the system.")
	else:
	    logging("The NFS mount points have 'nodev' option.")
	if len(tmpMountList) > 0:
	    logging("The below mentioned mounts are temporary mounts and can add as part of fstab configuration file \
for permanent mount.\n{0}".format("\n".join(tmpMountList)))
	return True

    if optionIntFlag:
	logging("The below mentioned entry has integer option which is wrong configuration. Please fix it manually.\n{0}".format(optionIntStr))
	return None

    #Checking, if there are any configuration related errors in fstab file
    remountRes = runOnShell("mount -a")
    if "is busy" not in remountRes and remountRes != "":
	logging("The system has wrong fstab entries like NFS Server is not reachable, wrong mount point, and etc. Please fix it manually.")
	return None

    logging("The below mentioned NFS mount entries do not have 'nodev' option.\n{0}".format(notnodevEntries))
    return False

def fixRule38652():
    if not os.path.exists("/etc/fstab"):
	logging("The fstab configuration file does not exist which is required to mount the NFS devices. Please fix it manually.")
	return None

    #The below condition is useful in case of force re-mediation
    logging("Checking if there are any fstab errors.")
    if runOnShell("mount -a") != "":
	return None

    # 'nodev' is available from the below list of /etc/fstab file
    nodevAvailableList = ['nodev', 'user', 'users', 'owner', 'group']

    fstabAllEntries = open("/etc/fstab", 'r').readlines()
    for entry in fstabAllEntries:
	if isL(entry):
	    entry = entry.translate(string.maketrans("\n\t\r", "   ")).strip()
	    #The below part of code will detrmine if any entry has less than 6 columns
	    entrySplit = entry.split()
	    if (len(entrySplit) < 3):
		logging("The below mentioned fstab configuration file entry has less than 3 columns.\n{0}".format(entry))
		return None
	    elif len(entrySplit) > 3:
		optionList = entrySplit[3].split(",")
		if any(re.match ("^\d+", option) for option in optionList):
		    logging("The below mentioned entry has integer option. Please fix it manually.\n{0}".format(entry))
		    return None
	    else:
		pass

    logging("Checking NFS entries in /etc/fstab file and adding nodev option to the mounted NFS devices.")
    timestamp = time.strftime("%Y%m%d-%H%M")
    filename = '/etc/fstab'
    fstabBackupFile = filename + timestamp
    os.rename(filename, fstabBackupFile)
    dest = open(filename, "w")
    src = open(fstabBackupFile, "r")

    fstabLine = ""
    lastLine = ""
    for line in src:
	line = line.translate(string.maketrans("\n\t\r", "   ")).strip()
	#This list contains options of the NFS entry
	optionList = []
	if isL(line):
	    fstabLineList = line.split()
	    if len(fstabLineList) == 3:
		if "Cloud Raxak" not in lastLine:
		    fstabLine = fstabLine + "# Cloud Raxak updated next line\n"
	        line = line + " nodev 0 0"
                lastLine = line
	    else:
	        nfsTypeCheck = runOnShell("echo " + line + " | cut -d' ' -f3", False)
	        if nfsTypeCheck in ["nfs\n", "nfs4\n"]:
		    try: 
		        optionList = fstabLineList[3].split(",")
		    except IndexError:
	    	        logging("The below mentioned fstab entry has configuration issue and not processing this entry.\n{0}".format(line))
			lastLine = line
		        continue

		    #Removing dev and nodev option from option list
		    optionList = [ele for ele in optionList if (ele != "dev")]

                    # Checking, if nodev related option is available or not
                    if not any(mountOption in nodevAvailableList for mountOption in optionList):
		        optionList.append("nodev")
		    optionStr = ",".join(optionList)

		    #If the length of the entry is 5
		    if len(fstabLineList) == 4:
		        fstabLineList.append("0")
		    #If the length of the entry is 6
		    if len(fstabLineList) == 5:
		        fstabLineList.append("0")

		    try:
			if "Cloud Raxak" not in lastLine:
			    fstabLine = fstabLine + "# Cloud Raxak updated next line\n"
		        line = " ".join([fstabLineList[0], fstabLineList[1], fstabLineList[2], optionStr, fstabLineList[4], fstabLineList[5]])
                        lastLine = line
		    except IndexError:
    		        logging("The below mentioned fstab entry has configuration issue and not processing this entry.\n{0}".format(line))
                        lastLine = line
		        continue

	fstabLine = fstabLine + line + "\n"
	lastLine = line

    #Writing all fstab related information into the /etc/fstab file
    dest.write(fstabLine)

    src.close()
    dest.close()

    mountDevRes = runOnShell("mount -t nfs4").splitlines()
    nfsMountDevRes = []
    if OsName.lower == "ubuntu" or ((OsName.lower() == "centos" or OsName.lower() == "redhat") and OsVersion < (7,0)):
	nfsMountDevRes = runOnShell("mount -t nfs").splitlines()

    # The below list contains all 'nfs', and 'nfs4' types
    mountDevRes = mountDevRes + nfsMountDevRes

    #Contains NFS temporary entries
    tmpMountList = []

    for mountEle in mountDevRes:
	mountEleSplit = mountEle.split()
	mountPoint = mountEleSplit[0] + "-->" + mountEleSplit[2]
	tmpMountList.append(mountPoint)

    for entry in fstabAllEntries:
	if not isL(entry):
	    continue
	entry = entry.translate(string.maketrans("\n\t\r", "   ")).strip()
	nfsTypeCheck = runOnShell("echo " + entry + " | cut -d' ' -f3", False)
	if nfsTypeCheck in ["nfs\n", "nfs4\n"]:
	    entry = entry.split()

	    unmountPoint = entry[0] + "-->" + entry[1]
	    if any(unmountPoint in ele for ele in tmpMountList):
                runOnShell("mount -o remount " + entry[1])

def checkRule38653():
    if os.path.isfile('/usr/sbin/snmpd'):
	if not os.path.isfile('/etc/snmp/snmpd.conf'):
	    logging("The snmpd configuration file does not exists. So please check it manually.")
	    return None

	logging("Checking if snmpd service is not using a default password.")
	res = runOnShell('grep -v "^#" /etc/snmp/snmpd.conf| grep -w com2sec ')
	if res == "" or "public" not in res:
	    logging("The snmpd service does not use default password.")
	    return True
	logging("The snmpd service is using default password.")
	return False
    logging("The snmpd service does not exist. So this rule is not applicable.")
    return True

def fixRule38653():
    if not os.path.isfile('/etc/snmp/snmpd.conf'):
	logging("The snmpd configuration file does not exists. So please fix it manually.")
	return None
    logging("Configuring the snmpd service for not using the default password settings.")
    with open("/etc/snmp/snmpd.conf", "r") as openFile:
	communityLine = ""
	for line in openFile:
		if isL(line) and "com2sec" and "public" in line:
			communityLine += ""
		else:
			communityLine += line

	fout = None
	try:
		fout = open("/etc/snmp/snmpd.conf", "wr")
		fout.write(communityLine)
	finally:
		if fout is not None:
			fout.close()

    if(OsName.lower() == 'ubuntu'):
	if "not running" not in runOnShell("/etc/init.d/snmpd  status"):
		logging("Reloading the snmpd service")
		runOnShell("/etc/init.d/snmpd  reload")
    elif (((OsName.lower() == "redhat") or (OsName.lower() == "centos")) and OsVersion >= (7,0)):
	if ("active (running)" in runOnShell ("systemctl status snmpd.service")):
		logging("Reloading the snmpd service")
		runOnShell("systemctl reload snmpd.service")
    else:
	if "stopped" not in runOnShell("/etc/init.d/snmpd  status"):
		logging("Reloading the snmpd service")
		runOnShell("/etc/init.d/snmpd  reload")


def checkRule38654():
    if not os.path.exists("/etc/fstab"):
	logging("The fstab configuration file does not exist which is required to mount the NFS devices. Please fix it manually.")
	return None

    # 'nosuid' is available from the below list of /etc/fstab file
    nosuidAvailableList = ['nosuid', 'user', 'users', 'owner', 'group']

    fstabAllEntries = open("/etc/fstab", 'r').readlines()

    #To find th integer options are avaialble in any valid entry of the fstab file
    optionIntFlag = False
    #To hold the option integer entry in the fstab file
    optionIntStr = ""

    #It uses to check ONLY first time nosuid option
    nosuidFlag = True

    #This list is used to differentiate temporary & permamnet mount devices
    permanantMounts = []

    # It contain the nfs entries in fstab file which don't have nodev option
    notnosuidEntries = ""
    for entry in fstabAllEntries:
	if isL(entry):
	    entry = entry.translate(string.maketrans("\n\t\r", "   ")).strip()
	    #The below part of code will detrmine if any entry has less than 6 columns
	    entrySplit = entry.split()
	    if (len(entrySplit) < 3):
		logging("The below mentioned fstab configuration file entry has less than 3 columns which is wrong configuration. \
Please fix it manually.\n{0}".format(entry))
		return None
	    elif (not optionIntFlag) and (len(entrySplit) > 3):
		optionList = entrySplit[3].split(",")
		if any(re.match ("^\d+", option) for option in optionList):
		    optionIntFlag = True
		    optionIntStr = entry

	    nfsTypeCheck = runOnShell("echo " + entry + " | cut -d' ' -f3", False)
	    if nfsTypeCheck in ["nfs\n", "nfs4\n"]:
		entry = entry.translate(string.maketrans("\n\t\r", "   ")).strip()
		entrySplit = entry.split()
		permanantMounts.append(entrySplit[0] + "-->" + entrySplit[1])

		#Checking this flag to avoid updating flag again
		if nosuidFlag:
		    try:
			optionList = entrySplit[3].split(",")
		    except IndexError:
			logging("The below mentioned NFS entry does not have 'nosuid' option.\n{0}".format(entry))
			return False

		    for option in xrange (len(optionList) - 1, -1, -1):
			if optionList[option] in nosuidAvailableList:
			    nosuidFlag = True
			    break
			elif "suid" == optionList[option]:
			    nosuidFlag = False
			    break
			else:
			    nosuidFlag = None

		    # Here, capturing the nfs entries in fstab which which do not have 'nosuid' option.
		    if not nosuidFlag:
			notnosuidEntries = notnosuidEntries + entry + "\n"

    mountDevRes = runOnShell("mount -t nfs4").splitlines()
    nfsMountDevRes = []
    if OsName.lower == "ubuntu" or ((OsName.lower() == "centos" or OsName.lower() == "redhat") and OsVersion < (7,0)):
	nfsMountDevRes = runOnShell("mount -t nfs").splitlines()

    # The below list contains all 'nfs', and 'nfs4' types
    mountDevRes = mountDevRes + nfsMountDevRes

    #Contains NFS temporary entries
    tmpMountList = []

    for mountEle in mountDevRes:
	mountEleSplit = mountEle.split()
	mountPoint = mountEleSplit[0] + "-->" + mountEleSplit[2]

	#Checking whether mount point is available in fstab file or not
	#If not available, considering as temporary mount
	if mountPoint not in permanantMounts:
	    tmpMountList.append(mountPoint)

    if len(permanantMounts) == 0 or nosuidFlag:
	if len(permanantMounts) == 0:
	    logging("There are no permanent NFS devices mounted on the system.")
	else:
	    logging("The NFS mount points have 'nosuid' option.")
	if len(tmpMountList) > 0:
	    logging("The below mentioned mounts are temporary mounts and can add as part of fstab configuration file \
for permanent mount.\n{0}".format("\n".join(tmpMountList)))
	return True

    if optionIntFlag:
	logging("The below mentioned entry has integer option which is wrong configuration. Please fix it manually.\n{0}".format(optionIntStr))
	return None

    #Checking, if there are any configuration related errors in fstab file
    remountRes = runOnShell("mount -a")
    if "is busy" not in remountRes and remountRes != "":
	logging("The system has wrong fstab entries like NFS Server is not reachable, wrong mount point, and etc. Please fix it manually.")
	return None

    logging("The below mentioned NFS mount entries do not have 'nosuid' option.\n{0}".format(notnosuidEntries))
    return False


def fixRule38654():
    if not os.path.exists("/etc/fstab"):
	logging ("The fstab configuration file does not exist which is required to mount the NFS devices. Please fix it manually.")
	return None

    #The below condition is useful in case of force re-mediation
    logging("Checking if there are any fstab errors.")
    if runOnShell("mount -a") != "":
	return None

    # 'nosuid' is available from the below list of /etc/fstab file
    nosuidAvailableList = ['nosuid', 'user', 'users', 'owner', 'group']

    fstabAllEntries = open("/etc/fstab", 'r').readlines()
    for entry in fstabAllEntries:
	if isL(entry):
	    entry = entry.translate(string.maketrans("\n\t\r", "   ")).strip()
	    #The below part of code will detrmine if any entry has less than 6 columns
	    entrySplit = entry.split()
	    if (len(entrySplit) < 3):
		logging("The below mentioned fstab configuration file entry has less than 3 columns.\n{0}".format(entry))
		return None
	    elif len(entrySplit) > 3:
		optionList = entrySplit[3].split(",")
		if any(re.match ("^\d+", option) for option in optionList):
		    logging("The below mentioned entry has integer option. Please fix it manually.\n{0}".format(entry))
		    return None
	    else:
		pass

    logging("Checking NFS entries in /etc/fstab file and adding nodev option to the mounted NFS devices.")
    timestamp = time.strftime("%Y%m%d-%H%M")
    filename = '/etc/fstab'
    fstabBackupFile = filename + timestamp
    os.rename(filename, fstabBackupFile)
    dest = open(filename, "w")
    src = open(fstabBackupFile, "r")

    fstabLine = ""
    lastLine = ""
    for line in src:
	line = line.translate(string.maketrans("\n\t\r", "   ")).strip()
	#This list contains options of the NFS entry
	optionList = []
	if isL(line):
	    fstabLineList = line.split()
	    if len(fstabLineList) == 3:
		if "Cloud Raxak" not in lastLine:
		    fstabLine = fstabLine + "# Cloud Raxak updated next line\n"
	        line = line + " nosuid 0 0"
                lastLine = line
	    else:
	        nfsTypeCheck = runOnShell("echo " + line + " | cut -d' ' -f3", False)
	        if nfsTypeCheck in ["nfs\n", "nfs4\n"]:
		    try: 
		        optionList = fstabLineList[3].split(",")
		    except IndexError:
	    	        logging("The below mentioned fstab entry has configuration issue and not processing this entry.\n{0}".format(line))
			lastLine = line
		        continue

		    #Removing dev and nodev option from option list
		    optionList = [ele for ele in optionList if (ele != "suid")]
                    # Checking, if nodev related option is available or not
                    if not any(mountOption in nosuidAvailableList for mountOption in optionList):
		        optionList.append("nosuid")
		    optionStr = ",".join(optionList)

		    #If the length of the entry is 5
		    if len(fstabLineList) == 4:
		        fstabLineList.append("0")
		    #If the length of the entry is 6
		    if len(fstabLineList) == 5:
		        fstabLineList.append("0")

		    try:
			if "Cloud Raxak" not in lastLine:
			    fstabLine = fstabLine + "# Cloud Raxak updated next line\n"
		        line = " ".join([fstabLineList[0], fstabLineList[1], fstabLineList[2], optionStr, fstabLineList[4], fstabLineList[5]])
                        lastLine = line
		    except IndexError:
    		        logging("The below mentioned fstab entry has configuration issue and not processing this entry.\n{0}".format(line))
                        lastLine = line
		        continue

	fstabLine = fstabLine + line + "\n"
	lastLine = line

    #Writing all fstab related information into the /etc/fstab file
    dest.write(fstabLine)

    src.close()
    dest.close()

    mountDevRes = runOnShell("mount -t nfs4").splitlines()
    nfsMountDevRes = []
    if OsName.lower == "ubuntu" or ((OsName.lower() == "centos" or OsName.lower() == "redhat") and OsVersion < (7,0)):
	nfsMountDevRes = runOnShell("mount -t nfs").splitlines()

    # The below list contains all 'nfs', and 'nfs4' types
    mountDevRes = mountDevRes + nfsMountDevRes

    tmpMountList = []
    for mountEle in mountDevRes:
	mountEleSplit = mountEle.split()
	mountPoint = mountEleSplit[0] + "-->" + mountEleSplit[2]
	tmpMountList.append(mountPoint)

    for entry in fstabAllEntries:
	if not isL(entry):
	    continue
	entry = entry.translate(string.maketrans("\n\t\r", "   ")).strip()
	nfsTypeCheck = runOnShell("echo " + entry + " | cut -d' ' -f3", False)
	if nfsTypeCheck in ["nfs\n", "nfs4\n"]:
	    entry = entry.split()

	    unmountPoint = entry[0] + "-->" + entry[1]
	    if any(unmountPoint in ele for ele in tmpMountList):
                runOnShell("mount -o remount " + entry[1])

def checkRule38655():
        ''' Description: Checking whether removable media partitions mounted on system is having noexec optoin in /etc/fstab.'''

        #checking for any configuration error in file.(Any entry with less than 6 column.)
        fstabAllEntries = open ("/etc/fstab", 'r').readlines()
        for line in fstabAllEntries:
            if isL(line):
                 line = line.translate(string.maketrans("\n\t\r", "   ")).strip().split()
                 if len(line) < 3:
                      logging ("The below mentioned fstab configuration file entry has less than 3 columns which is wrong configuration. \
Please fix it manually.\n{0}".format (" ".join (line)))
                      return None
        USBDeviceEntry = ""
        flag = True
        noexecFlag = False
        mount_option_list = ["noexec", "user", "users"]
        logging("Finding all the entries that start with /dev and UUID to find the ID_BUS of the removable media partitions mounted on system.")
        res = runOnShell('grep "UUID\|/dev" /etc/fstab | grep -v "^#"')
        res = res.splitlines()
        #Taking the first element of the line and also handling if there is any space at the start of the line.
        device_list = [i.strip(" ").split(" ")[0] for i in res]
        for line in device_list:
            # Handling any space at the start of the line.
            line = line.translate(string.maketrans("\n\t\r", "   ")).strip()
            if not line:
                 continue
            # if device name start with /dev and UUID
            if line.startswith("/dev") or line.startswith("UUID"):
                # If device name start form /dev.
                if line.startswith("/dev"):
                     cmd = "udevadm info -q all -n " + line  + "| grep ID_BUS"
                # If device name start form UUID.
                if line.startswith("UUID"):
                     uuid = line.split("=",1)[1]
                     # Finding the device name for UUID.
                     logging("Finding the device name for UUID.")
                     res2= runOnShell('ls -l /dev/disk/by-uuid/ | grep ' + uuid)
                     device_name = res2.split("/..")[1].strip("\n")
                     cmd = "udevadm info -q all -n /dev" + device_name + "| grep ID_BUS"
                # Find the ID_BUS for the device.
                logging("Finding the ID_BUS of the device " + line + ".")
                id_bus = runOnShell(cmd)
                if "device node not found" in id_bus:
                      continue
                if id_bus:
                      dev_type = id_bus.split("=",1)[1]
                      if "usb" in dev_type:
                           noexecFlag = False
                           logging("Checking whether removable media partitions mounted on system have the ability to execute binary files, in fstab configuration file.")
                           # Comaparing USB device found have entry in /etc/fstab.
                           newList = filter(lambda ele: line in  ele, res)
                           newList = " ".join(newList) #Converting list to string.
                           newList = newList.split()
                           try:
                               mount_option = newList[3].split(',') #Spliting the mount option to check noexec option present or not.
                               #Checking the mount option from right to left.
                               for mount_index in xrange(len(mount_option) - 1, -1, -1):
                                     ele = mount_option[mount_index]
                                     if ele in mount_option_list:
                                           noexecFlag = True
                                           break
                                     elif "exec" in ele:
                                           noexecFlag = None
                                           break
                                     else:
                                           pass
                           except:
                                   noexecFlag = None
                           #Checking for exec option present before noexec or not present in line.
                           if not noexecFlag:
                                 #Checking for any configuration error in file.(any device with wrong mounting point.)
                                 for line in fstabAllEntries:
                                     if isL(line):
                                          line = line.translate(string.maketrans("\n\t\r", "   ")).strip().split()
                                          if len(line) > 3:
                                             optionList = line[3].split(",")
                                             if any (re.match ("^\d+", option) for option in optionList):
                                                 logging ("The below mentioned entry has integer option. Please fix it manually.\n{0}".format (" ".join (line)))
                                                 return None
                                 check_conf_error = runOnShell('mount -a')
                                 if check_conf_error != "":
                                       logging("File /etc/fstab is having some configuration error.Please check /etc/fstab file manually.")
                                       return None
                                 USBDeviceEntry = USBDeviceEntry + ", " +" ".join(newList)
                                 flag = False
            else:
                 continue

        #If there is no device available.
        if flag and not noexecFlag:
           logging("No removable media found.")
           return True

        USBDeviceEntry = USBDeviceEntry.lstrip(", ")
        if USBDeviceEntry:
            logging("Removable media partitions mounted on system have entry in /etc/fstab with no 'noexec' option. \nCheck the following entry mentioned below.\n'" + USBDeviceEntry + "'")
        else:
            logging("Removable media partitions mounted on system do not have the ability to execute binary files.")
        return flag

def fixRule38655():
        ''' Description: Adding noexec option to removable media partitions mounted on system in /etc/fstab.'''

        lastLine = ""
        flag = False
        noexecFlag = False
        filename = '/etc/fstab'
        #checking for any configuration error in file.(Any entry with less than 6 column.)
        with open(filename, "r") as fileContent:
             for line in fileContent:
                 if isL(line):
                      line = line.translate(string.maketrans("\n\t\r", "   ")).strip().split()
                      if len(line) < 3:
                           logging ("The below mentioned fstab configuration file entry has less than 3 columns which is wrong configuration. \
Please fix it manually.\n{0}".format (" ".join (line)))
                           return None
                      #Checking for any configuration error in file.(any device with wrong mounting point.)
                      elif len(line) > 3:
                           optionList = line[3].split(",")
                           if any (re.match ("^\d+", option) for option in optionList):
                              logging ("The below mentioned entry has integer option. Please fix it manually.\n{0}".format (" ".join (line)))
                              return None

        # Taking backup of fstab file.
        fileContent = open (filename, "r").readlines()
        timestamp = time.strftime("%Y%m%d-%H%M")
        fstabBackupFile = filename + timestamp
        shutil.copyfile(filename,fstabBackupFile)

        logging("Finding all the entries that start with /dev and UUID to find the ID_BUS of the removable media partitions mounted on system.")
        mount_option_list = ["noexec", "user", "users"]
        res = runOnShell('grep "UUID\|/dev" /etc/fstab | grep -v "^#"')
        res = res.splitlines()
        #Taking the first element of the line and also handling if there is any space at the start of the line.
        device_list = [i.strip(" ").split(" ")[0] for i in res]
        device_name = ''
        for firsEle in device_list:
            # Handling any space at the start of the line.
            firsEle = firsEle.translate(string.maketrans("\n\t\r", "   ")).strip()
            if not firsEle:
                 continue
            # If device name start with /dev and UUID
            if firsEle.startswith("UUID") or firsEle.startswith("/dev"):
               # If device name start form /dev.
               if firsEle.startswith("/dev"):
                   cmd = "udevadm info -q all -n " + firsEle + "| grep ID_BUS"
                   device_name = firsEle
               # If device name start form UUID.
               if firsEle.startswith("UUID"):
                   uuid = firsEle.split("=",1)[1]
                   # Finding the device name for UUID.
                   res2= runOnShell('ls -l /dev/disk/by-uuid/ | grep ' + uuid)
                   logging("Finding the device name for UUID.")
                   device_name = res2.split("/..")[1].strip("\n")
                   device_name = "/dev" + device_name
                   cmd = "udevadm info -q all -n " + device_name + "| grep ID_BUS"
               # Find the ID_BUS for the device.
               logging("Finding the ID_BUS of the device.")
               id_bus = runOnShell(cmd)
               if "device node not found" in id_bus:
                     continue
               if id_bus:
                     dev_type = id_bus.split("=",1)[1]
                     if "usb" in dev_type:
                          logging("Checking whether removable media partitions mounted on system have the ability to execute binary files, \
in fstab configuration file.")
                          # Comaparing USB device found have entry in /etc/fstab.
                          newList = filter(lambda ele: firsEle in  ele, res)
                          newList = " ".join(newList) #Converting list to string.
                          newList_split = newList.split()
                          optionList = []
                          try:
                                 mount_option = newList_split[3].split(',') #Spliting the mount option to check noexec option present or not.
                                 #Checking the mount option from right to left.
                                 optionList = [ele for ele in mount_option if (ele != "exec")]
                          except:
                                 pass
                          if not any(mountOption in mount_option_list for mountOption in optionList):
                              optionList.append('noexec')
                          with open (filename, "r") as fileContent:
                               newLine = ""
                               for line in fileContent:
                                   if newList in line:
                                       logging(newList + ' adding noexec in forth parameter')
                                       if len(newList_split) > 3:
                                           if len(newList_split) == 4:
                                              newList_split.append("0")
                                           if len(newList_split) == 5:
                                              newList_split.append("0")
                                           if "Cloud Raxak updated next line" not in lastLine:
                                               lastLine += "# Cloud Raxak updated next line\n"
                                           newLine += newList_split[0] + " " + newList_split[1] + " "  + newList_split[2] + " " + ",".join(optionList) + " " + newList_split[4] + " " + newList_split[5] + "\n"
                                       elif len(newList_split) == 3:
                                           if "Cloud Raxak updated next line" not in lastLine:
                                               lastLine += "# Cloud Raxak updated next line\n"
                                           newLine += newList_split[0] + " " + newList_split[1] + " "  + newList_split[2] + " " + ",".join(optionList) + " 0 0" + "\n"
                                   else:
                                       newLine += line
                          fout = None
                          try:
                              fout = open(filename, 'wt')
                              fout.write(newLine)
                          finally:
                              if (fout is not None):
                                  fout.close()
                          logging("Changes made in fstab configuration file, umounting the device to apply changes.")
                          runOnShell("umount " + device_name)
                          runOnShell("mount -a")
                     else:
                          pass
            else:
                continue

def checkRule38656():
    if not os.path.exists('/etc/samba/smb.conf'):
        logging("Samba client is not in use.")
        return True

    logging("Checking the Samba clients running samba client and must be using packet signing.")
    checkGlobal = runOnShell('grep -w "\[global\]\s*" /etc/samba/smb.conf | grep -v "^#"')
    if not checkGlobal:
        logging("The global section in the configuration file does not exist, hence need to fix this manually.")
        return None

    checkResult = runOnShell('grep -w signing /etc/samba/smb.conf | grep -v "^#"')
    checkResultSplit = checkResult.splitlines()
    matchGlobal = False
    with open("/etc/samba/smb.conf", "r") as fileContent:
        for line in fileContent:
            matchObj = re.match(r'.*(\[.*\])',line)
            if matchObj != None:
                if tokenMatchIC("[global]", matchObj.group(1)):
                    matchGlobal = True
                else:
                    matchGlobal = False
            if matchGlobal:
                if "signing" in line and isL(line):
                    for element in checkResultSplit:
                        if re.search(r'client\ssigning\s=\s\w',element) != None:
                            if keyValEqMatch("client signing", 'mandatory', element):
                                logging("The client is required to use SMB signing.")
                                return True
        logging("The client is not required to use SMB signing.")
        return False

def fixRule38656():
        checkGlobal = runOnShell('grep -w "\[global\]\s*" /etc/samba/smb.conf | grep -v "^#"')
        if not checkGlobal:
            logging("The global section in the configuration file does not exist, hence need to fix this manually.")
            return None

        if os.path.exists("/etc/samba/smb.conf"):
            res = runOnShell('grep -w signing /etc/samba/smb.conf | grep -v "^#"')
            matchGlobal = False
            clientMatchFlag = False
	    # Checking for the [global] section in the configuration file.
            with open("/etc/samba/smb.conf", "r") as file_content:
                for line in file_content:
                    matchObj = re.match(r'.*(\[.*\])',line)
                    if matchObj != None:
                        if tokenMatchIC("[global]", matchObj.group(1)):
                            matchGlobal = True
                        else:
                            matchGlobal = False
                    if matchGlobal:
                        if "signing" in line and isL(line):
                            res_split = res.translate(string.maketrans("\n\t\r", "   "))
                            if tokenMatchIC("client signing",res_split):
                                clientMatchFlag = True
                                break
            with open("/etc/samba/smb.conf", "r") as file_content:
                    fileString = ""
                    lastLine = ""
                    matchLine = False
                    for line in file_content:
                        #If pattern exist with wrong value.
                        if clientMatchFlag and isL(line) and "signing" in line:
                            line = line.translate(string.maketrans("\n\t\r", "   ")).strip()
                            serachObj = re.search(r'client\ssigning\s=\w*',line)
                            if serachObj:
                                start = line.index("client signing =")
                                new = line[start:]
                                try:
                                    end = new.index(" ")
                                    if "Cloud Raxak updated next line" not in lastLine:
                                        fileString += "# Cloud Raxak updated next line\n"
                                    fileString += line[0:start] + "client signing = mandatory\n"
                                except:
                                    end = 25
                                    if "Cloud Raxak updated next line" not in lastLine:
                                        fileString += "# Cloud Raxak updated next line\n"
                                    fileString += line[0:start] + "client signing = mandatory" + line[start+end:len(line[start:])] + "\n"
                            matchLine = True
                        elif not clientMatchFlag:
                            if not matchLine:
                                if "signing" in line:
                                    continue
                                elif re.search('^\[global\]\s',line,re.M|re.I):
                                    fileString += line +"# Cloud Raxak updated next line\nclient signing = mandatory\n"
                                    continue
                            fileString += line
                        else:
                            fileString += line
                        lastLine = line
            fout = None
            fout = open("/etc/samba/smb.conf", "wt")
            if fout != None:
                fout.write(fileString)
                fout.close()

def checkRule38657():
	logging("Checking if cifs-utils service is installed on the system.")
	if OsName.lower() == "ubuntu":
		res1 = runOnShell('dpkg -s cifs-utils')
	else:
	        res1 = runOnShell('rpm -q cifs-utils')

	if ('is not installed' in res1) or ('deinstall ok' in res1):
		logging("cifs-utils package does not exist.")
		return True  
	logging('Checking "cifs" parameter in "/etc/fstab" and in "/etc/mtab".')
        res = runOnShell('grep cifs /etc/fstab /etc/mtab | grep -v "#"')
	if res == "" :
		logging('"cifs" parameter does not exist in "/etc/fstab" or "/etc/mtab".')
		return True
	res = res.split("\n")
	for line in res:
		if "sec=" in line:
			splitRes = line.split()[3]
			secSplit = splitRes.split("sec=")[1]
			secSplit = secSplit.split(",")
			if any ((ele == "ntlmv2i") or (ele == "krb5i") for ele in secSplit):
				logging('"sec=krb5i" or "sec=ntlmv2i" parameter is exist in "/etc/fstab" or "/etc/mtab".')
				return True
	logging('"sec=krb5i" or "sec=ntlmv2i" parameter does not exist in "/etc/fstab" or "/etc/mtab". Hence need to fix it manually.')
	return None

def fixRule38657():
	logging("Require packet signing of clients who mount samba shares using the 'mount.cifs' program (e.g., those who specify shares in '/etc/fstab'). To do so, ensure signing options (either 'sec=krb5i' or 'sec=ntlmv2i') are used. See the 'mount.cifs(8)' man page for more information. A samba client should only communicate with servers who can support SMB packet signing.")
	return None

def checkRule38658(val = 24):
	count = 0
	remember_correct = 24
	if OsName.lower() == "ubuntu":
		filePath = "/etc/pam.d/common-password"
	else:
		filePath = "/etc/pam.d/system-auth"

        if not os.path.exists(filePath):
            logging("File path " + filePath + " does not exist. Please fix this manually.")
            return None

	logging("Checking that the previous passwords must not be reused by a user.")
	check_result = runOnShell('grep -w pam_unix.so ' + filePath +' | grep -w password | grep -v "^#"')
	check_result = check_result.translate(string.maketrans("\n\t\r", "   ")).strip()
	match_obj = re.match(r'.*\s*(\bremember=-?\w*\b)\s*', check_result)
	if (match_obj):
	    parameter = match_obj.group(1)
	    actual_param,param_value =  parameter.split("=")
	    if param_value != "":
		try:
		    if int(param_value) >= val:
			logging("Parameter to check the previous password reusage is correctly configured.")
			return True
		except ValueError:
		    logging("Parameter to check the previous password reusage is not correctly configured.")
		    return False
	logging("The parameter to check the previous password reusage does not exist.")
	return False

def fixRule38658():
	if OsName.lower() == "ubuntu":
	    filePath = "/etc/pam.d/common-password"
	else:
	    filePath = "/etc/pam.d/system-auth"

        if not os.path.exists(filePath):
            logging("File path " + filePath + " does not exist. Please fix this manually.")
            return None

	check_result = runOnShell('grep -w pam_unix.so ' + filePath +' | grep -w password | grep -v "^#"')
	with open(filePath, "r") as file_content:
	    lastLine = ""
            file_string = ""
	    flag = False
            match_passwd_module_line = False
            for line in file_content:
		if OsName.lower() == "ubuntu":
		    module_search_obj = re.search('password\s*\[success\=1\sdefault\=ignore\]\s*pam_unix.so',line)
		else:
		    module_search_obj = re.search('^password\s*sufficient\s*pam_unix.so', line)
		if module_search_obj != None and check_result != "":
			flag = True
			if isL(line) and "remember" in line:
			    line = line.translate(string.maketrans("\n\t\r", "   ")).strip()
			    start = line.index("remember")
			    new = line[start:]
			    try:
				end = new.index(" ")
				line = line[0:start] + "remember=24" + line[start+end:]
			    except Exception as e:
				end = 11
				line = line[0:start] + "remember=24" + line[start+end:len(line[start:])]
			else:
			    line = line.translate(string.maketrans("\n", " ")).strip()
			    line = line+' remember=24'
			file_string += line + '\n'
		elif check_result == '':
		    if not match_passwd_module_line:
			if OsName.lower() == "ubuntu":
			    search_line =  re.search('^password\s*requisite\s*pam_deny.so',line)
			else:
			    search_line =  re.search('^password\s*required\s*pam_deny.so',line)
			
			if search_line != None:
			    logging("Updating the password reuse settings.")
			    if OsName.lower() == "ubuntu":
				file_string += "password    [success=1 default=ignore] pam_unix.so obscure use_authtok try_first_pass sha512 remember=24\n"
			    else:
				file_string += "password    sufficient pam_unix.so shadow use_authtok try_first_pass sha512 remember=24\n"
			        match_passwd_module_line = True
			file_string += line
		else:
		    file_string += line
	fout = None
        try:
        	fout = open(filePath, "wt")
        	fout.write(file_string)
        finally:
        	if (fout is not None):
        		fout.close()

def checkRule38659():
        #ASG: This is a manual intervention rule hence should go into manual tab, 
        #let the administrator confirm whether the operating system have a cryptographic mechanisms to protect data on the system. 
	#And if cryptographic mechanisms already is in use then user can mark this rule manually as successful
        logging("The operating system must employ cryptographic mechanisms to protect information in storage. The easiest way to encrypt a partition is during installation time. The cryptographic mechanisms need user input. So if cryptographic mechanisms are required for your environment then please implement it manually with required settings.")
        return None

def fixRule38659():
	logging("The easiest way to encrypt a partition is during installation time. The cryptographic mechanisms need user input.\
So if cryptographic mechanisms are required for your environment then please implement it manually with required settings.")
        return None

def checkRule38660():
	#Checking the existence of package.
	if not (os.path.isfile('/usr/sbin/snmpd')):
		logging("The snmpd service does not exists. So this rule is not applicable.")
		return True

	if not (os.path.isfile('/etc/snmp/snmpd.conf')):
		logging("The snmpd configuration file does not exists. So please check it manually.")
		return None

	logging("Checking SNMP protocol version.")
	res = runOnShell("grep 'v1\|v2c\|com2sec' /etc/snmp/snmpd.conf | grep -v '#'")

	if res=="":
	    logging("The snmpd service is using SNMP protocol version 3 or newer.")
	    return True

        if re.search("v1", res) or re.search("v2c", res) or re.search("com2sec", res):
	    logging("The snmpd service is not using SNMP protocol version 3 or newer.")
	    return False

	logging("The snmpd service is using SNMP protocol version 3 or newer.")
	return True

def fixRule38660():
    if not (os.path.isfile('/etc/snmp/snmpd.conf')):
	logging("The snmpd configuration file does not exists. So please fix manually.")
	return None
    match_token_lis = ["v2c","v1","com2sec"]
    logging ("Opening snmpd configuration to remove unnecessary SNMP version.")
    with open("/etc/snmp/snmpd.conf", "r") as f:
        s = ""
        for line in f:
	   continue_flag=False
	   tmpLine = re.sub(' +', '', line)
	   if isL(tmpLine):
		for token in match_token_lis:
			if token in line:
				continue_flag = True
		if continue_flag:
			continue
           s += line

    fout = None
    try:
	logging("Removing \"v1\", \"v2c\", or \"com2sec \" version entries from /etc/snmp/snmpd.conf.")
	fout = open("/etc/snmp/snmpd.conf", 'wt')
	fout.write(s)
    except:
	pass
    finally:
	if fout is not None:
	    fout.close()

    if(OsName.lower() == 'ubuntu'):
	if "not running" not in runOnShell("/etc/init.d/snmpd  status"):
		logging("Reloading the snmpd service")
		runOnShell("/etc/init.d/snmpd  reload")
    elif (((OsName.lower() == "redhat") or (OsName.lower() == "centos")) and OsVersion >= (7,0)):
	if ("active (running)" in runOnShell ("systemctl status snmpd.service")):
		logging("Reloading the snmpd service")
		runOnShell("systemctl reload snmpd.service")
    else:
	if "stopped" not in runOnShell("/etc/init.d/snmpd  status"):
		logging("Reloading the snmpd service")
		runOnShell("/etc/init.d/snmpd  reload")


def checkRule51337():
	if OsName.lower() == "ubuntu":
		# Checking which linux security module is installed in ubuntu.
		ubuntuSelinuxFlag = False
		if CheckPackage("selinux"):
			ubuntuSelinuxFlag = True # linux security module selinux is installed in ubuntu.
	if ((OsName.lower() == "redhat") or (OsName.lower() == "centos") or (OsName.lower() == "amazon linux ami")) or (ubuntuSelinuxFlag):
		if not os.path.exists("/etc/selinux/config"):
			logging ("The linux security module configuration file is not available. please check it manually.")
			return None
		logging ("Checking if linux security module is disabled at boot time.")
		selinuxMode = runOnShell('grep -w SELINUX /etc/selinux/config | grep -v "^#"')
		if selinuxMode == "":
			logging("SElinux is disabled at boot time.")
			return False
		selinuxMode = selinuxMode.translate(string.maketrans("\t\n\r", "   "))
		selinuxMode = re.sub('\s+', '', selinuxMode)
		if(re.match(r'.*\s*(\bSELINUX=disabled\b)\s*', selinuxMode)):
			logging("SElinux is disabled at boot time.")
			return False
	if OsName.lower() == "ubuntu":
		filePath = '/etc/default/grub'
		testString = "GRUB_CMDLINE_LINUX_DEFAULT"
		if not os.path.exists("/boot/grub/grub.cfg"):
			logging ("The grub file does not exist. Hence, fix it manually.")
			return None
		logging("Checking the grubfile permissions.")
		if int(runOnShell ('stat -c "%a" /boot/grub/grub.cfg')) == 600:
			logging("Updating grub file.")
			grubStatus = runOnShell("update-grub")
			logging("The system boot loader configuration file(s) must have mode 0600 or less permissive, reverting the permission to 0600 as the permission of boot loader configuration file has been changed to 0444 after executing the 'update-grub' command")
			runOnShell('chmod 0600 /boot/grub/grub.cfg')
		else:
			logging("Updating grub file.")
			grubStatus = runOnShell("update-grub", False)

		if ("Syntax error" in grubStatus) or ("not found" in grubStatus):
			logging("Since there is a syntax error in the grub file, need manual intervention to fix the grub syntax error.")
			return None
	elif ((OsName.lower() == "redhat") or (OsName.lower() == "centos")) and OsVersion >= (7,0):
		filePath = '/etc/default/grub'
		testString = "GRUB_CMDLINE_LINUX"

		if not os.path.exists("/boot/grub2/grub.cfg"):
			logging ("The grub file does not exists, hence fix it manually.")
			return None
		logging("Updating the grub file.")
		grubStatus = runOnShell ("grub2-mkconfig -o /boot/grub2/grub.cfg")
		if ("Syntax error" in grubStatus) or ("not found" in grubStatus):
			logging("Since there is a syntax error in the grub file, need manual intervention to fix the grub syntax error.")
			return None
	else:
		filePath = '/etc/grub.conf'
		testString = "kernel"

	logging ("Checking the kernel boot arguments if linux security module is disabled at boot time.")
	securitymoduleStatus = runOnShell('grep -w ' + testString +'  '+ filePath + ' | grep -v "^#"')
	if securitymoduleStatus == "":
		logging("kernel parameter line does not exist in grub file, hence fix it manually.")
		return None
	securitymoduleStatus = securitymoduleStatus.translate(string.maketrans("\t\n\r", "   "))

	if OsName.lower() == "ubuntu":
		try:
			securityModuleStatusList = securitymoduleStatus.split('"')[1]
		except IndexError:
			logging("Since there is a syntax error in the grub file, need manual intervention to fix the grub syntax error.")
			return None
		# Checking the apparmor is enabled or not.
		if not ubuntuSelinuxFlag and (re.search(r'.*\s*(\bapparmor=0\b)\s*', securityModuleStatusList) or (re.search(r'.*\s*(\bsecurity=selinux\b)\s*', securityModuleStatusList))):
			logging ("The linux security module is disabled at boot time.")
			return False
		# Checking the selinux is enabled or not.
		elif ubuntuSelinuxFlag and not (re.search(r'.*\s*(\bsecurity=selinux\b)\s*', securityModuleStatusList) and (re.search(r'.*\s*(\bselinux=1\b)\s*', securityModuleStatusList))):
			logging ("The linux security module is disabled at boot time.")
			return False
	else:
		if (re.search(r'.*\s*(\bselinux=0\b)\s*', securitymoduleStatus)):
			logging("SElinux is disabled at boot time.")
			return False
	logging("The linux security module is enabled at boot time.")
	return True


def fixRule51337():
	if OsName.lower() == "ubuntu":
		# Checking which linux security module is installed in ubuntu.
		ubuntuSelinuxFlag = False
		if CheckPackage("selinux"):
			ubuntuSelinuxFlag = True # linux security module selinux is installed in ubuntu.
	if ((OsName.lower() == "redhat") or (OsName.lower() == "centos")) or (ubuntuSelinuxFlag):
		if OsName.lower() == "ubuntu":
			selinuxConfigVar = "SELINUX=permissive"
		else:
			selinuxConfigVar = "SELINUX=enforcing"
		# If Selinux is installed in ubuntu then checking the selinux status in config file.
		with open('/etc/selinux/config', 'r') as selinuxFile:
			selinuxModeline = ""
			lastLine = ""
			flag = False
			for selinuxLine in selinuxFile:
				selinuxLinesub = re.sub('\s+', '', selinuxLine)
				if isL(selinuxLine) and re.search("SELINUX=", selinuxLinesub):
					flag = True
					if not tokenMatch('Cloud Raxak updated next line', lastLine):
						selinuxModeline += "# Cloud Raxak updated next line\n"
					logging("Enabling the SElinux status by updating the SElinux configuration file.")
					#selinuxModeline += "SELINUX=permissive\n"
					selinuxModeline += selinuxConfigVar + "\n"
				else:
					selinuxModeline += selinuxLine
					lastLine = selinuxLine
			if not(flag):
				logging("Enabling the SElinux status by updating the SElinux configuration file.")
				if not tokenMatch('Cloud Raxak updated next line', lastLine):
					selinuxModeline += "# Cloud Raxak updated next line\n"
				selinuxModeline += "SELINUX=permissive\n"
		fout = open("/etc/selinux/config", "wr")
		if fout != None:
			fout.write(selinuxModeline)
			fout.close()

	if OsName.lower() == "ubuntu":
		with open('/etc/default/grub', 'r') as grubFile:
			kernelLine = ""
			lastLine = ""
			selinuxFlag = False
			for line in grubFile:
				if isL(line) and re.search("GRUB_CMDLINE_LINUX_DEFAULT", line):
					# If security module is apparmor
					if not ubuntuSelinuxFlag:
						# If apparmor is disabled with apparmor=0
						if (re.search(r'.*\s*(\bapparmor=0\b)\s*', line)):
							if not tokenMatch('Cloud Raxak updated next line', lastLine):
								kernelLine += "# Cloud Raxak updated next line\n"
							kernelLine += line.replace("apparmor=0", "")
						# If apparmor is disabled with security=selinux
						elif (re.search(r'.*\s*(\bsecurity=selinux\b)\s*', line)):
							if not tokenMatch('Cloud Raxak updated next line', lastLine):
								kernelLine += "# Cloud Raxak updated next line\n"
							kernelLine += line.replace("security=selinux", "")
						else:
							kernelLine += line
							lastLine = line
					# If security module is selinux
					elif ubuntuSelinuxFlag:
						# If selinux is disabled with selinux=0
						if (re.search(r'.*\s*(\bselinux=0\b)\s*', line)):
							line = line.replace("selinux=0", "selinux=1")
						# If selinux is disable with no exstence of security=selinux and selinux=0 parameters.
						if not (re.search(r'.*\s*(\bsecurity=selinux\b)\s*', line)) and not (re.search(r'.*\s*(\bselinux=1\b)\s*', line)):
							if not tokenMatch('Cloud Raxak updated next line', lastLine):
								kernelLine += "# Cloud Raxak updated next line\n"
							kernelOptions = line.split('"')
							kernelLine += kernelOptions[0] + "\"" + kernelOptions[1] + " security=selinux selinux=1\"" + "\n"
						# If selinux is disable with no existence of security=selinux parameter.
						elif (re.search(r'.*\s*(\bselinux=1\b)\s*', line)) and not(re.search(r'.*\s*(\bsecurity=selinux\b)\s*', line)):
							if not tokenMatch('Cloud Raxak updated next line', lastLine):
								kernelLine += "# Cloud Raxak updated next line\n"
							kernelOptions = line.split('"')
							kernelLine +=  kernelOptions[0] + "\"" + kernelOptions[1] + " security=selinux\"" + "\n"
						# If selinux is disable with no existence of selinux=1 parameter.
						elif (re.search(r'.*\s*(\bsecurity=selinux\b)\s*', line)) and not(re.search(r'.*\s*(\bselinux=1\b)\s*', line)):
							if not tokenMatch('Cloud Raxak updated next line', lastLine):
								kernelLine += "# Cloud Raxak updated next line\n"
							kernelOptions = line.split('"')
							kernelLine +=  kernelOptions[0] + "\"" + kernelOptions[1] + " selinux=1\"" + "\n"
						else:
							kernelLine += line
							lastLine = line
				else:
					kernelLine += line
					lastLine = line

		fout = open("/etc/default/grub", "wr")
		if fout != None:
			fout.write(kernelLine)
			fout.close()
	else:
		if (((OsName.lower() == "redhat") or (OsName.lower() == "centos")) and OsVersion >= (7,0)):
			filePath = "/etc/default/grub"
			testString ="GRUB_CMDLINE_LINUX"
		else:
			filePath = "/etc/grub.conf"
			testString ="kernel"

		# grubfile
		with open(filePath, 'r') as grubFile:
			kernelLine = ""
			lastLine = ""
			for line in grubFile:
				if isL(line) and re.search(testString, line):
					if(re.search(r'.*\s*(\bselinux=0\b)\s*', line)):
						if not tokenMatch('Cloud Raxak updated next line', lastLine):
							kernelLine += "# Cloud Raxak updated next line\n"
						logging("Configuring the grub file to prevent linux security module \
from being disabled at boot.")
						kernelLine += line.replace("selinux=0", "")
					else:
						kernelLine += line
						lastLine = line
				else:
					kernelLine += line
					lastLine = line

		fout = open(filePath, "wr")
		if fout != None:
			fout.write(kernelLine)
			fout.close()
	logging("Need to reboot the system to reflect linux security module changes.")


def checkRule51363():
    ''' Description: check if the Linux security module state is set to enforcing. '''
    logging ("Checking if the linux security module is configured to enforce mode.")
    if OsName.lower() == "ubuntu":
        apparmorState = runOnShell('apparmor_status', False).splitlines()
	noofComplainProfile = runOnShell('apparmor_status --complaining')
	
        for idx in range (0, len(apparmorState)):
            if "profiles are in complain" in apparmorState[idx] and "0" not in apparmorState[idx]:
	        complainLine =  apparmorState[idx]
                complainProfileIndex = apparmorState.index(complainLine) + 1
                try:
                    # Listing all complain profile paths based on index of first complain profile to last complian profile path.
                    complainProfilePath = apparmorState[complainProfileIndex : complainProfileIndex + int(noofComplainProfile)]
                except (ValueError, TypeError):
                    logging ("Configuration error in Linux security module, please check it manually.")
                    return None
                if complainProfilePath:
                    logging ("The " + ", ".join(complainProfilePath) + " profile(s) not in enforcing mode.")
                    return False

	logging("The Linux security enhancement status is configured with enforcing mode.")
        return True
    else:
        if not os.path.exists("/etc/selinux/config"):
            logging ("The linux security module configuration file is not available. please check it manually.")
            return None
        selinuxState = runOnShell('grep -w SELINUX=enforcing /etc/selinux/config | grep -v "^#"')
        if selinuxState != "":
            logging("The Linux security enhancement status is configured with enforcing mode.")
            return True
        logging("The Linux security enhancement status is not properly configured with enforcing mode.")
        return False

def fixRule51363():
    ''' Description: set the linux security module state to enforcing. '''
    if OsName.lower() == "ubuntu":
	apparmorState = runOnShell('apparmor_status', False).splitlines()
	noofComplainProfile = runOnShell('apparmor_status --complaining')
        profileList = []
        for idx in range (0, len(apparmorState)):
            if "profiles are in complain" in apparmorState[idx] and "0" not in apparmorState[idx]:
	        complainLine =  apparmorState[idx]
                complainProfileIndex = apparmorState.index(complainLine) + 1
                try:
                    # Listing all the complian profile file paths.
                    complainProfilePath = apparmorState[complainProfileIndex : complainProfileIndex + int(noofComplainProfile)]
                except (ValueError, TypeError):
                    logging ("Configuration error in Linux security module, please check it manually.")
                    return None
                for cmpPath in complainProfilePath:
                    cmpPath = cmpPath.strip()
                    if os.path.isfile(cmpPath):
                        logging("Configuring the linux security module to enforcing mode.")
                        runOnShell('aa-enforce  ' + cmpPath)
    else:
        if not os.path.exists("/etc/selinux/config"):
            logging ("The linux security module configuration file is not available. please check it manually.")
            return None

        with open("/etc/selinux/config", "r") as selinuxConfigFile:
            flag = False
            selinuxStateLine = ""
            lastLine = ""
            for line in selinuxConfigFile:
                if isL(line) and tokenMatch("SELINUX", line.split("=")[0]):
                    if not tokenMatch('Cloud Raxak updated next line', lastLine):
                        selinuxStateLine += "# Cloud Raxak updated next line\n"
                    logging("Configuring the linux security module to enforcing mode.")
                    selinuxStateLine += "SELINUX=enforcing\n"
                    flag = True
                else:
                    selinuxStateLine += line
                    lastLine = line
            if not(flag):
                if not tokenMatch('Cloud Raxak updated next line',lastLine):
                    selinuxStateLine += "# Cloud Raxak updated next line\n"
                logging("Configuring the linux security module to enforcing mode.")
                selinuxStateLine += "SELINUX=enforcing\n"

        fout = None
        fout = open('/etc/selinux/config', 'wt')
        if fout != None:
            fout.write(selinuxStateLine)
            fout.close()
	logging("Please reboot the system to get effect the linux security module configuration changes.")


def checkRule51369():
    ''' Description: Check the linux security module policy is set to targeted. '''
    if OsName.lower() == "ubuntu":
        logging ("Linux security module Apparmor does not work in the same way as Selinux security module, So \
this rule is not applicable for ubuntu.")
        return True
    else:
        if not os.path.exists("/etc/selinux/config"):
            logging ("The linux security module configuration file is not available. please check it manually.")
            return None
        selinuxType = runOnShell('grep -w SELINUXTYPE=targeted /etc/selinux/config')
        if selinuxType != "":
            logging("The linux security module policy is configured with targeted.")
            return True
        logging("The linux security module policy is not configured with targeted.")
        return False

def fixRule51369():
    ''' Description: setting the linux security module policy is set to targeted. '''
    if OsName.lower() == "ubuntu":
        logging ("Linux security module Apparmor does not work in the same way as Selinux security module, So \
this rule is not applicable for ubuntu.")
        return True
    else:
        with open("/etc/selinux/config", "r") as selinuxConfigFile:
            flag = False
            selinuxTypeLine = ""
            lastLine = ""
            for line in selinuxConfigFile:
                if isL(line) and tokenMatch("SELINUXTYPE", line.split("=")[0]):
                    if not tokenMatch('Cloud Raxak updated next line', lastLine):
                        selinuxTypeLine += "# Cloud Raxak updated next line\n"
		    logging("Configuring the linux system module policy to targeted.")
                    selinuxTypeLine += "SELINUXTYPE=targeted\n"
                    flag = True
                else:
                    selinuxTypeLine += line
                    lastLine = line
            if not(flag):
                if not tokenMatch('Cloud Raxak updated next line',lastLine):
                    selinuxTypeLine += "# Cloud Raxak updated next line\n"
		logging("Configuring the linux system module policy to targeted.")
                selinuxTypeLine += "SELINUXTYPE=targeted\n"

        fout = None
        fout = open('/etc/selinux/config', 'wt')
        if fout != None:
            fout.write(selinuxTypeLine)
            fout.close()
        logging("Please reboot the system to get effect the linux security module configuration changes.")

def checkRule51379():
    ''' Description: Check the device file(s) is monitored by the system linux security module. '''
    if OsName.lower() == "ubuntu":
        if CheckPackage("apparmor"):
            logging("Linux Security module Apparmor does not label or relabel the filesystem, so this rule is not applicable for ubuntu.")
            return True
        ubuntuSelinuxFlag = False
        if CheckPackage("selinux"):
            logging ("Checking if the Selinux is enabled.")
            if "enabled" in runOnShell('sestatus | grep "SELinux status:"'):
                ubuntuSelinuxFlag = True # linux security module selinux is installed in ubuntu.
            else:
                logging("The security module selinux exist but it is disabled, so please check it manually.")
                return None
        else:
            logging ("There is no security module installed in the system, so please check it manually.")
            return None

    if OsName.lower() == "centos" or OsName.lower() == "redhat" or ubuntuSelinuxFlag:
	logging ("Checking for unlabeled device files.")
        unlabelDir = runOnShell("find /dev -exec stat --format=%n,%C {} \; |grep unlabeled_t |awk -F',' '{print $1}'")
        if unlabelDir == "":
	    logging("All device files are monitored by the system linux security module.")
            return True
        unlabelDir = ", ".join( unlabelDir.splitlines())
        logging ("The '" + unlabelDir + "' device file(s) are not monitored by the system linux security module.")
        return False

def fixRule51379():
    ''' Description: set the proper lables to device files. '''
    if OsName.lower() == "ubuntu":
        ubuntuSelinuxFlag = False
        if (not CheckPackage("apparmor")) and CheckPackage("selinux"):
            logging ("Checking if the Selinux is enabled.")
            if "enabled" in runOnShell('sestatus | grep "SELinux status:"'):
                ubuntuSelinuxFlag = True # linux security module selinux is installed in ubuntu.
            else:
                logging("The security module selinux exist but it is disabled, so please check it manually.")
                return None

    if OsName.lower() == "centos" or OsName.lower() == "redhat" or ubuntuSelinuxFlag:
        unlabelDir = runOnShell("find /dev -exec stat --format=%n,%C {} \; |grep unlabeled_t |awk -F',' '{print $1}'")
        if unlabelDir != "":
            unlabelDir = unlabelDir.splitlines()
            for devFile in unlabelDir:
                logging("Relabelling the file system.")
                runOnShell("restorecon -vF " + devFile)

def checkRule38661():
        #ASG: This is a manual intervention rule hence should go into manual tab, 
        #let the administrator confirm whether the operating system have a cryptographic mechanisms to protect data on the system. 
	#And if cryptographic mechanisms already is in use then user can mark this rule manually as successful
        logging("The operating system must protect the confidentiality and integrity of data at rest. The easiest way to encrypt a partition is during installation time. The cryptographic mechanisms need user input. So if cryptographic mechanisms are required for your environment then please implement it manually with required settings.")  
        return None

def fixRule38661():
	logging("Encryption protects the confidentiality and integrity of data at rest. The easiest way to encrypt a partition is during installation time. The cryptographic mechanisms also needed user input. So if cryptographic mechanisms is required for your environment then please implement it manually with required settings.")
        return None

def checkRule38662():
        #ASG: This is a manual intervention rule hence should go into manual tab, 
        #let the administrator confirm whether the operating system have a cryptographic mechanisms to protect data on the system. 
	#And if cryptographic mechanisms already is in use then user can mark this rule manually as successful
        logging("The operating system must employ cryptographic mechanisms to prevent unauthorized disclosure of data at rest unless\
 otherwise protected by alternative physical measures. The easiest way to encrypt a partition is during installation time. The cryptographic \
mechanisms need user input. So if cryptographic mechanisms are required for your environment then please implement it manually with \
required settings.")
        return None

def fixRule38662():
	logging("The operating system must employ cryptographic mechanisms to prevent unauthorized disclosure of data at rest. The easiest\
 way to encrypt a partition is during installation time. The cryptographic mechanisms need user input, so if cryptographic\
 mechanisms are required for your environment then please implement it manually with required settings.")
        return None

def checkRule38663():
	logging("Checking the audit service installation.")
	if not os.path.exists('/sbin/auditd'):
		logging ("audit package is not available.")
		return True

	if OsName.lower() == "ubuntu":
            logging("dpkg did not provide support for '--setperms' option, not applicable for Ubuntu.")
            return None
	else:
            res = runOnShell("sudo rpm -V audit | grep '^.M'")
	    if res == "":
		logging ("The system package management verifies permissions on all files and directories associated with the audit package.")
		return True
	    splitRes = res.splitlines()
            for fileName in splitRes:
		if "prelink" in fileName:
		    continue
		else:
	    	    logging ("The system package management does not verify permissions on all files and directories \
associated with the audit package.")
		    return False

	    logging ("The system package management verifies permissions on all files and directories associated with the audit package.")
            return True

def fixRule38663():
	if OsName.lower() == "ubuntu":
            logging("dpkg did not provide support for '--setperms' option, not applicable for Ubuntu.")
            return None
	else:
	    logging ("Updating audit files permission.")
	    #Setting permissions to the package for synching with database
	    runOnShell('sudo rpm --setperms audit')

def checkRule38664():
	logging("Checking the audit service installation.")
	if not os.path.exists('/sbin/auditd'):
		logging ("audit package is not available.")
		return True

	if OsName.lower() == "ubuntu":
            logging("dpkg did not provide support for '--setugids' option, not applicable for Ubuntu.")
            return None
	else:
            res = runOnShell("sudo rpm -V audit | grep '^.....U'")
	    if res == "":
		logging ("The system package management verifies ownership on all files and directories associated with the audit package.")
		return True
	    splitRes = res.splitlines()
            for fileName in splitRes:
		if "prelink" in fileName:
		    continue
		else:
		    logging ("The system package management does not verify ownership on all files and directories \
associated with the audit package.")
		    return False

	    logging ("The system package management verifies ownership on all files and directories associated with the audit package.")
            return True

def fixRule38664():
	if OsName.lower() == "ubuntu":
            logging("dpkg did not provide support for '--setperms' option, not applicable for Ubuntu.")
            return None
	else:
	    logging ("Updating audit files permission.")
	    #Setting permissions to the package for synching with database
	    runOnShell('sudo rpm --setugids audit')

def checkRule38665():
	logging("Checking the audit service installation.")
	if not os.path.exists('/sbin/auditd'):
		logging ("audit package is not available.")
		return True

	if OsName.lower() == "ubuntu":
            logging("dpkg did not provide support for setugids option, not applicable for Ubuntu.")
            return None
	else:
            res = runOnShell("sudo rpm -V audit | grep '^......G'")
	    if res == "":
		logging ("The system package management verifies group-ownership on all files and directories associated with the audit package.")
		return True
	    splitRes = res.splitlines()
            for fileName in splitRes:
		if "prelink" in fileName:
		    continue
		else:
		    logging ("The system package management does not verify group-ownership on all files and directories associated with the audit package.")
		    return False

	    logging ("The system package management verifies group-ownership on all files and directories associated with the audit package.")
            return True

def fixRule38665():
	if OsName.lower() == "ubuntu":
            logging("dpkg did not provide support for '--setperms' option, not applicable for Ubuntu.")
            return None
	else:
	    logging ("Updating audit files permission.")
	    #Setting permissions to the package for synching with database
	    runOnShell('sudo rpm --setugids audit.')

def checkRule38666():
    ''' The rule intends to use and update a DoD-approved virus scan program.'''

    #Checking if `McAfee VSEL` virus scanning tool is installed on the system.
    if not CheckPackage("McAfeeVSEForLinux"):
        logging("McAfee VSEL system service is not installed to perform scans dynamically.Please install this package manually.")
        return None

    logging("Verifying if McAfee VSEL system service is operational on the system.")
    mcafeStatus = runOnShell("service nails status")
    if "daemon is running" not in mcafeStatus:
        logging("McAfee VSEL system service is not operated on the system.Please run it manually.")
        return None
    		
    logging("Checking for McAfee installation directory.")
    McAfeeInstallDir = runOnShell("ps -p$(pidof nailsd) -f |sed -e '1d' -e s/^[^\/]*// |awk -Flibexec/nailsd '{print $1}'")	
    if McAfeeInstallDir == "":
        logging("McAfee installation directory does not exist, Hence need to manually configure the McAfee tool properly.")
	return None 	

    logging("Checking on the age of following uvscan virus definition files on the system.")
    runOnShell("ls  $(ps -p$(pidof nailsd) -f |sed -e '1d' -e s/^[^\/]*// |awk -Flibexec/nailsd '{print $1}')engine/dat") 

    outdatedFile = runOnShell("find  $(ps -p$(pidof nailsd) -f |sed -e '1d' -e s/^[^\/]*// | awk -Flibexec/nailsd '{print $1}')engine/dat -mtime +7 -type f")
    if outdatedFile != "":
	logging("McAfee Antivirus is not updated.Hence update it manually.")
	return None

    logging("Virus scanning software is running continuously, hence configured correctly.")
    return True


def fixRule38666():
	logging("Configuration of the virus scanning software to perform scans dynamically requires user inputs.Hence need to fix it manually.")
        return None


def checkRule38667():
    """
    Description: To find the intrusion on the system.
    Implementation: Checking whether SELINUX/AIDE are available with active or not
    Return Value:
        True: If any one of SELINUX/AIDE is available with active
        None: If neither SELINUX nor AIDE are available with active
    """

    logging("Checking SELINUX tool status to detect the intrusion on the system.")
    selinuxStatus = runOnShell("getenforce")

    # Checking aparmor in case of ubuntu, if selinux is not avaialble
    if OsName.lower() == "ubuntu":
        # Checking selinux status
        if "Permissive" in selinuxStatus:
            logging("SELINUX is available to detect the intrusion on the system.")
            return True

        logging("Checking apparmor tool status to detect the intrusion on the system.")
        apparmorStat = runOnShell("apparmor_status", False)
        if ("not mounted" in apparmorStat) or ("disabled" in apparmorStat) or ("not found" in apparmorStat):
            logging("apparmor is not available on the system.")
        else:
            logging("apparmor is available to detect the intrusion on the system.")
            return True

        aideConfFilePath = "/etc/aide/aide.conf"
    else:
        # Checking selinux status
        if "Enforcing" in selinuxStatus:
            logging("SELINUX is available to detect the intrusion on the system.")
            return True

        aideConfFilePath = "/etc/aide.conf"

    # Checking aide, and it's database as host-based intrustion detection on the machine
    if (not CheckPackage("aide")) or (not os.path.exists(aideConfFilePath)):
        logging("Please re-mediate the rules V-38489, and V-51391 to get host-based intrustion tool on the system.")
        return 3

    aideDatabaseFilePath = ""
    if OsName.lower() == "ubuntu":
        # To get the AIDE database file from AIDE configuration file
        aideDatabaseFilePath = runOnShell ("grep -w database " + aideConfFilePath + " | grep -v '^#' | cut -d':' -f2")
        if (len(aideDatabaseFilePath.split()) > 1) or (aideDatabaseFilePath == "") or aideDatabaseFilePath.startswith((' ', '\t')):
            logging("Please re-mediate the rule V-51391 to get host-based intrustion tool on the system.")
            return 3

        aideDatabaseFilePath = aideDatabaseFilePath.strip()
    else:
        aideDatabaseFilePath = runOnShell ("grep -w DBDIR " + aideConfFilePath + " | grep -v '^#'")
        if aideDatabaseFilePath == "":
            logging("Please re-mediate the rule V-51391 to get host-based intrustion tool on the system.")
            return 3

        aideDatabaseConfigInfo = aideDatabaseFilePath.translate (string.maketrans("\t\r", "  ")).strip()
        aideDatabaseConfigInfo = aideDatabaseFilePath.splitlines()
        aideDatabaseFilePath = aideDatabaseConfigInfo[0]
        aideDatabaseFilePath = re.sub('\s+', ' ', aideDatabaseFilePath)
        try:
            aideDatabaseFilePath = aideDatabaseFilePath.split()[2]
        except IndexError:
            logging("Please re-mediate the rule V-51391 to get host-based intrustion tool on the system.")
            return 3

        #Checking aide database file path existence in aide configuration file
        if (aideDatabaseFilePath == "/") or (not os.path.exists(aideDatabaseFilePath)):
            logging("Please re-mediate the rule V-51391 to get host-based intrustion tool on the system.")
            return 3

        aideDatabaseFileName = "".join(filter (lambda ele: "database=file:@@" in ele, aideDatabaseConfigInfo))
        try:
            aideDatabaseFileName = aideDatabaseFileName.split('/')[1]
        except IndexError:
            logging("Please re-mediate the rule V-51391 to get host-based intrustion tool on the system.")
            return 3
        aideDatabaseFilePath = aideDatabaseFilePath + "/" + aideDatabaseFileName

    # Checking aide database avaialble
    if os.path.exists(aideDatabaseFilePath):
        logging("AIDE tool is available to detect the intrusion on the system.")
        return True

    logging("Please re-mediate the rule V-51391 to get host-based intrustion tool on the system.")
    return 3

def fixRule38667():
    logging("At present, We are not providing fix for this rule as the rules V-38489, and V-51391 are taking care of fixing of this rule.")
    return None

def checkRule38668():
	if (OsName.lower() == "centos" or OsName.lower() == "redhat") and OsVersion >= (7,0):
            if os.path.exists ("/etc/systemd/system/ctrl-alt-del.target"):
		logging ("/etc/systemd/system/ctrl-alt-del.target file exists to avoid system reboot when user accidentally \
presses the combination of CTRL+ALT+DEL keys.")
                return True
	    else:
		logging ("/etc/systemd/system/ctrl-alt-del.target file does not exist where system will be rebooted when user \
accidentally presses the combination of CTRL+ALT+DEL keys.")
        else:
	    if not os.path.exists('/etc/init/control-alt-delete.override'):
		logging("The file path /etc/init/control-alt-delete.override does not exist. This file is required to add a line \
to avoid system reboot when user presses accidentally press CTRL+ALT+DEL keys.")
	    else:
                res = runOnShell('grep -iw ctrl-alt-delete /etc/init/control-alt-delete.override | grep -v "#"')
                for line in res.splitlines():
		    if isL(line) and re.match ('\s*exec\s*/usr/bin/logger\s*-p\s*security.info\s*"Ctrl-Alt-Delete pressed\s*"', line):
			logging ("/usr/bin/logger is available in /etc/init/control-alt-delete.override file to avoid system reboot \
when user accidentally presses the combination of CTRL+ALT+DEL keys.")
                        return True
	        logging ("/etc/init/ctrl-alt-del.override file is not properly configured where system will be rebooted \
when user accidentally presses the combination of CTRL+ALT+DEL keys.")
        return False

def fixRule38668():
	if (OsName.lower() == "centos" or OsName.lower() == "redhat") and OsVersion >= (7,0):
	    logging ("Checking ctrl-alt-del.target file existence.")
	    if not os.path.exists ("/etc/systemd/system/ctrl-alt-del.target"):
		logging ("Creating crl-alt-del.target file to prevent reboot the system when user accidentally \
presses CTRL+ALT+DEL key combinations.")
		runOnShell("ln -s /dev/null /etc/systemd/system/ctrl-alt-del.target")
        else:
	    #The below file is for adding ctrl-alt-delete line for avoiding OS reboot 
	    #when mistakenly press Ctrl+Alt+Del key combination
	    fileName = "/etc/init/control-alt-delete.override"

	    logging ("Creating the new file {0}, if does not exist.".format(fileName))
	    #If control-alt-delete.override file is not available, create it for adding ctrl-alt-delete line
	    if not os.path.exists(fileName):
		runOnShell('touch ' + fileName)

	    rebootFileContent = ""
	    lastLine = ""
	    rebootFlag = False

	    logging ("Checking /usr/bin/logger entry in the file {0} and adding the line, if not available to prevent system reboot \
when user accidentally presses the combination of CTRL+ALT+DEL keys.".format(fileName))
	    fileLines = open(fileName).readlines()
            for line in fileLines:
	        if isL(line) and re.match ('\s*exec\s*/usr/bin/logger\s*-p\s*security.info\s*"Ctrl-Alt-Delete pressed\s*"\n', line) and (not rebootFlag):
		    rebootFlag = True
		    break
		else:
		    lastLine = line
		    continue

	    #It means no where the above line is not available
	    if rebootFlag == False:
		if not "# Cloud Raxak updated next line" in lastLine:
                    rebootFileContent += "# Cloud Raxak updated next line\n"

		#Adding the below line into control-alt-delete.override file to avoid reboot 
		#when we mistakenly press Ctrl+Alt+Del key combination
                rebootFileContent += 'exec /usr/bin/logger -p security.info "Ctrl-Alt-Delete pressed"\n'

	    rebootFileReference = None
	    try:
		rebootFileReference = open(fileName, 'a+')
		rebootFileReference.write(rebootFileContent)
	    finally:
		if rebootFileReference is not None:
		    rebootFileReference.close()
		
def checkRule38669():
	#It works only for centos-7 ,not for 6
	#Only need to be fixed in tokenMatchIC
	#as match issue is coming out.
	if os.path.exists('/usr/sbin/postfix') == False:
                logging("postfix service is not installed. Please install it manually.")
		return None
	logging("Checking the current status of postfix service.")
	if ((OsVersion >= (7,0) ) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		service_status = runOnShell('systemctl is-active postfix.service').replace('\n','')
		service_at_runlevel = runOnShell("systemctl is-enabled postfix.service")
		if service_status == "active" and 'enabled' in service_at_runlevel:
			return True
		return False
	else :
		run_level_flag = False
		if OsName.lower() == "ubuntu":
			logging("service and init.d are used for start/stop/restart/reload the service,\
 hence checking the status of service using both commands.")	
			res = runOnShell('service postfix status')
			return_value = tokenMatchIC("*postfixisrunning\n", res.replace(" ",''))
			status_from_init_cmd = runOnShell('/etc/init.d/postfix status')
			return_value_init = tokenMatchIC("*postfixisrunning\n", status_from_init_cmd.replace(" ",''))
			run_level_serv = runOnShell('sysv-rc-conf --list postfix').translate(string.maketrans("\n\t\r", "   "))
			run_level_serv = run_level_serv.replace(" ","")
			if return_value and return_value_init:
				run_level_flag = True
		else:
			service_status = runOnShell('service postfix status')
			if "master dead but pid file exists" in service_status:
				logging("postfix is installed but not running properly, please check it manually.")
				return None
			service_match = tokenMatchIC("isrunning...\n", service_status.replace(" ",''))
			run_level_serv = runOnShell('chkconfig --list postfix').translate(string.maketrans("\n\t\r", "   "))
			run_level_serv = run_level_serv.replace(" ",'')
			if service_match:
				run_level_flag = True

		if run_level_flag:
			if current_runlevel in run_level_serv:
				if previous_runlevel != None:
					if previous_runlevel in run_level_serv:
						return True
					else:
						logging("Previous runlevel is off, need to be started, hence rule is failed.")
						return False
				else:
					return True
			else:
				logging("Default runlevel is off, need to be started, hence rule is failed.")
				return False
			
		logging("postfix service is not running.")
		return False

			
def fixRule38669():
	if ((OsVersion >= (7,0) ) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		runOnShell("systemctl enable postfix.service; systemctl start postfix.service")
	else:
		logging("Starting the postfix service in system boot configuration.")
		if OsName.lower() == "ubuntu":
			runOnShell('sysv-rc-conf --level 0123456S postfix on')
		else:
			runOnShell('service postfix start;chkconfig --level 0123456 postfix on')

		if not OsName.lower() == 'redhat':
			runOnShell('/etc/init.d/postfix start')
			runOnShell('service postfix start')


def checkRule303to307():
        return runOnShell("grep aide /etc/crontab | grep -v '#'")
    
def fixRule303to307():
        appendToFile("/etc/crontab","05 4 * * * root /usr/sbin/aide --check",True)

def checkRule38670():
    #To check whether aide service is installed or not
    if OsName.lower() == "ubuntu":
        aideConfFilePath = "/etc/aide/aide.conf"
        cronPackage = "cron"
    else:
        aideConfFilePath = "/etc/aide.conf"
        cronPackage = "cronie"

    if not CheckPackage(cronPackage):
        logging("Cron is used to detect unauthorized changes to software and information.")
        return False

    logging("Checking aide package entry in /etc/crontab and /etc/cron.*/* files.")
    res = runOnShell('grep "aide -c ' + aideConfFilePath  + '" /etc/crontab /etc/cron.*/* | grep -w nice | grep -v ":#"')
    if res:
        logging("The operating system detects unauthorized changes to software and information.")
        return True
    else:
        logging("The operating system does not detect unauthorized changes to software and information.")
        return False

def fixRule38670():
    aideBinFilePath = "/usr/sbin/aide"
    logging("Checking if cron is installed on the system.")
    if not os.path.exists("/etc/crontab"):
        if not InstallPackage("cronie"):
    	    return None

    aideConfFilePath = "/etc/aide.conf"
    if (OsName.lower() == "redhat" or OsName.lower() == "centos") and OsVersion < (7,0):
        niceBinFilePath = "/bin/nice"
    else:
        if OsName.lower() == "ubuntu":
            aideBinFilePath = "/usr/bin/aide"
            aideConfFilePath = "/etc/aide/aide.conf"
        niceBinFilePath = "/usr/bin/nice"

    cronFlag = False # To add aide entry in cron file
    cronEntry = "" # Contains the content of /etc/fstab file
    cronLogMessage = "05 4 * * * root " + niceBinFilePath + " -n +10 " + aideBinFilePath + " -c " + aideConfFilePath + " --check\n"

    logging("Adding aide package as part of cron jobs.")
    crontabFileLines = open("/etc/crontab").readlines()
    for cronLine in crontabFileLines:
        if (aideConfFilePath in cronLine) or (aideBinFilePath in cronLine):
            if not cronFlag:
                if "Cloud Raxak" not in lastLine:
                    cronEntry += "# Cloud Raxak updated next line\n"
                cronEntry += cronLogMessage
                cronFlag = True
        else:
            cronEntry += cronLine
            lastLine = cronEntry

    if not cronFlag:
        if "Cloud Raxak" not in lastLine:
            cronEntry += "# Cloud Raxak updated next line\n"
        cronEntry += cronLogMessage

    fout = open("/etc/crontab", "wt")
    if fout != None:
        fout.write(cronEntry)
        fout.close()

def checkRule38671():
        logging("Checking if 'sendmail' package is installed on system.")
        if OsName.lower() == "ubuntu":
                res = runOnShell('dpkg -s sendmail')
        else:
                res = runOnShell('rpm -q sendmail')
        if ("not installed" in res) or ("deinstall ok" in res):
            logging("'sendmail' package is not installed on system.")
            return True
        elif "error" in res:
            logging("'sendmail' package is not installed on system.")
            return True
        else:
            logging("'sendmail' package is installed on system. Please remove the 'sendmail' package.")
            return False

def fixRule38671():
	logging("Removing 'sendmail' package.")
	if OsName.lower() == "ubuntu":
                runOnShell('dpkg -r --force-all sendmail')
        else:
                runOnShell('rpm -e sendmail --nodeps')

def checkRule38672():
	if OsName.lower() == "ubuntu":
	    logging("Checking the status of netconsole mode.")
            status_of_netconsole_mode = runOnShell('lsmod |grep netconsole')
	    if status_of_netconsole_mode != "":
		logging("netconsole module is enabled.")
		if runOnShell("dmesg | grep netcon") != "":
			logging("This rule is not applicable since netconsole module is already in use.")
			return None
		return False	

	    logging("netconsole module is disabled.")
	    return True		
	else:
	    logging("Checking the configuration of netconsole kernel module.")	
            netconsole_conf = runOnShell('rpm -qf /etc/sysconfig/netconsole')
	    if "No such file or directory" in netconsole_conf:
		logging("Netconsole kernel module is not configured on this system.")
		return True
					
            service_status = runOnShell('service netconsole status').translate(string.maketrans("\n\t\r", "   "))
	    if "netconsole module loaded" in service_status:
		logging("Netconsole service is in use, please stop this service manually \
if it is not required as it is responsible for loading the netconsole kernel module, \
which logs kernel printk messages over UDP to a syslog server which is not secure.")
		return None 	

            ser_runlevel_status = runOnShell('chkconfig netconsole --list 2>/dev/null')
            if serviceInstalled(ser_runlevel_status):
                ser_runlevel_status = ser_runlevel_status.translate(string.maketrans("\n\t\r", "   "))
	        if not(tokenMatchIC("netconsole 0:off 1:off 2:off 3:off 4:off 5:off 6:off", ser_runlevel_status)):
                    return False

	return True

def fixRule38672():
	if OsName.lower() == "ubuntu":
	    logging("Disabling the netconsole module.")	
	    runOnShell('rmmod netconsole')
	else:
	    logging("Disabling the netconsole service at all runlevel.")
       	    runOnShell('chkconfig --level 0123456 netconsole off')
	    if OsVersion >= (7,0):
       	        runOnShell('systemctl stop netconsole.service')
	    else:
	        logging("Disabling the netconsole service in current session.")
       	        runOnShell('service netconsole stop')

def checkRule38673():
    #To check whether aide service is installed or not
    if OsName.lower() == "ubuntu":
        aideConfFilePath = "/etc/aide/aide.conf"
        cronPackage = "cron"
    else:
        aideConfFilePath = "/etc/aide.conf"
        cronPackage = "cronie"

    if not CheckPackage(cronPackage):
        logging("Cron is used to ensure unauthorized, security-relevant configuration changes detected are tracked on the system.")
        return False

    logging("Checking aide package entry in /etc/crontab and /etc/cron.*/* files.")
    res = runOnShell('grep "aide -c ' + aideConfFilePath  + '" /etc/crontab /etc/cron.*/* | grep -w nice | grep -v ":#"')
    if res:
	logging("The operating system ensures unauthorized, security-relevant configuration changes detected are tracked.")
        return True
    else:
        logging("The operating system does not ensure unauthorized, security-relevant configuration changes detected are tracked.")
        return False

def fixRule38673():
    aideBinFilePath = "/usr/sbin/aide"
    logging("Checking if cron is installed on the system.")
    if not os.path.exists("/etc/crontab"):
        if not InstallPackage("cronie"):
            return None

    aideConfFilePath = "/etc/aide.conf"
    if (OsName.lower() == "redhat" or OsName.lower() == "centos") and OsVersion < (7,0):
        niceBinFilePath = "/bin/nice"
    else:
        if OsName.lower() == "ubuntu":
            aideBinFilePath = "/usr/bin/aide"
            aideConfFilePath = "/etc/aide/aide.conf"
        niceBinFilePath = "/usr/bin/nice"

    cronFlag = False # To add aide entry in cron file
    cronEntry = "" # Contains the content of /etc/fstab file
    cronLogMessage = "05 4 * * * root " + niceBinFilePath + " -n +10 " + aideBinFilePath + " -c " + aideConfFilePath + " --check\n"

    logging("Adding aide package as part of cron jobs.")
    crontabFileLines = open("/etc/crontab").readlines()
    for cronLine in crontabFileLines:
        if (aideConfFilePath in cronLine) or (aideBinFilePath in cronLine):
            if not cronFlag:
                if "Cloud Raxak" not in lastLine:
                    cronEntry += "# Cloud Raxak updated next line\n"
                cronEntry += cronLogMessage
                cronFlag = True
        else:
            cronEntry += cronLine
            lastLine = cronEntry

    if not cronFlag:
        if "Cloud Raxak" not in lastLine:
            cronEntry += "# Cloud Raxak updated next line\n"
        cronEntry += cronLogMessage

    fout = open("/etc/crontab", "wt")
    if fout != None:
        fout.write(cronEntry)
        fout.close()

def checkRule38674():
	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat' )):
		logging("Checking system default target")
        	res = runOnShell('systemctl get-default').strip()
		if res == 'multi-user.target':
			logging("X window is disabled.")
			return True
		elif res == 'graphical.target':
			logging("X window is enabled.Please fix it manually.")
			return None
		else:
			logging("Default target is not set properly. Please fix it manually.")
			return None
	elif OsName.lower() == "ubuntu":
		logging("Checking if grub file has any syntax error or wrong specification.")
		if not os.path.exists ("/boot/grub/grub.cfg"):
			logging ("The grub file does not exist, hence fix it manually.")
			return None
		logging("Checking the grub file permissions.")
	        if int (runOnShell ('stat -c "%a" /boot/grub/grub.cfg')) == 600:
			grub_out = runOnShell ("update-grub")
			logging("The system boot loader configuration file(s) must have mode 0600 or less permissive, reverting the permission to 0660 as the permission of boot loader configuration file has been changed to 0444 after executing the 'update-grub' command.")
			runOnShell('chmod 600 /boot/grub/grub.cfg')
		else:
			grub_out = runOnShell ("update-grub")

		if 'Syntax error' in grub_out:
			logging("grub file has syntax error, need to fix it manually.")
			return None
		elif "not found" in grub_out:
			logging("Wrong specification in grub file, need to fix it manually.")
			return None
			
		grub_command_line_linux = False
		grub_terminal = False
		for command in ["GRUB_CMDLINE_LINUX","GRUB_TERMINAL"]:
        		res = runOnShell('grep '+command+' /etc/default/grub | grep -v "^#" | grep -v "GRUB_CMDLINE_LINUX_" ')
			res = res.translate(string.maketrans("\n\t\r", "   "))
			if command == "GRUB_CMDLINE_LINUX":
				match_object = re.match(r'.*\s*(\btext\b)\s*', res)
				if match_object != None and match_object.group(1) == 'text':
					grub_command_line_linux = True	
			elif command == "GRUB_TERMINAL":
				match_object = re.match(r'.*\s*(\bconsole\b)\s*', res)
				if match_object != None and match_object.group(1) == 'console':
					grub_terminal = True	
		if grub_command_line_linux and grub_terminal:
			logging("X window is disabled.")
			return True
		logging("X window is enabled.")
	else:
		#This case will also be executed for amazon version.
		logging("Checking if the default runlevel is 3.") 
		res = runOnShell('grep initdefault /etc/inittab | grep -v "^#"')
		res = res.split("\n")
		for element in res[:-1]:
		    if not tokenMatchIC("id:3:initdefault:", element):
			logging("The default runlevel is not 3, need to fix it manually.")
			return None
		    else:
			logging("The default runlevel is 3, this will prevent automatic startup of the X server.")
			return True
	return False

def fixRule38674():
	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		logging("Disabling the x-windows from the system.")
		runOnShell('systemctl set-default multi-user.target')
		logging("Reboot is requird to disable x-windows from the system.")
	else:
		if OsName.lower() == "ubuntu":
		    value = 'GRUB_CMDLINE_LINUX="text"\n'	
		    grub_terminal_val = 'GRUB_TERMINAL=console\n'	
		    file_path = "/etc/default/grub"
		else:
		    file_path = "/etc/inittab"
		    value = "\nid:3:initdefault:\n"

		#Iterating the data of file to update it.
        	s = ""
		count = 0	
		flag = False
		grub_terminal_flag = False
		previous_line = ""
		prev_previous_line = ""
		list_of_lines = open(file_path, "r").readlines()
        	for line in list_of_lines:
        	    if "id:" in line and "initdefault:" in line and OsName.lower()=="centos":
		        flag = True
        	        s += "# Cloud Raxak updated next line\n"
        	        s += "id:3:initdefault:\n"
		    elif (re.search("GRUB_CMDLINE_LINUX", line) and not("GRUB_CMDLINE_LINUX_" in line) and OsName.lower() == "ubuntu"):
		        line = line.translate(string.maketrans("\n\t\r", "   "))
			if isL(line):
		            flag = True
		            index = line.find("=")+1
			    value = re.sub(r'"', '', line[index:])
			    value = value.rstrip()	
		            parameter = "GRUB_CMDLINE_LINUX="+'"'+value
		            if "Cloud Raxak" not in previous_line:
        	            	s += "# Cloud Raxak updated next line\n"
		            if re.match(r'.*\s*(\btext\b)\s*', line) == None:
        	           	    s += parameter+' text"'+'\n'
		            else:
        	           	    s += parameter+'"'+'\n'
			else:
				s += line+'\n' 

		    elif "GRUB_TERMINAL" in line and OsName.lower() == "ubuntu":
		        grub_terminal_flag = True
		        if "Cloud Raxak" not in previous_line:
        	            s += "# Cloud Raxak updated next line\n"
        	        s += 'GRUB_TERMINAL=console\n'
		    elif isL(line) and "id:" in line and "initdefault:" in line and OsName.lower()=="redhat":
			flag = True
			s += "# Cloud Raxak updated next line\n"
			s += "id:3:initdefault:\n"
			logging("Please reboot the system to reflect these changes.")
        	    else:
        	        s += line
		    previous_line = line

		msg = ""
		if "Cloud Raxak" not in previous_line:
			msg = "\n# Cloud Raxak updated next line\n"
        	fout = None
        	try:
        	    fout = open(file_path, "wt")
        	    fout.write(s)
		    if flag == False:
        	    	fout.write(msg+value)
		    if grub_terminal_flag == False and OsName.lower() == "ubuntu":
        	    	fout.write(msg+grub_terminal_val)
        	finally:
        	    if fout is not None:
        	        fout.close()
	
def checkRule38675():
    if not os.path.exists('/etc/security/limits.conf') and not os.path.exists('/etc/security/limits.d/*.conf'):
        logging("The configuration file for disabling process core dumps for all users does not exist.")
        return None

    logging("Checking whether process core dumps are disabled for all users.")
    coreLoginStr = runOnShell("grep -w core /etc/security/limits.conf /etc/security/limits.d/*.conf --no-messages | grep -v '#'")
    if not coreLoginStr:
        logging("Configuration for disabling process core dumps for all users was not found.")
        return False

    res1 = coreLoginStr.splitlines()
    count_wrong_entry = 0
    filepathlist = []
    # We are checking for configuration "* hard core 0", if anything besides this is configured on a system the rule will be marked as FAIL.
    for element in res1:
        iSplit = element.split(':')
        filepathlist.append(iSplit[0])
        try:
            trim_i = re.sub(r'\s+', '', iSplit[1])
        except IndexError:
            logging("Process core dumps are not disabled for all users.")
            return False
        if trim_i != "*hardcore0" or filepathlist.count(iSplit[0]) > 1:
            count_wrong_entry = count_wrong_entry + 1
    if count_wrong_entry > 0:
        logging("Process core dumps are not disabled for all users.")
        return False
    else:
        logging("Process core dumps are disabled for all users.")
        return True

def fixRule38675():
    if not os.path.exists('/etc/security/limits.conf') and not os.path.exists('/etc/security/limits.d/*.conf'):
        logging("The configuration file for disabling process core dumps for all users does not exist.")
        return None

    coreLoginStr = runOnShell('grep -w core /etc/security/limits.conf /etc/security/limits.d/*.conf --no-messages | grep -v "#"')
    if not coreLoginStr:
        fout = None
        try:
            fout = open('/etc/security/limits.conf', 'at')
            add_line = "# Cloud Raxak updated next line\n* hard core 0\n"
            fout.write(add_line)
        finally:
            if fout is not None:
                fout.close()
    else:
        core_config = coreLoginStr.splitlines()
        filepathlist_check = []
        filepathlist = []
        for line_no in core_config:
            core_config_element = line_no.split(':')
            filepathlist_check.append(core_config_element[0])
            trim_i = re.sub(r'\s+', '', core_config_element[1])
            if trim_i != "*hardcore0" or filepathlist_check.count(core_config_element[0]) > 1:
                filepathlist.append(core_config_element[0])
        # Removing duplicate entries of the same file path
        filepathlist = list(set(filepathlist))
        for file_write in filepathlist:
            flag_core = False
            with open(file_write, "r") as file_data:
                change_line = ""
                lastLine = ""
                for line in file_data:
                     if isL(line) and "core" in line:
                         if not flag_core:
                             if not tokenMatch('Cloud Raxak updated next line',lastLine):
                                 change_line += "# Cloud Raxak updated next line\n"
		             logging("Disabling core dumps for all users. To take changes made, in effect please restart the current login session.") 
                             change_line += "* hard core 0\n"
                             flag_core = True
                     else:
                         change_line += line
                         lastLine = line
            if not(flag_core):
                if not tokenMatch('Cloud Raxak updated next line',lastLine):
                    change_line += "# Cloud Raxak updated next line\n"
	        logging("Disabling core dumps for all users. To take changes made, in effect please restart the current login session.") 
                change_line += "* hard core 0\n"
            fout = None
            try:
                fout = open(file_write, 'wt')
                fout.write(change_line)
            finally:
                if fout is not None:
                    fout.close()

def checkRule38676():
	if OsName.lower() == "ubuntu":
		logging("Checking if the xserver-common package is installed on the system.")
		res = runOnShell('dpkg -s xserver-common')
		if "dpkg was interrupted" in res:
			logging ("dpkg is not properly configured, need to configure dpkg manually.")
			return None
		elif ("not installed" in res) or ("deinstall ok" in res):
			logging("Package xserver-common is not installed.")
			return True
		logging("xserver-common package is installed on your system, removing all packages which constitute the X Window System ensures users or malicious software cannot start X. Hence, please remove X Window system manually if not required and reboot the system for changes to get effected.")
		return None
	else:
		logging("Checking if the xorg-x11-server-common package is installed on the system.")
		res = runOnShell('rpm -qi xorg-x11-server-common')
		if "is not installed" in res:
		    logging("Package xorg-x11-server-common is not installed.")
		    return True
		logging("xorg-x11-server-common package is installed in your system, removing all packages which constitute the X Window System ensures users or malicious software cannot start X. Hence, please remove X Window system manually if not required and reboot the system for changes to get effected.")
		return None

def fixRule38676():
	if OsName.lower() == "ubuntu":
		logging("Removing all the package related to X Window System.")
		if "dpkg was interrupted" in runOnShell('apt-get -y purge xserver-common', False):
			logging("dpkg is not properly configured, it needs to be configured properly using \
command 'dpkg --configure -a'. Please fix this manually.")
			return None
		logging("xserver-common package is removed from your system. Please reboot the system manually for changes to get effected.")
		return None
	else:
        	#runOnShell('yum groupremove "X Window System"')
		logging("Removing all the packages related to X Window System.")
		runOnShell('rpm -e xorg-x11-server-common --nodeps')
		logging("xorg-x11-server-common package is removed from your system. Please reboot the system manually for changes to get effected.")
		return None


def checkRule38677():
	if OsName.lower() == "ubuntu":
	    service_name = "nfs-kernel-server"
	    pkgInstallCheck = "dpkg -s "
	else:
	    pkgInstallCheck = "rpm -q "
            service_name = "nfs-utils"

	logging ("Checking if NFS is installed in the system.")
	NFSInstallCheck = runOnShell (pkgInstallCheck + service_name)
	if ("not installed" in NFSInstallCheck) or ("deinstall" in NFSInstallCheck):
	    logging ("As NFS package is not installed in this system, this rule is not applicable.")
	    return True

	logging ("Checking NFS server's mount configuration file existence.")
	if not os.path.exists('/etc/exports'):
	    logging ("NFS package is installed but, NFS server mount configuration file is not available. Please fix it manually.")
	    return None

	logging ("Checking syntax errors on NFS server configuration file.")
	if runOnShell ("exportfs -a"):
	    logging ("As NFS server configuration file has syntax errors, please fix it manually.")
	    return None

	logging ("Checking the content of NFS server's configuration file.")
	if not int(runOnShell ("cat /etc/exports | grep -v '^$\|^#\|^\s*\#' | wc -l")):
	    logging ("The NFS configuration file is not configured with any NFS client entries.")
	    return True

	logging ("Checking insecure_locks option in /etc/exports file at NFS Server.")
	NFSServerConfigRes = runOnShell("grep -w insecure_locks /etc/exports | grep -v '^#'")
	if NFSServerConfigRes == "":
	    logging ("The NFS server disabled the insecure_locks option in /etc/exports file.")
	    return True
	else:
	    logging ("The NFS server enabled the insecure_locks option in /etc/exports file.")
	    return False


def fixRule38677():
	logging ("Checking NFS server's mount configuration file existence.")
	if not os.path.exists('/etc/exports'):
	    logging ("NFS package is installed but, NFS server mount configuration is not available.")
	    return None

	logging ("Checking syntax errors on NFS server configuration file.")
	if runOnShell ("exportfs -a"):
	    logging ("As NFS server configuration file has syntax errors.")
	    return None

	logging ("Checking and removing insecure_locks option of the instance from /etc/exports file.")
	with open("/etc/exports", "r") as NFSConfigFileContent:
		NFSConfigFileInfo = ""
		for NFSEntry in NFSConfigFileContent:
			if isL(NFSEntry) and "insecure_locks" in NFSEntry:
			    splitNFSEntry = NFSEntry.split('(')
			    optionObj= re.match(r".*\((.*)\)", NFSEntry)
			    if optionObj != None:
		    		optionList = optionObj.group(1).split(',')
				#It contains individual NFS entry's options
				optionList = list (set (optionList))
				optionList.remove ("insecure_locks")
				NFSEntry = splitNFSEntry[0] + "(" + ",".join(optionList) + ")\n" 
			else:
			    lastLine = NFSEntry

			#Updating NFS Configuration file Content
			NFSConfigFileInfo += NFSEntry

	NFSConfigFileRef = open("/etc/exports", 'wt')
	if NFSConfigFileRef is not None:
	    NFSConfigFileRef.write(NFSConfigFileInfo)
	    NFSConfigFileRef.close()

	if OsName.lower() == "ubuntu":
		logging ("Restarting nfs-kernel-server after removing insecure_locks option instance from /etc/exports file.")
		runOnShell("service nfs-kernel-server restart")
	elif OsName.lower() == "centos" and OsVersion >= (7,0):
		logging ("Restarting nfs-server after removing insecure_locks option instance from /etc/exports file.")
	        runOnShell("systemctl restart nfs-server")
	else:
		logging ("Restarting nfs after removing insecure_locks option instance from /etc/exports file.")
		runOnShell("service nfs restart")


def checkRule38678(val = 75):
	if not CheckService("auditd"):
		return False

	if not os.path.exists('/etc/audit/auditd.conf'):
		logging ("The audit configuration file does not exist, please fix this manually.")
		return None

	logging("Checking the maximum size of audit log files.")
	res_max_log_file = runOnShell('grep -wi max_log_file /etc/audit/auditd.conf | grep -v "^#"')
        converted_max_log_int = 0
	value_max_log_file = ""
	try:
		value_max_log_file = getValueOfKey("max_log_file", res_max_log_file.rstrip('\n'))
		converted_max_log_int = int(value_max_log_file)
		updated_res_max_log_file = re.sub(' +', ' ', res_max_log_file)
		if "max_log_file = " + value_max_log_file not in updated_res_max_log_file.lower():
			logging("The system value set for maximum size of audit log files is not correct, so need to fix it manually, or to configure \
the maximum system audit log file size remediate the Rule V-38633.")
			return None
	except (ValueError, TypeError) as e:
		logging("The system value set for maximum size of audit log files is not correct, so need to fix it manually, or to configure \
the maximum system audit log file size remediate the Rule V-38633.")
		return None

	logging("Checking the total number of audit log files.")
	res_num_logs = runOnShell('grep -wi num_logs /etc/audit/auditd.conf | grep -v "^#"')
	converted_num_log_int = 0
	value_num_logs = ""
	try:
		value_num_logs = getValueOfKey("num_logs", res_num_logs.rstrip('\n'))
		converted_num_log_int = int(value_num_logs)
		updated_value_num_logs = re.sub(' +', ' ', res_num_logs)
		if "num_logs = " + value_num_logs not in updated_value_num_logs.lower():
			logging("The system value for value_num_logs is not correct, so need to fix it manually, or to configure \
the system log file(s) remediate the Rule V-38636.")
			return None
	except (ValueError, TypeError) as e:
		logging("The system value for value_num_logs is not correct, so need to fix it manually, or to configure the system \
log file(s) remediate the Rule V-38636.")
		return None

	# Calculating the left storage capacity(disk space).  
	calculated_value = (converted_max_log_int * converted_num_log_int)*10/100
	logging("Checking the remaining audit partition capacity.")
	res = runOnShell('grep -wi space_left /etc/audit/auditd.conf | grep -v "^#"')
	if not res:
	    logging("The system is not configured to check the disk space problem.")
	    return False

	converted_space_left_int = 0	
	file_value = ''
	try:
		file_value = getValueOfKey("space_left", res.rstrip('\n'))
		converted_space_left_int = int(file_value)
	except (ValueError, TypeError) as e:
		logging("The system value for the left over storage capacity is not configured correctly.")
		return False

	if file_value is not None:
		res = res.split(" ")
		for element in res:
		    if ("space_left=" in element.lower()) or ("=" + file_value in element.lower()):
			logging("The system is not configured to check the disk space problem.")
			return False

		list_of_int = [converted_space_left_int,val,calculated_value]
		max_value = max(list_of_int)
		if converted_space_left_int >= max_value:
			logging("The system is properly configured to handle disk space.")
			return True
	else:
		logging("The system is not configured to check the disk space problem.")
		return False
	logging("Need to change the setting that handles the disk space problem.")
	return False

def fixRule38678(val = 75):
	if not CheckPackage("audit"):
		InstallPackage("audit")

	if not os.path.exists('/etc/audit/auditd.conf'):
		logging("The audit configuration file does not exist, please fix this manually.")
		return None

	res_max_log_file = runOnShell('grep -wi max_log_file /etc/audit/auditd.conf | grep -v "^#"', False)
	converted_max_log_int = 0
	value_max_log_file = ""
	try:
		value_max_log_file = getValueOfKey("max_log_file", res_max_log_file.rstrip('\n'))
		converted_max_log_int = int(value_max_log_file)
	except (ValueError, TypeError) as e:
		logging("The system value for max_log_file is not configured correctly.")

	res_num_logs = runOnShell('grep -wi num_logs /etc/audit/auditd.conf | grep -v "^#"', False)
	converted_num_log_int = 0
	value_num_logs = ""
	try:
		value_num_logs = getValueOfKey("num_logs", res_num_logs.rstrip('\n'))
		converted_num_log_int = int(value_num_logs)
	except (ValueError, TypeError) as e:
		logging("The system value for value_num_logs is not configured correctly.")
	# Calculating the left storage capacity.
	calculated_value = (converted_max_log_int * converted_num_log_int)*10/100
	res = runOnShell('grep -wi space_left /etc/audit/auditd.conf | grep -v "^#"', False)
	converted_space_left_int = 0	
	file_value = ''
	try:
		file_value = getValueOfKey("space_left", res.rstrip('\n'))
		converted_space_left_int = int(file_value)
	except (ValueError, TypeError) as e:
		logging("The system value for the left over storage capacity is not configured correctly.")
	with open('/etc/audit/auditd.conf', "r") as file_content:
		flag = False
		file_string = ""
		lastLine= ""
		for line in file_content:
			if isL(line) and ("space_left" in line.lower()):
				value = line.split("_")
				if len(value) > 2:
					file_string += line
					lastLine = line
					continue
				line = line.translate(string.maketrans("\n\t\r", "   "))
				line = line.split("=")
				if tokenMatchIC("space_left", line[0]):
					logging("Updating the remaining audit partition capacity.")
					if not tokenMatch("# Cloud Raxak updated next line",lastLine):
						file_string += "# Cloud Raxak updated next line\n"
					list_of_int = [converted_space_left_int,val,calculated_value]
					max_value = max(list_of_int)
					file_string += "space_left = "+str(max_value)+"\n"
				        flag = True
			else:
				file_string += line
				lastLine=line
		if not(flag):
			file_string += "# Cloud Raxak updated next line\n"
			if calculated_value >= val:
			    logging("Updating the remaining audit partition capacity by allocating disk space.")
			    file_string += "space_left = " + str(calculated_value) + "\n"
			else:
			    logging("Updating the remaining audit partition capacity by allocating disk space.")
			    file_string += "space_left = " + str(val) + "\n"
	fout = None
	try:
		fout = open("/etc/audit/auditd.conf", 'wt')
		fout.write(file_string)
	finally:
		if fout is not None:
			fout.close()
	RunService("auditd")

def checkRule38679():
	'''This function intends to check the status(DHCP or STATIC) of machine with the following steps;-
	   1.Extracting the device from the system.
	   2.Checking each the type(virtual/physical) of device.
	   3.Checking ifcfg-<anyName> file under the netwrok-scrips/.
	   4.If ifcfg-<anyName> file does not exist then cheking if any ipaddress is assigned to that device
	     using command `ip addr sh eth0 | grep '\binet\b'`
	   5.If ip address is assigned then consider rule as failed ,could be dhcp else ignore(success).
	   6.If ifcfg-<name> file exist then checking required static mode parameters in file.

	'''
	#1.Extracting the systems's network devices 
        list_of_device = runOnShell("ip link|grep -v 'link/*' | cut -d: -f2 | tr -d '' | grep -v 'lo'").splitlines()
	list_of_device = map(str.strip, list_of_device)
	physicalDevDHCP = [] #list of device which has not icfg-* file but ip addrress is assigned.
	dhcpDevice = [] #list of device which has dhcp value or static mode required param not exist.

	if OsName.lower() == "ubuntu":
                if not os.path.exists("/etc/network/interfaces"):
                    logging("File '/etc/network/interfaces' does not exist.Please check it manually.")
                    return None
		logging("========= INFO : Dumping the data of file =============")
		runOnShell('cat /etc/network/interfaces')
		logging("========================================================")
	for device in list_of_device:
	    if OsName.lower() == "ubuntu":
		#2.Checking the existence of iface <device> inet dhcp.
	   	dhcp_out = runOnShell("grep '\s*iface\s*" + device + "\s*inet\s*static\s*'" + " /etc/network/interfaces | grep -v ^#")
		#If dhcp exists then rule need to be remediated.
	   	if dhcp_out == "":
	   		#return False #TODO Currently supporting manual remediation, hence adding return None , do not remove commented value 
			logging(device + " device is setup to dhcp, please fix it manually.")
	   		return None
            else:		
		staticParamConfiguration = True
		#2.Fetching the network file corresponding to network active device.
		logging("\n\nChecking configuration for device "+device)
		logging("-----------------------------------------------")
		file_path = runOnShell("egrep -l 'NAME="+ device +"|DEVICE="+ device + "' /etc/sysconfig/network-scripts/ifcfg-*")
		list_of_file = file_path.splitlines()
		
		#3.If ifcfg fle does not exist corresponding to device then checking ipaddress is assigned to physical device   	
		if len(list_of_file) == 0: 
			if runOnShell("ip addr sh "+device+" | grep '\\binet\\b'"):
				physicalDevDHCP.append(device) #ip address assigned but not ifcfg-* file. 	
			continue
		
		for file_path in list_of_file:
			deviceCount = 0	
			#4.Checking the required static mode parameters inifcfg-<name> file for active device.
			for parameter in ["BOOTPROTO","ONBOOT","IPADDR","GATEWAY"]:
				if deviceCount > 1:
		        		parameter = runOnShell('grep -w '+ parameter + ".* " + file_path + " | grep -v ^#")
				else:
		        		parameter = runOnShell('grep -w '+ parameter + " " + file_path + " | grep -v ^#")
                    		param_value = parameter.translate(string.maketrans("\n\t\r", "   "))
                    		if param_value.find('"') != -1:
                        		param_value = param_value.replace('"',r'')
                    		if param_value == "" :
					logging(parameter+" does not exist in "+file_path)
					staticParamConfiguration = False 
        	        	if parameter == "BOOTPROTO" and not keyValEqMatch_new("BOOTPROTO", "static", param_value) and \
        	        		not keyValEqMatch_new("BOOTPROTO", "none", param_value):
        	       			logging("BOOTPROTO parameter is not set to static or none, please fix it manually.")
					staticParamConfiguration = False 
			 	elif parameter == "ONBOOT" and not keyValEqMatch_new("ONBOOT","yes",param_value):
                        		logging("ONBOOT parameter is not set to required value to make the ip static, please fix it manually.")
					staticParamConfiguration = False 
        	        	elif parameter == "IPADDR" and parameter != "":
					if not re.match(r'.*=\s*\d+.\d+.\d+.\d+',param_value):
						logging("Value of ipaddress is not properly configured.")
						staticParamConfiguration = False 
        	        	elif parameter == "IPADDR" and parameter != "":
					if not re.match(r'.*=\s*\d+.\d+.\d+.\d+',param_value):
						logging("Value of ipaddress is not properly configured.")
						staticParamConfiguration = False 
        	        	elif parameter == "GATEWAY" and parameter != "":
					if not re.match(r'.*=\s*\d+.\d+.\d+.\d+',param_value):
						logging("Value of gateway is not properly configured.")
						staticParamConfiguration = False 
				deviceCount = deviceCount+1

			#5.Checking the required static mode parameters inifcfg-<name> file for active device.
			#In some cases Prefix exists at place at place of gateway.
			netmaskParam = runOnShell("grep -w NETMASK.* " + file_path + " | grep -v ^#")
			if netmaskParam != "":
				if not re.match(r'.*=\s*\d+.\d+.\d+.\d+',netmaskParam):
					logging("Value of netmask is not properly configured.")
					staticParamConfiguration = False 
			else:
				prefixParam = runOnShell("grep -w PREFIX.* " + file_path + " | grep -v ^#")
				if not re.match(r'.*=\s*\d+',prefixParam):
					logging("Value of prefix is not properly configured.")
					staticParamConfiguration = False 
			if not staticParamConfiguration:
				dhcpDevice.append(device)
				
	returnFlag = True
	if len(dhcpDevice) != 0:
		logging("Following are dhcp configured device(s) which need to be fixed manually.")
		print ", ".join(dhcpDevice)
		returnFlag = False	
	if len(physicalDevDHCP) != 0:
		logging("Following are device(s) which has configured ip but not static value configured, hence need to fix this rule manually.")
		print ", ".join(physicalDevDHCP)
		returnFlag = False	
		
	if not returnFlag:
		return None
	 		
        logging("The DHCP client is disabled.")
	return True

def fixRule38679():
	logging("Currenlty not providing the fix for this rule, please fix it manually.")
	return None
	#Commented as will push it in next release.
'''
	#Checking the ifconfig command.
	if not os.path.exists('/sbin/ifconfig'):
	    InstallPackage("net-tools")

	#Commmand to extract the device from system.
	ipAddress = runOnShell("ifconfig | grep 'inet addr:'| grep -v '127.0.0.1' | cut -d: -f2 | awk '{ print $1}'")
	ipAddressList = ipAddress.splitlines()	
	netMask = runOnShell("ifconfig | grep 'inet addr:'| grep -v '127.0.0.1' | cut -d: -f4 | awk '{ print $1}'")
	netMaskList = netMask.splitlines()
	gateWay = runOnShell("route -n | grep UG | grep -v UGH |cut -f 10 -d ' '")
        gateWay = gateWay.translate(string.maketrans("\n\t\r", "   "))
	hwAddr = runOnShell("ifconfig | grep -o -E '([[:xdigit:]]{1,2}:){5}[[:xdigit:]]{1,2}'")
	hwAddrList = hwAddr.splitlines()

	list_of_device = runOnShell("ifconfig |grep -e ^[a-z] |grep -v lo | awk '{ printf $1 FS}'").split()
	file_startup = "#This file describes the network interfaces available on your system\n# and how to activate them.\
For more information, see interfaces(5).\n# The loopback network interface\nauto lo\niface lo inet loopback\n"
	count = 0
	ubuntu_file_data = ""
	for device in list_of_device:
	    if OsName.lower() == "ubuntu":
		if count == 0:
		    runOnShell('cp /etc/network/interfaces /etc/network/interfaces-backup')
		device_command = "\niface "+device+" inet static\naddress "+ipAddressList[count]+\
"\nnetmask "+netMaskList[count]+"\ngateway "+gateWay+"\nhwaddress "+hwAddrList[count] + "\n"
		ubuntu_file_data = ubuntu_file_data + device_command
	    else:
		if count==0:
		    runOnShell('cp -r /etc/sysconfig/network-scripts /etc/sysconfig/network-scripts-backup')
		file_path = runOnShell("egrep -l 'NAME="+ device +"|DEVICE="+ device + "' /etc/sysconfig/network-scripts/ifcfg-*")
		list_of_file = file_path.splitlines()
		for abs_file_path in list_of_file:
		#abs_file_path = os.path.join('/etc/sysconfig/network-scripts',"ifcfg-"+device)
		#abs_file_path = os.path.join('/etc/sysconfig/network-scripts',"ifcfg-"+device)
			if os.path.exists(abs_file_path):
				file_data = ""
				ip_add_bool = False
				net_mask_bool = False
				gateway_bool = False
				list_of_lines = open(abs_file_path,'r').readlines()
			    	for line in list_of_lines: 
			      		if isL(line) and "BOOTPROTO" in line:
			          		file_data += "BOOTPROTO=static\n"
			        	elif isL(line)  and "IPADDR" in line:
			             		ip_add_bool = True
			          		file_data += "IPADDR="+ipAddressList[count]+"\n"
			        	elif isL(line)  and "NETMASK" in line:
			             		net_mask_bool = True
			          		file_data += "NETMASK="+netMaskList[count]+"\n"
			        	elif isL(line)  and "GATEWAY" in line:
			             		gateway_bool = True
			          		file_data += "GATEWAY="+gateWay+"\n"
					else:
						file_data+=line
			
				if not(ip_add_bool):
					file_data += "# Cloud Raxak updated next line\n"
			        	file_data += "IPADDR="+ipAddressList[count]+"\n"
				if not(net_mask_bool):
					file_data += "# Cloud Raxak updated next line\n"
			          	file_data += "NETMASK="+netMaskList[count]+"\n"
				if not(gateway_bool):
					file_data += "# Cloud Raxak updated next line\n"
			          	file_data += "GATEWAY="+gateWay+"\n"
				
			    	fout = open(abs_file_path, 'wt')
				if fout != None:
			    		fout.write(file_data)
			
			count = count + 1	
	if OsName.lower() == "ubuntu":
		handle = open('/etc/network/interfaces','w+')
		startup = "# interfaces(5) file used by ifup(8) and ifdown(8)\nauto lo\niface lo inet loopback\n"
		handle.write(startup)
		handle.write(ubuntu_file_data)
        	handle.close();

	#Command to receive the network changes. 
	runOnShell('service network restart')	
'''

def checkRule38680():
	if not CheckService("auditd"):
		return False
	logging("Checking whether the system is configured to send email to an account when it needs to notify an administrator.")
	line = runOnShell('grep "action_mail_acct" /etc/audit/auditd.conf | grep -v "^#" ')
	if not line:
		logging("System is not configured to send email to an account when it needs to notify an administrator.")
		return False
	value = getValueOfKey("action_mail_acct", line.rstrip('\n'))
	if value is not None:
		if not value == "root":
			logging("System is not properly configured to send email to notify an administrator.")
			return False
		res =  re.sub(' +', ' ', line)
		if not "action_mail_acct = root" in res:
			logging("System is not properly configured to send email to notify administrator.")
			return False
		logging("System is configured to send email to an account when it needs to notify an administrator.")
		return True
	logging("System is not properly configured to send email to an account when it needs to notify an administrator.")
	return False

def fixRule38680():
        if not InstallPackage("audit"):
            return None
	match_param = False
	lastLine=""
	with open('/etc/audit/auditd.conf') as f:
		s = ""
		for line in f:
			if ((line[0].strip() != '#') and ("action_mail_acct" in line)):
				if not tokenMatch("Cloud Raxak updated next line",lastLine):
					s += "# Cloud Raxak updated next line\n"
				logging("Updating audit configuration file to send email to notify an administrator.")
				s += "action_mail_acct = root\n"
				match_param = True
			else:
				s += line
				lastLine=line

		if match_param == False:
			logging("Configuring audit to send email to notify an administrator.")
			s += "# Cloud Raxak updated next line\naction_mail_acct = root\n"

		try:
			fout = open('/etc/audit/auditd.conf', "wt")
			fout.write(s)
		except:
			pass
		finally:
			fout.close()
        	RunService("auditd")
        
def checkRule38681():
	logging ("Checking if All GIDs referenced in /etc/passwd file are defined in /etc/group file.")
	res = runOnShell('pwck -r | grep "no group"')
        if res == "":
	    logging ("GID(s) referenced in /etc/passwd are available in /etc/group.")
	    return True
	else:
	    logging ("GID(s) referenced in /etc/passwd are not available in /etc/group.")
	    return False

def fixRule38681():
	logging ("Checking /etc/passwd file to update missing group related information in /etc/group file.")
	passwdList = open("/etc/passwd", "r").readlines()
	res = runOnShell( 'pwck -r | grep "no group"')
	if res:
	    tmpList = res.split(" ")
	    tmpListLen = len(tmpList)
	    cnt = 1
	    finalList = [] # It contains only unentried group users which are available in passwd file
	    tmpDict = {} #It contains group file new entries or modifying entries
	    for index in range(1, tmpListLen):
		if cnt == index:
	            #unentried user
	            searchUser = tmpList[index].replace("'", "")
		    finalList = filter(lambda ele: re.match(searchUser, ele), passwdList)
		    #Converting unentried group users to string from list and spliting them for collecting required fields
		    finalListString = ("".join(finalList)).split(":")
		    tmpDict[finalListString[0]] = finalListString[0] + ":" + finalListString[1] + ":" + finalListString[3] + ":"
		    cnt = cnt + 4

		    # This loop will take care of duplicated GID entries in /etc/group file
		    try:
		        groupEntryRes = runOnShell("grep -e " + finalListString[0] + ": /etc/group | grep -v '^#' | cut -d':' -f3").strip()
		        if groupEntryRes == "":
		            # We are handling this in next , if there GID is empty 
			    continue

			# To find the id details i.e., username, and groupId
			idRes = runOnShell("id " + groupEntryRes, False)
			groupId = idRes.split('gid=')[1].split()[0].split('(')[0]
			groupName = idRes.split('(')[1].split(')')[0]
			tmpDict[groupName] = groupName + ":x:" + groupId + ":"
		    except IndexError:
		        # As we are handling this exception in follwing code. Hence, not handling here
		        pass

	# To identify x user in /etc/group file
	xUserFlag = False

	# This list is used to identify the duplicate entries
	tmpGroupEntryDelList = []

        groupFileLines = ""
	fout = None
	for groupEntry in tmpDict:
            if groupEntry == "x":
		xUserFlag = True
                groupFileLines += tmpDict[groupEntry] + "\n"
                continue
	    res = runOnShell ("grep -e ^\s*" + groupEntry + "[:] /etc/group | grep -v '^#' | cut -d ':' -f1", False).splitlines()
	    #If an entry is not available
	    if len(res) == 0:
		groupFileLines += tmpDict[groupEntry] + "\n"
	    else:
	        groupFileEntries = runOnShell ('grep -e ^\s*' + groupEntry + ': /etc/group | grep -v "^#"', False).splitlines()
		tmpStr = tmpDict[groupEntry].split(':')

		splitRes = groupFileEntries[0].split(':')
		try:
		    groupFileLines += splitRes[0] + ":" + splitRes[1] + ":" + tmpStr[2] + ":" + splitRes[3] + "\n"
		except IndexError:
		    groupFileLines += tmpDict[groupEntry] + "\n"

	    # The below loop will identify duplicate multiple entries
	    groupLines = open("/etc/group").readlines()
	    for groupEle in groupLines:
	        groupEleSplit = groupEle.strip().split(':')
	        if groupEleSplit[0] == groupEntry:
		    tmpGroupEntryDelList.append(groupEle)

	# Removing duplicated existing entries from the groupLines list (Indirectly removing from /etc/group file)
	groupLines = [ele for ele in groupLines if ele not in tmpGroupEntryDelList]

	# Handling x user here
	if xUserFlag:
            #Excluding the entry from /etc/group which starts with x:
            groupLines = filter(lambda ele: not ele.startswith("x:"), groupLines)

	#Concatenating remaining /etc/group file entries and excluded /etc/group file entries
	groupFileString = "".join(groupLines) + groupFileLines

	logging ("Updating /etc/group file with proper group information which is available in /etc/passwd file.")
        fout = open("/etc/group", 'w')
	if fout != None:
            fout.write(groupFileString)
            fout.close()

def checkRule38682():
	logging('Checking if the system is configured to prevent the loading of the "bluetooth" and "net-pf-31" kernel module.')
	grep_bluetooth_block_module = runOnShell('grep -wr bluetooth /etc/modprobe.d | grep -v "^#"')
	grep_netpf31_block_module = runOnShell('grep -wr net-pf-31 /etc/modprobe.d | grep -v "^#"')
	flag = False
	bluetooth_block_module_list = grep_bluetooth_block_module.split("\n")
	for bluetooth_block_module in bluetooth_block_module_list:
	    if re.match(r'.*\s*(\bbluetooth\b)\s*', bluetooth_block_module):
	        blacklist_bluetooth = bluetooth_block_module.split(":")[1]
	        blacklist_bluetooth = blacklist_bluetooth.replace(" ","")
	        if (blacklist_bluetooth == "installbluetooth/bin/false") or (blacklist_bluetooth == "installbluetooth/bin/true") or (blacklist_bluetooth == "blacklistbluetooth"):
	            logging("Checking whether 'bluetooth' kernel module is active.")
	            res = runOnShell("lsmod | grep bluetooth")
	            if re.match(r'.*\s*(\bbluetooth\b)\s*', res):
	                logging("Remove the 'bluetooth' kernel module or reboot the system to disable 'bluetooth' kernel module.")
	                return None
	            else:
	                flag = True 
	                logging("System is configured properly to prevent loading of 'bluetooth' kernel module.")
	if flag != True:
	    logging("System is not configured properly to prevent loading of 'bluetooth' kernel module.")
	    return False
	netpf31_block_module_list = grep_netpf31_block_module.split("\n")
	for netpf31_block_module in netpf31_block_module_list:
	    if re.match(r'.*\s*(\bnet-pf-31\b)\s*', netpf31_block_module):
	        blacklist_netpf31 = netpf31_block_module.split(":")[1]
	        blacklist_netpf31 = blacklist_netpf31.replace(" ","")
	        if (blacklist_netpf31 == "installnet-pf-31/bin/false") or (blacklist_netpf31 == "installnet-pf-31/bin/true") or (blacklist_netpf31 == "blacklistnet-pf-31"):
	            logging("Checking whether 'net-pf-31' kernel module is active.")
	            res = runOnShell("lsmod | grep net-pf-31")
	            if re.match(r'.*\s*(\bnet-pf-31\b)\s*', res):
	                logging("Remove the 'net-pf-31' kernel module or reboot the system to disable 'net-pf-31' kernel module.")
	                return None
	            else:
		        logging("System is configured properly to prevent loading of 'net-pf-31' kernel module.")
	                return True
	logging("System is not configured properly to prevent loading of 'net-pf-31' kernel module.")
	return False
    
def fixRule38682():
            addLine = "install bluetooth /bin/true\n"
            addLine1 = "install net-pf-31 /bin/true\n"

            if os.path.exists("/etc/modprobe.d/cloudraxak.conf"):
                f = open("/etc/modprobe.d/cloudraxak.conf", "r+")
            else:
                f = open("/etc/modprobe.d/cloudraxak.conf", "w+")
            flag = False
            flag1 = False
            s = ""
            lastLine = ""
            for line in f:
                if isL(line) and "net-pf-31" in line:
                    if not tokenMatch('Cloud Raxak updated next line',lastLine):
                        s += "# Cloud Raxak updated next line\n"
                    s += addLine1
                    flag = True
                elif isL(line) and "bluetooth" in line: 
                    if not tokenMatch('Cloud Raxak updated next line',lastLine):
                        s += "# Cloud Raxak updated next line\n"
                    s += addLine
                    flag1 = True
                else:
                    s += line
                    lastLine = line
            if not(flag) or not(flag1):
                if not tokenMatch('Cloud Raxak updated next line',lastLine):
                    s += "# Cloud Raxak updated next line\n"
                if flag == False and flag1 == True:
                    s += addLine1
                elif flag1 == False and flag == True:
                    s += addLine
                else:
                    s += addLine
                    s += addLine1
            fout = None
            try:
                fout = open("/etc/modprobe.d/cloudraxak.conf", 'wt')
                fout.write(s)
            finally:
                if fout is not None:
                    fout.close()
            logging("Preventing 'bluetooth' and 'net-pf-31' kernel modules from being loaded.")
            runOnShell("modprobe -r bluetooth")
            runOnShell("modprobe -r net-pf-31")

def checkRule38683():
	logging ("Checking duplicate user names on the system.")
	res = runOnShell("pwck -rq")
	if res:
		logging ("Removing a duplicate username without analysis can loose all the information related to the particular user,\
 hence recommended to delete or change the username manually.")
		return None
	logging("duplicate names does not exist.")
	return True
    
def fixRule38683():
	logging("Removing a duplicate username without analysis can loose all the information related to the particular user,\
 hence recommended to delete or change the username manually.")
        return None
        # return None because duplicate users cannot be deleted from /etc/passwd using command so,
        # we have to manually delete the user with duplicate names.
            
def checkRule38684(val = 10):
	logging("Checking the maximum number of simultaneous system logins configured for all users, to limit the risks related to denial of service attacks.")
	check_maxlogins = runOnShell('grep -w maxlogins /etc/security/limits.conf /etc/security/limits.d/*.conf --no-messages | grep -v "#"')
	if not check_maxlogins:
		logging("Configuration for maximum number of simultaneous system logins for all users was not found.")
		return False
	check_maxlogins = check_maxlogins.translate(string.maketrans(":"," "))
	check_maxlogins = check_maxlogins.splitlines()
	count_line = False
	filePathList = []
	try:
		# Check in all .conf files in limits.d directory if maxlogins setting is configured properly or not. Even if there are multiple files 
                # with maxlogin settings, the linux system reads limits.conf file first and then all .conf files in limits.d directory, the setting 
                # that is read last is taken into effect.
		for line_no in range(len(check_maxlogins)):
			check_maxlogins_element = check_maxlogins[line_no].split()
			filePathList.append(check_maxlogins_element[0])
			if len(check_maxlogins_element) != 5 or check_maxlogins_element[1] != "*" or check_maxlogins_element[2] != "hard" or int(check_maxlogins_element[4]) > val or int(check_maxlogins_element[4]) < 1 or filePathList.count(check_maxlogins_element[0]) > 1:
				count_line = True
				break
		if count_line:
			logging("The maximum number of simultaneous system logins is not configured correctly for all users.")
			return False
		else:
			logging("The maximum number of simultaneous system logins is configured correctly for all users.")
			return True
	except (ValueError,IndexError):
		logging("The maximum number of simultaneous system logins is not configured correctly for all users.")
		return False

def fixRule38684():
    check_maxlogins = runOnShell('grep -w maxlogins /etc/security/limits.conf /etc/security/limits.d/*.conf --no-messages | grep -v "#"')
    check_maxlogins = check_maxlogins.translate(string.maketrans(":"," "))
    # If all maxlogin settings are commented or do not exist the condition below is satisfied.

    if not check_maxlogins:
        fout = open('/etc/security/limits.conf', 'at')
        add_line = "# Cloud Raxak updated next line\n* hard maxlogins 10\n"
        if fout != None:
            fout.write(add_line)
            fout.close()
    else:
	check_maxlogins = check_maxlogins.splitlines()
        filePathList = []
        filePathList_check = []
        for line_no in range(len(check_maxlogins)):
            check_maxlogins_element = check_maxlogins[line_no].split()
            filePathList_check.append(check_maxlogins_element[0])
            if len(check_maxlogins_element) != 5 or check_maxlogins_element[1] != "*" or check_maxlogins_element[2] != "hard" or int(check_maxlogins_element[4]) > 10 or int(check_maxlogins_element[4]) < 1 or filePathList_check.count(check_maxlogins_element[0]) > 1:

                # Store the filepath in a list where the maxlogins value in that particular file is not configured properly.

                filePathList.append(check_maxlogins_element[0])
        # If there are multiple entries of '*    hard    maxlogins' in '/etc/security/limits.conf' '/etc/security/limits.d/*.conf' then list 
        # filePathList will conatin duplicate entries of the same absolute path so the below line removes only those duplicate entries.

        filePathList = list(set(filePathList))
        for file_write in range(len(filePathList)):
            # Write the correct setting for maxlogins value for all .conf files where it is not configured properly.

            with open(filePathList[file_write], "r") as file_data:
               flag_maxlogins = False
               changeline = ""
               lastLine = ""
               logging("Updating the maximum number of simultaneous system logins.")
               for line in file_data:
                   if isL(line) and "maxlogins" in line:
                       # Preventing multiple entries of '*     hard      maxlogins' written to file '/etc/security/limits.conf' '/etc/security/limits.d/*.conf'.
                       if not flag_maxlogins:
                           if not tokenMatch('Cloud Raxak updated next line',lastLine):
                               changeline += "# Cloud Raxak updated next line\n"
                           changeline += "* hard maxlogins 10\n"
                           flag_maxlogins = True   
                   else:
                       lastLine = line
                       changeline += line
            if not(flag_maxlogins):
                if not tokenMatch('Cloud Raxak updated next line',lastLine):
                    changeline += "# Cloud Raxak updated next line\n"
                changeline += "* hard maxlogins 10\n"
            fout = open(filePathList[file_write], 'wt')
            if fout != None:
                fout.write(changeline)
                fout.close()

#def checkRule38685(string="c1",accountMax="1"):#accountMax in years
#        return True
#
#def fixRule38685():
#        return None
#
def checkRule38685():
	if not os.path.exists ("/etc/login.defs"):
	    logging ("Since user account login configuration file is not available, need to execute it as manually.")
	    return None

	#If UID_MIN value is not available, considering default values
	UID_MAX_VAL = 60000
	if (OsName.lower() == "ubuntu" or (OsName.lower() == "centos" and OsVersion >= (7,0)) or (OsName.lower() == "redhat" and OsVersion >= (7,0))):
	    UID_MIN_VAL = 1000
	else: #For CentsOS(6.x), Redhat(6.x), and Amazon(2015, 2013)
	    UID_MIN_VAL = 500

	#Opening and splitting this file to find UID_MIN and UID_MAX values
	user_login_file = open("/etc/login.defs").readlines()
	#To find UID_MIN and UID_MAX values in /etc/login.defs file
	UIDList = filter(lambda ele: re.search(r'.*\s*(\bUID_MIN\b)\s*', ele) or re.search(r'.*\s*(\bUID_MAX\b)\s*', ele), user_login_file)
	for uidValue in UIDList:
	    try:
		uidValue = uidValue.strip()
		uidValue = re.sub(r"\s+", " ", uidValue)
		if "UID_MIN" in uidValue:
		    uidValue = uidValue.split(' ')[1]
		    UID_MIN_VAL = int(uidValue)
		elif "UID_MAX" in uidValue:
		    uidValue = uidValue.split(' ')[1]
		    UID_MAX_VAL = int(uidValue)
		else:
		    pass
	    except:
		pass

	#The below list contains all user accounts whose account's expiry is "never"
	neverList = []
	#The below list contains all user accounts whose Lastpasswordchage is "password must be changed"
	manualList = []

	logging ("Finding all temporary user accounts in the system.")
	#To find the available users except root user
	user_accounts_string = runOnShell("awk -F'[/ : ]' '{if ($3 >= " + str(UID_MIN_VAL) + " && $3 <= " + str(UID_MAX_VAL) +") print $1}' /etc/passwd")
        user_accounts_string = user_accounts_string.translate(string.maketrans("\n\t\r", "   "))
        list_of_user_accounts = filter(lambda elem: elem != "", user_accounts_string.split(" "))
	logging ("Checking user accounts expiration date.")
	for user_account in list_of_user_accounts:
                if user_account == username:
                    logging("> Ignoring check for Raxak Protect username " + user_account)
                    continue

		res = runOnShell('chage -l ' + user_account)
		if res != '':
			lis = res.split('\n')	
			for element in lis[:-1]:
				if "Last password change" in element:
				    account_lastpwdchange_value = element.split(':')[1]
        			    account_lastpwdchange_value = account_lastpwdchange_value.translate(string.maketrans("\n\t\r", "   ")).strip()
				elif 'Account expires' in element:
				    account_expire_value = element.split(':')[1]
        			    account_expire_value = account_expire_value.translate(string.maketrans("\n\t\r", "   ")).strip()
				    break
			
		#We are trying to modify the expiry date to the users whose account expire is "never"
		if "never" == account_expire_value:
		    neverList.append(user_account)

		if "password must be changed" == account_lastpwdchange_value:
		    manualList.append(user_account)

	#Removing manual user entries from the never list
	for manualUser in manualList:
	    if manualUser in neverList:
		neverList.remove(manualUser)

	if len(manualList) > 0:
	    if len(neverList) > 0:
	        logging ("Following are the list of temporary user accounts have no expiration date set:")
	        for neverUser in neverList:
		    logging (str(neverUser) + "\n")
	    logging ("Since following are the list of temporary user accounts whose 'password change' must be changed, \
need to fix as manually:")
	    for manualUser in manualList:
		logging (str(manualUser) + "\n")
	    return None

	elif len(neverList) > 0:
	    logging ("Following user accounts have no expiration date set. Please set the expiry date manually as per your requirement.")
	    for neverUser in neverList:
		logging (str(neverUser) + "\n")
	    return None
	else:
	    logging ("All temporary user accounts expiration date is set.")
	    return True

def fixRule38685():
	logging ("All user accounts expiry date should not be set automatically. It should be fixed as manually.")
	return None

	logging ("Opening /etc/login.defs file to find UID_MIN and UID_MAX values.")

	UID_MAX_VAL = 60000
	#If UID_MIN and UID_MAX values are not available, considering default values
	if (OsName.lower() == "ubuntu" or (OsName.lower() == "centos" and OsVersion >= (7,0)) or (OsName.lower() == "redhat" and OsVersion >= (7,0))):
	    UID_MIN_VAL = 1000
	else: #For CentsOS(6.x), Redhat(6.x), and Amazon(2015, 2013)
	    UID_MIN_VAL = 500

	#Opening and splitting this file to find UID_MIN and UID_MAX values
	user_login_file = open("/etc/login.defs").readlines()
	#To find UID_MIN and UID_MAX values in /etc/login.defs file
	UIDList = filter(lambda ele: re.search(r'.*\s*(\bUID_MIN\b)\s*', ele) or re.search(r'.*\s*(\bUID_MAX\b)\s*', ele), user_login_file)
	for uidValue in UIDList:
	    try:
		uidValue = uidValue.strip()
		uidValue = re.sub(r"\s+", " ", uidValue)
		if "UID_MIN" in uidValue:
		    uidValue = uidValue.split(' ')[1]
		    UID_MIN_VAL = int(uidValue)
		elif "UID_MAX" in uidValue:
		    uidValue = uidValue.split(' ')[1]
		    UID_MAX_VAL = int(uidValue)
		else:
		    pass
	    except:
		pass

	logging ("Finding all temporary user accounts in the machine.")
	#To find the available users except root user
	user_accounts_string = runOnShell("awk -F'[/ : ]' '{if ($3 >= " + str(UID_MIN_VAL) + " && $3 <= " + str(UID_MAX_VAL) +") print $1}' /etc/passwd")
        user_accounts_string = user_accounts_string.translate(string.maketrans("\n\t\r", "   "))
        list_of_user_accounts = filter(lambda elem: elem != "", user_accounts_string.split(" "))

	lastPasswordChangeDate = ""
	logging ("Checking all user's account expiry date.")
	for user_account in list_of_user_accounts:
                if user_account == username:
                    logging("> Ignoring check for Raxak Protect username " + user_account)
                    continue

		res = runOnShell('chage -l '+user_account)
		if res != '':
			lis = res.split('\n')
			for element in lis:
				if 'Account expires' in element:
				    account_expire_value = element.split(':')[1]
				    account_expire_value = account_expire_value.translate(string.maketrans("\n\t\r", "   ")).strip()
				    if "never" != account_expire_value:
					break
				elif "Last password change" in element:
					lastPasswordChangeDate = element.split(':')[1]
				elif "Password expires" in element:
					passwordExpires = element.split(':')[1]
				elif "Password inactive" in element:
					passwordInactive = element.split(':')[1]
				else:
					pass
			
		#We are trying to modify the expiry date to the users whose account expire is "never"
		if "never" == account_expire_value:
			changeAccountExpiryDate = ChangeUserAccountExpiryDate (user_account, lastPasswordChangeDate, passwordExpires, passwordInactive)
			if changeAccountExpiryDate == None:
			    return None
			logging ("Changing user {0}'s expiry date to valid expiry date".format(user_account))
			runOnShell('chage -E ' + str(changeAccountExpiryDate) + " " + user_account)

def checkRule38686():
	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		firewall_status = runOnShell("systemctl is-active firewalld").replace('\n','')
		iptables_status = runOnShell("systemctl is-active iptables").replace('\n','')
		if (firewall_status == "active" and iptables_status == "active"):
		    logging("Firewalld and iptables both are running which should not be used at a time.\
Please fix it manually by turning off one of them.In CentOS 7 the default firewall is `firewalld` so it is recommended to use firewalld.")	
		    return None
		elif firewall_status == "active": 
			#Checking if forward policy is implemented with firewall. 
			enabled_token = runOnShell("systemctl is-enabled firewalld").replace('\n','')
			ipv6_rule = runOnShell("firewall-cmd --permanent --direct --get-rules ipv6 filter FORWARD")
			ipv4_rule = runOnShell("firewall-cmd --permanent --direct --get-rules ipv4 filter FORWARD")
			if enabled_token == "enabled" and "DROP" in ipv6_rule and "DROP" in ipv4_rule:
				logging("The systems local firewall is implemented with a deny-all, allow-by-exception policy for forwarded packets.")
				return True
		elif iptables_status == "active":
			enabled_token = runOnShell("systemctl is-enabled iptables").replace('\n','')
			drop_forward_policy = runOnShell("grep -w :FORWARD /etc/sysconfig/iptables | grep -v '^#' ")
			if enabled_token == "enabled" and "DROP" in drop_forward_policy:
				logging("The systems local firewall is implemented with a deny-all, allow-by-exception policy for forwarded packets.")
				return True
	elif OsName.lower() == "ubuntu":
		logging("Checking the status of Firewall")
		match_object = runOnShell("ufw status verbose").split('\n')[0]
		match_object1 = match_object.split(':')[1]
		if tokenMatch('active',match_object1):
			logging("Checking the service status of Firewall")
			service_status = runOnShell("service ufw status")
			service_status = service_status.split('\n')[0]
			if "start/running" in service_status:
				logging("Checking the default forward policy")	
				def_forward_policy = runOnShell('grep -w DEFAULT_FORWARD_POLICY /etc/default/ufw | grep -v "^#"')
				def_forward_policy = def_forward_policy.translate(string.maketrans("\n\t\r", "   "))
				if keyValEqMatch("DEFAULT_FORWARD_POLICY",'"DROP"',def_forward_policy):
					logging("Firewall is running.")
					return True
	else:
    		if CheckService("iptables"):
        		if "DROP" in runOnShell("grep -w :FORWARD /etc/sysconfig/iptables | grep -v '#' "):
				logging("Firewall is active/running properly and default forward policy is set to drop.")
				return True
	logging("Firewall is not active/running properly or default forward policy is not set to drop, hence it is recommended to fix it manually.")
	return None


def fixRule38686():
	logging("Please fix it manually.")
	return None
	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		policy_fix = False
		if 'No such file or directory' not in runOnShell("systemctl status firewalld"):
			runOnShell("systemctl start firewalld")
			runOnShell("systemctl enable firewalld")
			runOnShell("firewall-cmd --permanent --direct --add-rule ipv4 filter FORWARD 1 -j DROP ")
			runOnShell("firewall-cmd --permanent --direct --add-rule ipv6 filter FORWARD 1 -j DROP ")
		else:
			runOnShell("systemctl start iptables.service")
			runOnShell("systemctl enable iptables.service")
			policy_fix = True
	elif OsName.lower() == "ubuntu":
		forward_policy = runOnShell('grep net/ipv4/ip_forward /etc/ufw/sysctl.conf | grep -v "^#"')
  		forward_policy = forward_policy.translate(string.maketrans("\n\t\r", "   ")).strip()
		policy_exist_bool = keyValEqMatch("net/ipv4/ip_forward","1",forward_policy)
		forward_policy_default = runOnShell('grep -w DEFAULT_FORWARD_POLICY /etc/default/ufw | grep -v "^#"')
		forward_policy_default = forward_policy_default.translate(string.maketrans("\n\t\r", "   "))
		policy_default_exist_bool = keyValEqMatch("DEFAULT_FORWARD_POLICY",'"ACCEPT"',forward_policy_default)
		file_path_list = []
		if policy_exist_bool:
			file_path_list.append('/etc/ufw/sysctl.conf')
		if policy_default_exist_bool:
			file_path_list.append('/etc/default/ufw')
		for file_path in file_path_list:
			with open(file_path, 'r') as fileHandler:
	        	    file_data = ""
	        	    for line in fileHandler:
	        	        if "net/ipv4/ip_forward" in line and isL(line):
	        	            file_data += "# Cloud Raxak updated next line\n"
	        	            file_data += "#net/ipv4/ip_forward=0\n"
	        	        elif "DEFAULT_FORWARD_POLICY" in line and isL(line):
	        	            file_data += 'DEFAULT_FORWARD_POLICY="DROP"\n'
	        	        else:
	        	            file_data += line

	        	    fout = open(file_path, 'wt')
		            if fout != None:
		                fout.write(file_data)
		                fout.close()
		runOnShell('ufw disable')
		runOnShell("echo 'y'|ufw enable")
		runOnShell("ufw allow 22")
		runOnShell("ufw reload")
	else:
		policy_fix = True

	if policy_fix:
		with open('/etc/sysconfig/iptables', 'r') as filehandler:
		    file_data = ""
		    for line in filehandler:
		        if ":FORWARD" in line and isL(line):
		            file_data += "# Cloud Raxak updated next line\n"
		            file_data += ":FORWARD DROP [0:0]\n"
		        else:
		            file_data += line

		    fout = open('/etc/sysconfig/iptables', 'wt')
		    if fout != None:
		        fout.write(file_data)
		        fout.close()
		

def checkRule38687():
    if OsName.lower() == "ubuntu":
        logging("Checking if 'openswan' package is installed on system.")
        package_name = "openswan"
        res = runOnShell("dpkg -s openswan")
    elif ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
        logging("Checking if 'libreswan' package is installed on system.")
        package_name = "libreswan"
        res = runOnShell("rpm -q libreswan")
    else:
        logging("Checking if 'openswan' package is installed on system.")
        package_name = "openswan"
        res = runOnShell("rpm -q openswan")

    if ("not installed" in res) or ("deinstall ok" in res):
        logging("The "+"'"+package_name+"'"+" package provides an implementation of IPsec and IKE, which permits the creation of secure tunnels over untrusted networks. "+"'"+package_name+"'"+" package is not installed on your system. Please install the "+"'"+package_name+"'"+" package and configure it manually.")
        return None
    logging(""+package_name+" package is installed on system.")
    return True

def fixRule38687():
    if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
        logging("The 'libreswan' package provides an implementation of IPsec and IKE, which permits the creation of secure tunnels over untrusted networks. 'libreswan' package is not installed on your system. Please install the 'libreswan' package and configure it manually.")
    else:
        logging("The 'openswan' package provides an implementation of IPsec and IKE, which permits the creation of secure tunnels over untrusted networks. 'openswan' package is not installed on your system. Please install the 'openswan' package and configure it manually.")


def checkRule38688():
	if OsName.lower() == "ubuntu":
	    if not CheckPackage('ubuntu-desktop') or not CheckPackage('xorg'):
		logging("Since this system is not a GUI based system, this rule is not applicable.")
		return True

	    logging ("Checking which display manager is in usage.")
	    displayManager = runOnShell('cat /etc/X11/default-display-manager')
	    if "lightdm" in displayManager:
		logging ('Enable the banner-message-enable schema is not required for ubuntu OS in case of "lightdm" desktop manager. \
The banner text configuration is getting fixed as part of the V-38689. Hence, marking this rule as success.')
		return True

	    elif "gdm" in displayManager:
		screenBlock = False
		statusFlag = False
		bannerList = runOnShell("egrep -hr  'banner-message-enable|disable-user-list|\[org/gnome/login-screen]' /etc/dconf/db/gdm.d/*").splitlines()
		for bannerElemnt in bannerList:
		    matchObject = re.match(r'.*(\[.*\])', bannerElemnt)
		    if matchObject != None:
			if tokenMatchIC("[org/gnome/login-screen]", matchObject.group(1)):
			    screenBlock = True
		    if screenBlock:
			if isL(bannerElemnt) and tokenMatchIC("disable-user-list=true", re.sub(' +', '', bannerElemnt)):
			    logging("The 'disable-user-list' flag is set to 'true' which will prevent the user list \
while logging into the system. If 'disable-user-list' flag is set to 'true', banner message can not be allowed. Please fix it manually.")
			    return None
			if isL(bannerElemnt) and tokenMatchIC("banner-message-enable=true", re.sub(' +', '', bannerElemnt)):
			    statusFlag = True
		if statusFlag:
		    logging ("The login warning banner is properly configured.")
		    return True
		logging ("The login warning banner is not configured.")
		return False
	else:
	    logging("Checking if the system is GUI based system.")
	    if not os.path.exists('/usr/bin/gconftool-2'):
		logging("Since this system is not a GUI based system, this rule is not applicable.")
		return True

	    logging("Checking if login warning banner is enabled.")
	    if (OsName.lower() == "redhat" or OsName.lower() == "centos") and OsVersion >= (7,0):
		bannerStatus = runOnShell('sudo -u gdm gsettings get org.gnome.login-screen banner-message-enable')
	    else:
		bannerStatus = runOnShell('gconftool-2 --get /apps/gdm/simple-greeter/banner_message_enable')

	    bannerStatus = bannerStatus.translate(string.maketrans("\n\t\r", "   "))
	    if tokenMatchIC("true", bannerStatus):
	        logging ("Login warning banner is enabled.")
		return True
	    logging ("Login warning banner is disabled.")
	    return False


def fixRule38688():
	logging ("Enabling the login warning banner status.")
	requiredText = " \"I've read & consent to terms in IS user agreem't.\""
	if OsName.lower() == "ubuntu":
	    displayManager = runOnShell('cat /etc/X11/default-display-manager')

	    if "gdm" in displayManager:
		bannerElemnts = runOnShell("egrep -r \'banner-message-enable|\[org/gnome/login-screen]\' /etc/dconf/db/gdm.d/*")
		if bannerElemnts == "":
		    bannerPath = '/etc/dconf/db/gdm.d/00-upstream-settings'
		else:
		    try:
		        bannerList = bannerElemnts.splitlines()
		        bannerPath = bannerList[0].split(":")[0]
		    except IndexError:
			bannerPath = '/etc/dconf/db/gdm.d/00-upstream-settings'

		with open(bannerPath, 'r') as bannerFile:
		    bannerFlag = False
		    bannerString = ""
		    for bannerStatusline in bannerFile:
		        if "banner-message-enable" in bannerStatusline:
			    continue
			elif re.search('^\[org/gnome/login-screen]\s', bannerStatusline, re.M|re.I):
			    bannerFlag = True
			    bannerString += "[org/gnome/login-screen]\nbanner-message-enable=true \n"
			else:
			    bannerString += bannerStatusline
		    if not bannerFlag:
			bannerString += "[org/gnome/login-screen]\nbanner-message-enable=true\n"

		fout = None
		fout = open(bannerPath, 'wt')
		if fout != None:
		    fout.write(bannerString)
		    fout.close()

		logging("Updating the dconf database")
		runOnShell("dconf update")
	elif (OsName.lower() == "redhat" or OsName.lower() == "centos") and OsVersion >= (7,0):
	    runOnShell('sudo -u gdm dbus-launch gsettings set org.gnome.login-screen banner-message-enable true')
	else:
	    runOnShell('gconftool-2 --direct --config-source xml:readwrite:/etc/gconf/gconf.xml.mandatory --type bool --set /apps/gdm/simple-greeter/banner_message_enable true')

	logging("Please reboot the system to complete the process of Gnome desktop setting.")

def checkRule38689():
	logging("Checking if the system is GUI based system.")
	if OsName.lower() == "ubuntu":
		if not CheckPackage('ubuntu-desktop') or not CheckPackage('xorg'):
			logging("Since this system is not a GUI based system, this rule is not applicable.")
			return True
		logging ("Checking which display manager is in usage.")
		displayManager = runOnShell('cat /etc/X11/default-display-manager')
		if "gdm" in displayManager:
			screenBlock = True
			statusFlag = False
			textFlag = False
			bannerList = runOnShell("egrep -hr  'banner-message-enable|banner-message-text|disable-user-list|\[org/gnome/login-screen]' /etc/dconf/db/gdm.d/*").splitlines()
			for bannerElemnt in bannerList:
				matchObject = re.match(r'.*(\[.*\])', bannerElemnt)
				if matchObject != None:
					if tokenMatchIC("[org/gnome/login-screen]", matchObject.group(1)):
						screenBlock = True
				if screenBlock:
					try:
						if isL(bannerElemnt) and "banner-message-text" in bannerElemnt:
							bannerText = bannerElemnt.split('"')[1]
							# If the text exist without space like ""
							bannerText = re.sub('', ' ', bannerText)
							if not bannerText.isspace():
								textFlag = True
					except IndexError:
						logging("The login warning banner text is not properly configured.")
						return False
					if isL(bannerElemnt) and tokenMatchIC("banner-message-enable=true", re.sub(' +', '', bannerElemnt)):
						statusFlag = True
					if isL(bannerElemnt) and tokenMatchIC("disable-user-list=true", re.sub(' +', '', bannerElemnt)):
						logging ("The 'disable-user-list' flag is set to 'true' which will prevent the user list \
while logging into the system. If 'disable-user-list' flag is set to 'true', banner message can not be allowed. Please fix it manually.")
						return None
			if textFlag:
				if not statusFlag:
					logging ("The banner status is not configured. Please remediate the rule to configure \
the banner status.")
					return None
				logging ("The login warning banner text is properly configured.")
				return True
			logging("The login warning banner text is not properly configured.")
			return False

		elif "lightdm" in displayManager:
			if os.path.exists('/etc/lightdm/lightdm.conf'):
				logging("Checking if login warning banner is configured.")
				bannerString = 'greeter-setup-script=/usr/bin/zenity --info --text '
				bannerMessage = runOnShell('grep '+ "'" + bannerString + "'" +' /etc/lightdm/lightdm.conf | grep -v "^#"')
				flag = False
				with open("/etc/lightdm/lightdm.conf", "r") as file_content:
					for line in file_content:
						match_obj = re.match(r'.*(\[.*\])', line)
						if match_obj != None:
							if tokenMatchIC("[SeatDefaults]", match_obj.group(1)):
								flag = True
						if flag and bannerString in line and isL(line):
							try:
								bannerText = bannerMessage.split('"')[1]
								# If the text exist without space like ""
								bannerText = re.sub('', ' ', bannerText)
								if not bannerText.isspace():
									logging ("The login warning banner is properly configured.")
									return True
							except IndexError:
								logging ("The login warning banner is not properly configured.")
								return False
					logging ("The login warning banner is not properly configured.")
					return False
			logging("The default display manager \'lightdm\' configuration file does not exist.")
			return False
	else:
		if not os.path.exists('/usr/bin/gconftool-2'):
			logging("Since this system is not a GUI based system, this rule is not applicable.")
			return True

		logging("Checking if the login warning banner text is properly set.")
		if (OsName.lower() == "redhat" or OsName.lower() == "centos") and OsVersion >= (7,0):
			bannerMessage = runOnShell("sudo -u gdm gsettings get org.gnome.login-screen banner-message-text")
		else:
			bannerMessage = runOnShell("gconftool-2 --get /apps/gdm/simple-greeter/banner_message_text")

		bannerMessage = re.sub(' +','',bannerMessage).strip("'")
		if not bannerMessage.isspace():
			logging ("The login warning banner is properly configured.")
			return True
		logging ("The login warning banner is not properly configured.")
		return False


def fixRule38689():
	loginBanner = " \"I've read & consent to terms in IS user agreem't.\""
	if OsName.lower() == "ubuntu":
		loginBannerLightdm = " \"I've read &amp; consent to terms in IS user agreem't.\""
		displayManager = runOnShell('cat /etc/X11/default-display-manager')
		if "gdm" in displayManager:
			bannerElemnts = runOnShell("egrep -r \'banner-message-enable|\[org/gnome/login-screen]\' /etc/dconf/db/gdm.d/*")
			if bannerElemnts == "":
				bannerPath = '/etc/dconf/db/gdm.d/00-upstream-settings'
			else:
				try:
					bannerList = bannerElemnts.splitlines()
					bannerPath = bannerList[0].split(":")[0]
				except:
					bannerPath = '/etc/dconf/db/gdm.d/00-upstream-settings'

			with open(bannerPath, 'r') as bannerFile:
				bannerFlag = False
				bannerString = ""
				loginscreenBlock = False
				for bannerTextLine in bannerFile:
					if "banner-message-text" in bannerTextLine:
						continue
					elif re.search('^\[org/gnome/login-screen]\s', bannerTextLine, re.M|re.I):
						bannerFlag = True
						bannerString += "[org/gnome/login-screen]\nbanner-message-text=" + loginBanner +"\n"
					else:
						bannerString += bannerTextLine
				if not bannerFlag:
					bannerString += "[org/gnome/login-screen]\nbanner-message-text="+ loginBanner +"\n"

			fout = None
			fout = open(bannerPath, 'wt')
			if fout != None:
				fout.write(bannerString)
				fout.close()
			logging("Updating the dconf database")
			runOnShell("dconf update")

		elif "lightdm" in displayManager:
			if not os.path.exists('/etc/lightdm/lightdm.conf'):
				os.chdir("/usr/share/doc/lightdm/")
				runOnShell("gunzip lightdm.conf.gz")
				runOnShell("cp lightdm.conf /etc/lightdm/")
			if os.path.exists('/etc/lightdm/lightdm.conf'):
				bannerString = 'greeter-setup-script=/usr/bin/zenity --info --text'
				fileString = ""
				bannerFlag = False
				with open("/etc/lightdm/lightdm.conf", "r") as file_content:
					for line in file_content:
						if "greeter-setup-script=" in line:
							continue
						elif re.search('^\[SeatDefaults\]\s',line,re.M|re.I):
							bannerFlag = True
							logging ("Setting the text shown by the GNOME Display Manager in the login screen.")
							fileString += "[SeatDefaults]\n" + bannerString + loginBannerLightdm + "\n"
						else:
							fileString += line
					if not bannerFlag:
						fileString += "[SeatDefaults]\n" + bannerString + loginBannerLightdm + "\n"
				fout = None
				fout = open('/etc/lightdm/lightdm.conf', 'wt')
				if fout != None:
					fout.write(fileString)
					fout.close()
	elif (OsName.lower() == "redhat" or OsName.lower() == "centos") and OsVersion >= (7,0):
		command = "sudo -u gdm dbus-launch gsettings set org.gnome.login-screen  banner-message-text" + loginBanner
		logging ("Setting the text shown by the GNOME Display Manager in the login screen.")
		runOnShell(command)
	else:
		command = "gconftool-2 --direct --config-source xml:readwrite:/etc/gconf/gconf.xml.mandatory --type string --set /apps/gdm/simple-greeter/banner_message_text" + loginBanner
		logging ("Setting the text shown by the GNOME Display Manager in the login screen.")
		runOnShell(command)

	logging("Please reboot the system to complete the process of Gnome desktop setting.")


def checkRule38690():
	if not os.path.exists ("/etc/login.defs"):
	    logging ("Since user account login configuration file is not available, need to execute it as manually.")
	    return None

	#If UID_MIN value is not available, considering default values
	UID_MAX_VAL = 60000
	if (OsName.lower() == "ubuntu" or (OsName.lower() == "centos" and OsVersion >= (7,0)) or (OsName.lower() == "redhat" and OsVersion >= (7,0))):
	    UID_MIN_VAL = 1000
	else: #For CentsOS(6.x), Redhat(6.x), and Amazon(2015, 2013)
	    UID_MIN_VAL = 500

	#Opening and splitting this file to find UID_MIN and UID_MAX values
	user_login_file = open("/etc/login.defs").readlines()
	#To find UID_MIN and UID_MAX values in /etc/login.defs file
	UIDList = filter(lambda ele: re.search(r'.*\s*(\bUID_MIN\b)\s*', ele) or re.search(r'.*\s*(\bUID_MAX\b)\s*', ele), user_login_file)
	for uidValue in UIDList:
	    try:
		uidValue = uidValue.strip()
		uidValue = re.sub(r"\s+", " ", uidValue)
		if "UID_MIN" in uidValue:
		    uidValue = uidValue.split(' ')[1]
		    UID_MIN_VAL = int(uidValue)
		elif "UID_MAX" in uidValue:
		    uidValue = uidValue.split(' ')[1]
		    UID_MAX_VAL = int(uidValue)
		else:
		    pass
	    except:
		pass

	#The below list contains all user accounts whose account's expiry is "never"
	neverList = []
	#The below list contains all user accounts whose Lastpasswordchage is "password must be changed"
	manualList = []

	logging ("Finding all emergency user accounts in the system.")
	#To find the available users except root user
	user_accounts_string = runOnShell("awk -F'[/ : ]' '{if ($3 >= " + str(UID_MIN_VAL) + " && $3 <= " + str(UID_MAX_VAL) +") print $1}' /etc/passwd")
        user_accounts_string = user_accounts_string.translate(string.maketrans("\n\t\r", "   "))
        list_of_user_accounts = filter(lambda elem: elem != "", user_accounts_string.split(" "))
	logging ("Checking user accounts expiration date.")
	for user_account in list_of_user_accounts:
                if user_account == username:
                    logging("> Ignoring check for Raxak Protect username " + user_account)
                    continue

		res = runOnShell('chage -l ' + user_account)
		if res != '':
			lis = res.split('\n')	
			for element in lis[:-1]:
				if "Last password change" in element:
				    account_lastpwdchange_value = element.split(':')[1]
        			    account_lastpwdchange_value = account_lastpwdchange_value.translate(string.maketrans("\n\t\r", "   ")).strip()
				elif 'Account expires' in element:
				    account_expire_value = element.split(':')[1]
        			    account_expire_value = account_expire_value.translate(string.maketrans("\n\t\r", "   ")).strip()
				    break
			
		#We are trying to modify the expiry date to the users whose account expire is "never"
		if "never" == account_expire_value:
		    neverList.append(user_account)

		if "password must be changed" == account_lastpwdchange_value:
		    manualList.append(user_account)

	#Removing manual user entries from the never list
	for manualUser in manualList:
	    if manualUser in neverList:
		neverList.remove(manualUser)

	if len(manualList) > 0:
	    if len(neverList) > 0:
	        logging ("Following are the list of emergency user accounts have no expiration date set:")
	        for neverUser in neverList:
		    logging (str(neverUser) + "\n")
	    logging ("Since following are the list of emergency user accounts whose 'password change' must be changed, \
need to fix as manually:")
	    for manualUser in manualList:
		logging (str(manualUser) + "\n")
	    return None
	elif len(neverList) > 0:
	    logging ("Following user accounts have no expiration date set. Please set the expiry date manually as per your requirement.")
	    for neverUser in neverList:
		logging (str(neverUser) + "\n")
	    return None
	else:
	    logging ("All emergency user accounts expiration date is set.")
	    return True

def fixRule38690():
	logging ("All user accounts expiry date should not be set automatically. It should be fixed as manually.")
	return None

	logging ("Opening /etc/login.defs file to find UID_MIN and UID_MAX values.")

	UID_MAX_VAL = 60000
	#If UID_MIN and UID_MAX values are not available, considering default values
	if (OsName.lower() == "ubuntu" or (OsName.lower() == "centos" and OsVersion >= (7,0)) or (OsName.lower() == "redhat" and OsVersion >= (7,0))):
	    UID_MIN_VAL = 1000
	else: #For CentsOS(6.x), Redhat(6.x), and Amazon(2015, 2013)
	    UID_MIN_VAL = 500

	#Opening and splitting this file to find UID_MIN and UID_MAX values
	user_login_file = open("/etc/login.defs").readlines()
	#To find UID_MIN and UID_MAX values in /etc/login.defs file
	UIDList = filter(lambda ele: re.search(r'.*\s*(\bUID_MIN\b)\s*', ele) or re.search(r'.*\s*(\bUID_MAX\b)\s*', ele), user_login_file)
	for uidValue in UIDList:
	    try:
		uidValue = uidValue.strip()
		uidValue = re.sub(r"\s+", " ", uidValue)
		if "UID_MIN" in uidValue:
		    uidValue = uidValue.split(' ')[1]
		    UID_MIN_VAL = int(uidValue)
		elif "UID_MAX" in uidValue:
		    uidValue = uidValue.split(' ')[1]
		    UID_MAX_VAL = int(uidValue)
		else:
		    pass
	    except:
		pass

	UID_MIN_VAL = str(UID_MIN_VAL)
	UID_MAX_VAL = str(UID_MAX_VAL)

	logging ("Finding all emergency user accounts in the machine.")
	#To find the available users except root user
	user_accounts_string = runOnShell("awk -F'[/ : ]' '{if ($3 >= " + UID_MIN_VAL + " && $3 <= " + UID_MAX_VAL +") print $1}' /etc/passwd")
        user_accounts_string = user_accounts_string.translate(string.maketrans("\n\t\r", "   "))
        list_of_user_accounts = filter(lambda elem: elem != "", user_accounts_string.split(" "))

	lastPasswordChangeDate = ""
	logging ("Checking all user's account expiry date.")
	for user_account in list_of_user_accounts:
                if user_account == username:
                    logging("> Ignoring check for Raxak Protect username " + user_account)
                    continue

		res = runOnShell('chage -l '+user_account)
		if res != '':
			lis = res.split('\n')
			for element in lis:
				if 'Account expires' in element:
				    account_expire_value = element.split(':')[1]
				    account_expire_value = account_expire_value.translate(string.maketrans("\n\t\r", "   ")).strip()
				    if "never" != account_expire_value:
					break
				elif "Last password change" in element:
					lastPasswordChangeDate = element.split(':')[1]
				elif "Password expires" in element:
					passwordExpires = element.split(':')[1]
				elif "Password inactive" in element:
					passwordInactive = element.split(':')[1]
				else:
					pass
			
		#We are trying to modify the expiry date to the users whose account expire is "never"
		if "never" == account_expire_value:
			changeAccountExpiryDate = ChangeUserAccountExpiryDate (user_account, lastPasswordChangeDate, passwordExpires, passwordInactive)
			if changeAccountExpiryDate == None:
			    return None
			logging ("Changing user {0}'s expiry date to valid expiry date".format(user_account))
			runOnShell('chage -E ' + str(changeAccountExpiryDate) + " " + user_account)

def checkRule38691():
	if OsName.lower() == "ubuntu":
		logging("Checking if bluetooth service package is installed.")
		chk_installation = runOnShell("dpkg --list |grep bluez | grep 'Bluetooth tools and daemons' ")
    	        chk_installation = chk_installation.translate(string.maketrans("\n\t\r", "   ")).strip()
		if chk_installation == "":
			logging("Bluetooth service is not installed.")
			return True
		
		logging("service and init.d are used for start/stop/restart/reload the service, hence checking the status of service using both commands.")	
		service_bluetooth_flag = False
		init_bluetooth_flag = False
        	service_status = runOnShell("service bluetooth status").translate(string.maketrans("\n\t\r", "   ")).strip()
                if tokenMatchIC("bluetooth stop/waiting", service_status):
			service_bluetooth_flag = True

		init_bluetooth_status = runOnShell('/etc/init.d/bluetooth status').translate(string.maketrans("\n\t\r", "   "))
		if "*bluetoothisnotrunning" in init_bluetooth_status.replace(" ",''):
			init_bluetooth_flag = True

		if init_bluetooth_flag and service_bluetooth_flag:
			service_at_level = runOnShell('sysv-rc-conf --list bluetooth')
    	        	service_at_level = service_at_level.translate(string.maketrans("\n\t\r", "   ")).strip()
			if tokenMatchIC("bluetooth 0:off 1:off 2:off 3:off 4:off 5:off 6:off S:off", service_at_level):
				return True
	else:
		logging("Checking if bluetooth service package is installed.")
		check_install = runOnShell("rpm -q bluez").translate(string.maketrans("\n\t\r", "   ")).strip()
		if "not installed" in check_install:
			logging("Bluetooth service is not installed.")
			return True

		if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
			service_status = runOnShell('systemctl is-active bluetooth.service').replace('\n','')
			if service_status in ["inactive", "unknown","failed"]:
				return True
			service_at_runlevel = runOnShell("systemctl is-enabled bluetooth.service").replace('\n','')
			if service_status == "active" or service_at_runlevel == "enabled":
				return False

		else:
	        	service_at_level = runOnShell("chkconfig --list bluetooth")
	    	        service_at_level = service_at_level.translate(string.maketrans("\n\t\r", "   ")).strip()
	 		service_at_level = service_at_level.replace("\t",'').replace(" ",'')
			if tokenMatchIC("bluetooth0:off1:off2:off3:off4:off5:off6:off", service_at_level):
				return True

	return False

def fixRule38691():
	if (( OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		runOnShell("systemctl stop bluetooth.service")
		runOnShell("systemctl disable bluetooth.service")
	elif OsName.lower() == "ubuntu":
		res = runOnShell("service bluetooth status")
    	        res = res.translate(string.maketrans("\n\t\r", "   ")).strip()
		if not "bluetooth stop/waiting" in res:
			runOnShell("service bluetooth stop")

		init_res = runOnShell("/etc/init.d/bluetooth status")
    	        init_res = init_res.translate(string.maketrans("\n\t\r", "   ")).strip()
		if "not" not in init_res:
			runOnShell("/etc/init.d/bluetooth stop")

		runOnShell("sysv-rc-conf --level 0123456S bluetooth off")
	else:
		runOnShell("service bluetooth stop")
		runOnShell("chkconfig --level 0123456 bluetooth off")
		

def checkRule38692():
	# greping INACTIVE parameter.
	logging("Checking the number of days to inactive the account, the DoD requirement is within 35 days.")
	check_inactive_days = runOnShell('grep -w "INACTIVE" /etc/default/useradd | grep -v "^#"')
	check_inactive_days = check_inactive_days.translate(string.maketrans("\n\t\r", "   "))
	if re.match(r'(\bINACTIVE=\w*\b)', check_inactive_days):
		inactiveValue = check_inactive_days.split("=")
		try:
			# check wether INACTIVE parameter is less than 35 and more than 0
			if len(inactiveValue) == 2 and int(inactiveValue[1]) >= 0 and int(inactiveValue[1]) <= 35:
				if int(inactiveValue[1]) == 35:
					logging("Days to inactive the account is set to 35.")
					return True
				logging('Days to inactive the account is set to '+ inactiveValue[1] +' but setting the timeout too low incurs support costs and also has the potential to impact availability of the system to legitimate users.')
				return True
		except:
			logging("There is some configuration error in useradd configuration file.")
			return False
	# Check is there any sysntax error in the INACTIVE parameter.(space after = or before =)
	elif re.match(r'.*\s*(\bINACTIVE\s*=\s*\b)\s*', check_inactive_days):
		logging('There is some syntax error in the line ' + check_inactive_days + '.')
		return False
	logging("Days to inactive the account is not set correctly. Please configure the system to inactive account within 35 Days as suggested by disa rule.")
	return False
            
def fixRule38692():
	logging("Configuring the system to inactive the unused account within 35 Days as suggested by disa rule.")
	lastLine = ""
	file_string = ""
	flag = False
	fileSplit = open("/etc/default/useradd").readlines()
	for line in fileSplit:
	      if isL(line) and "INACTIVE" in line:
	          if flag == False:
	              if not tokenMatch("# Cloud Raxak updated next line",lastLine):
	                   file_string += "# Cloud Raxak updated next line\n"
	              file_string += "INACTIVE=35\n"
	              flag = True
	      else:
	            file_string += line
	            lastLine=line
	if not(flag):
	      file_string += "# Cloud Raxak updated next line\n"
	      file_string += "INACTIVE=35\n"
	fout = None
	try:
	      fout = open("/etc/default/useradd", 'w')
	      fout.write(file_string)
	finally:
	     if fout is not None:
	            fout.close()

def checkRule38693():
	qualityCheck = False # flag to check if maxrepeat exist in pwquality.conf
        grepModule = "pam_cracklib.so"
        if OsName.lower() == "ubuntu":
	    if not CheckPackage("libpam-cracklib"):
		return False
            filePath = "/etc/pam.d/common-password"
        else:
            filePath = "/etc/pam.d/system-auth"
            if OsVersion >= (7,0):
                grepModule = 'pam_pwquality.so'
	        logging("Checking for consecutive repeating characters setting for a password quality configuration file.")
		# Checking the maxrepeat in the /etc/security/pwquality.conf file
		checkPwQuality = runOnShell('grep -w maxrepeat /etc/security/pwquality.conf | grep -v "^#"')
		checkDigit = re.match(r'.*\s*(\bmaxrepeat\s*=\s*\d\b)\s*', checkPwQuality)
	        if checkDigit != None:
	            parameter = checkDigit.group(1)
	            actualParamDigit,paramValueDigit =  parameter.split("=")
	            actualParamDigit = actualParamDigit.replace(" ","")
	            paramValueDigit = paramValueDigit.replace(" ","")
	            qualityCheck = True
	logging("Checking the consecutive repeating characters setting for a password, the DoD recommends password must contain no more than three consecutive repeating characters.")
	checkResult = runOnShell('grep -w '+ grepModule + " " + filePath +' | grep -w requisite | grep -v "^#"')
	checkResult = checkResult.translate(string.maketrans("\n\t\r", "   ")).strip()
	matchObj = re.match(r'.*\s*(\bmaxrepeat=\d\b)\s*', checkResult)
	if matchObj:
	    parameter = matchObj.group(1)
	    actualParam,paramValue =  parameter.split("=")
	    if paramValue != "":
		try:
		    validValue = False
		    if qualityCheck:
			if (paramValue in ['1', '2', '3']) and (paramValueDigit in ['1', '2', '3']) and (int(paramValueDigit) <= int(paramValue)) :
				validValue = True
			elif (paramValue in ['1', '2', '3']) and (paramValueDigit not in ['1', '2', '3']):
				validValue = True
		    else:
			if paramValue in ['1', '2', '3']:
				validValue = True
		    if validValue:
			logging("Configuration to avoid consecutive repeating characters for a password is correctly specified.")
			return True
		except:
		    logging("Configuration to avoid consecutive repeating characters for a password is not correctly specified.")
		    return False
	logging("Consecutive repeating characters settings for a password is not configured correctly.")
	return False

def fixRule38693(max_value=3):
	paramValue = 3
	qualityCheck = False # flag to check if maxrepeat exist in pwquality.conf
	grepModule = 'pam_cracklib.so'
	if OsName.lower() == "ubuntu":
	    if not CheckPackage("libpam-cracklib"):
                InstallPackage("libpam-cracklib")
	    filePath = "/etc/pam.d/common-password"
	else:
	    filePath = "/etc/pam.d/system-auth"
            if OsVersion >= (7,0):
                grepModule = 'pam_pwquality.so'
		checkPwQuality = runOnShell('grep -w maxrepeat /etc/security/pwquality.conf | grep -v "^#"')
		checkDigit = re.match(r'.*\s*(\bmaxrepeat\s*=\s*\d\b)\s*', checkPwQuality)
		if checkDigit != None:
		    parameter = checkDigit.group(1)
		    actualParamDigit,paramValueDigit =  parameter.split("=")
		    actualParamDigit = actualParamDigit.replace(" ","")
		    paramValueDigit = paramValueDigit.replace(" ","")
		    qualityCheck = True
	checkResult = runOnShell('grep -w '+ grepModule + " " + filePath +' | grep -w requisite | grep -v "^#"')
	with open(filePath, "r") as file_content:
            fileString = ""
	    lastLine = ""
            logging("Updating the consecutive repeating characters settings requirement in a password, the DoD recommends password must contain no more than three consecutive repeating characters.")
            for line in file_content:
	        updateValue = False
		moduleSearchObj = re.search('^password\s*requisite\s*'+ grepModule, line)
		if moduleSearchObj != None and checkResult != "":
			checkValue = False
			if isL(line) and "maxrepeat" in line:
			    line = line.translate(string.maketrans("\n\t\r", "   ")).strip()
                            matchObjs = re.match(r'.*\s*(\bmaxrepeat=\d\b)\s*', checkResult)
			    resultTranslate = checkResult.translate(string.maketrans("\n\t\r", "   "))
			    if tokenMatchIC("maxrepeat", resultTranslate) or tokenMatchIC("maxrepeat=", resultTranslate):
				checkValue = True
			    elif matchObjs != None:
				parameter = matchObjs.group(1)
				actualParam,paramValue =  parameter.split("=")
				try:
				    if qualityCheck:
					if (int(paramValue) != max_value):
						checkValue = True
				    elif  (int(paramValue) != max_value) or (paramValue == ""):
						checkValue = True
				    else:
					pass
				except:
				    checkValue = True
			    else:
				updateValue = True
			else:
			    updateValue = True
			if qualityCheck:
			    if int(paramValue) != int(paramValueDigit):
				if (int(paramValueDigit) <  max_value) and (int(paramValueDigit) > 0):
					newValue = paramValueDigit
				else:
					newValue = max_value
			    else:
				newValue = max_value
			else:
				newValue = max_value
			if checkValue:
			    start = line.index("maxrepeat")
			    new = line[start:]
			    try:
			        end = new.index(" ")
			        line = line[0:start] + "maxrepeat="+str(newValue) + line[start+end:]
			    except:
			        end = 10
			        line = line[0:start] + "maxrepeat="+str(newValue) + line[start+end:len(line[start:])]

			if updateValue:
			    line = line.translate(string.maketrans("\n", " ")).strip()
			    line = line+' maxrepeat='+str(newValue)
			if "Cloud Raxak updated next line" not in lastLine:
                            fileString += "# Cloud Raxak updated next line\n"
			fileString += line + '\n'
		elif checkResult == "":
		    if OsName.lower() == "ubuntu":
		        if re.search('^password\s*\[success\=1\sdefault=ignore\]\s*pam_unix.so', line):
                            if "Cloud Raxak updated next line" not in lastLine:
                                fileString += "# Cloud Raxak updated next line\n"
		            fileString += "password       requisite       pam_cracklib.so maxrepeat=-1\n"
	    	    else:
		        if re.search('^password\s*sufficient\s*pam_unix.so',line):
                            if "Cloud Raxak updated next line" not in lastLine:
                                fileString += "# Cloud Raxak updated next line\n"
			    if qualityCheck:
				if paramValueDigit in ['1', '2']:
					fileString += "password     requisite     "+ grepModule + " maxrepeat="+ paramValueDigit +"\n"
				else:
					fileString += "password     requisite     "+ grepModule + " maxrepeat=3\n"
			    else:
				fileString += "password     requisite     "+ grepModule + " maxrepeat=3\n"
		    fileString += line
		else:
		    fileString += line
		lastLine = line
	fout = None
        fout = open(filePath, 'wt')
        if fout != None:
            fout.write(fileString)
            fout.close()

def checkRule38694():
	# greping INACTIVE parameter.
	logging("Checking the number of days to inactive the account, the DoD requirement is within 35 days.")
	check_inactive_days = runOnShell('grep -w "INACTIVE" /etc/default/useradd | grep -v "^#"')
	check_inactive_days = check_inactive_days.translate(string.maketrans("\n\t\r", "   "))
	if re.match(r'(\bINACTIVE=\w*\b)', check_inactive_days):
		inactiveValue = check_inactive_days.split("=")
		try:
			# check wether INACTIVE parameter is less than 35 and more than 0
			if len(inactiveValue) == 2 and int(inactiveValue[1]) >= 0 and int(inactiveValue[1]) <= 35:
				if int(inactiveValue[1]) == 35:
					logging("Days to inactive the account is set to 35.")
					return True
				logging('Days to inactive the account is set to '+ inactiveValue[1] +' but setting the timeout too low incurs support costs and also has the potential to impact availability of the system to legitimate users.')
				return True
		except:
			logging("There is some configuration error in useradd configuration file.")
			return False
	# Check is there any sysntax error in the INACTIVE parameter.(space after = or before =)
	elif re.match(r'.*\s*(\bINACTIVE\s*=\s*\b)\s*', check_inactive_days):
		logging('There is some syntax error in the line ' + check_inactive_days + '.')
		return False
	logging("Days to inactive the account is not set correctly. Please configure the system to inactive account within 35 Days as suggested by disa rule.")
	return False

def fixRule38694():
	logging("Configuring the system to inactive the unused account within 35 Days as suggested by disa rule.")
	lastLine = ""
	file_string = ""
	flag = False
	fileSplit = open("/etc/default/useradd").readlines()
	for line in fileSplit:
	      if isL(line) and "INACTIVE" in line:
	          if flag == False:
	              if not tokenMatch("# Cloud Raxak updated next line", lastLine):
	                   file_string += "# Cloud Raxak updated next line\n"
	              file_string += "INACTIVE=35\n"
	              flag = True
	      else:
	            file_string += line
	            lastLine=line
	if not(flag):
	      file_string += "# Cloud Raxak updated next line\n"
	      file_string += "INACTIVE=35\n"
	fout = None
	try:
	      fout = open("/etc/default/useradd", 'w')
	      fout.write(file_string)
	finally:
	     if fout is not None:
	            fout.close()

def checkRule38695():
    #To check whether aide service is installed or not
    if OsName.lower() == "ubuntu":
        aideConfFilePath = "/etc/aide/aide.conf"
        cronPackage = "cron"
    else:
        aideConfFilePath = "/etc/aide.conf"
        cronPackage = "cronie"

    if not CheckPackage(cronPackage):
        logging("Cron is used to check for unauthorized file, unauthorized modification to authorized system libraries or \
binaries on the system.")
        return False

    logging("Checking aide package entry in /etc/crontab and /etc/cron.*/* files.")
    res = runOnShell('grep "aide -c ' + aideConfFilePath  + '" /etc/crontab /etc/cron.*/* | grep -w nice | grep -v ":#"')
    if res:
        logging("A file integrity tool is available to check for unauthorized file, unauthorized modification \
to authorized system libraries or binaries.")
        return True
    else:
        logging("A file integrity tool is not available to check for unauthorized file, unauthorized modification \
to authorized system libraries or binaries.")
        return False

def fixRule38695():
    aideBinFilePath = "/usr/sbin/aide"
    logging("Checking if cron is installed on the system.")
    if not os.path.exists("/etc/crontab"):
        if not InstallPackage("cronie"):
            return None

    aideConfFilePath = "/etc/aide.conf"
    if (OsName.lower() == "redhat" or OsName.lower() == "centos") and OsVersion < (7,0):
        niceBinFilePath = "/bin/nice"
    else:
        if OsName.lower() == "ubuntu":
            aideBinFilePath = "/usr/bin/aide"
            aideConfFilePath = "/etc/aide/aide.conf"
        niceBinFilePath = "/usr/bin/nice"

    cronFlag = False # To add aide entry in cron file
    cronEntry = "" # Contains the content of /etc/fstab file
    cronLogMessage = "05 4 * * * root " + niceBinFilePath + " -n +10 " + aideBinFilePath + " -c " + aideConfFilePath + " --check\n"

    logging("Adding aide package as part of cron jobs.")
    crontabFileLines = open("/etc/crontab").readlines()
    for cronLine in crontabFileLines:
        if (aideConfFilePath in cronLine) or (aideBinFilePath in cronLine):
            if not cronFlag:
                if "Cloud Raxak" not in lastLine:
                    cronEntry += "# Cloud Raxak updated next line\n"
                cronEntry += cronLogMessage
                cronFlag = True
        else:
            cronEntry += cronLine
            lastLine = cronEntry

    if not cronFlag:
        if "Cloud Raxak" not in lastLine:
            cronEntry += "# Cloud Raxak updated next line\n"
        cronEntry += cronLogMessage

    fout = open("/etc/crontab", "wt")
    if fout != None:
        fout.write(cronEntry)
        fout.close()

def checkRule38696():
    #To check whether aide service is installed or not
    if OsName.lower() == "ubuntu":
        aideConfFilePath = "/etc/aide/aide.conf"
        cronPackage = "cron"
    else:
        aideConfFilePath = "/etc/aide.conf"
        cronPackage = "cronie"

    if not CheckPackage(cronPackage):
        logging("Cron is used to detect the addition of unauthorized components/devices into the operating system.")
        return False

    logging("Checking aide package entry in /etc/crontab and /etc/cron.*/* files.")
    res = runOnShell('grep "aide -c ' + aideConfFilePath  + '" /etc/crontab /etc/cron.*/* | grep -w nice | grep -v ":#"')
    if res:
        logging("The operating system is configured with automated mechanisms to detect the addition of \
unauthorized components/devices into the operating system.")
        return True
    else:
        logging("The operating system is not configured with automated mechanisms to detect the addition of \
unauthorized components/devices into the operating system.")
        return False

def fixRule38696():
    aideBinFilePath = "/usr/sbin/aide"
    logging("Checking if cron is installed on the system.")
    if not os.path.exists("/etc/crontab"):
        if not InstallPackage("cronie"):
            return None

    aideConfFilePath = "/etc/aide.conf"
    if (OsName.lower() == "redhat" or OsName.lower() == "centos") and OsVersion < (7,0):
        niceBinFilePath = "/bin/nice"
    else:
        if OsName.lower() == "ubuntu":
            aideBinFilePath = "/usr/bin/aide"
            aideConfFilePath = "/etc/aide/aide.conf"
        niceBinFilePath = "/usr/bin/nice"

    cronFlag = False # To add aide entry in cron file
    cronEntry = "" # Contains the content of /etc/fstab file
    cronLogMessage = "05 4 * * * root " + niceBinFilePath + " -n +10 " + aideBinFilePath + " -c " + aideConfFilePath + " --check\n"

    logging("Adding aide package as part of cron jobs.")
    crontabFileLines = open("/etc/crontab").readlines()
    for cronLine in crontabFileLines:
        if (aideConfFilePath in cronLine) or (aideBinFilePath in cronLine):
            if not cronFlag:
                if "Cloud Raxak" not in lastLine:
                    cronEntry += "# Cloud Raxak updated next line\n"
                cronEntry += cronLogMessage
                cronFlag = True
        else:
            cronEntry += cronLine
            lastLine = cronEntry

    if not cronFlag:
        if "Cloud Raxak" not in lastLine:
            cronEntry += "# Cloud Raxak updated next line\n"
        cronEntry += cronLogMessage

    fout = open("/etc/crontab", "wt")
    if fout != None:
        fout.write(cronEntry)
        fout.close()

def checkRule38697():
	logging("Checking the world-writable directories that lack the sticky bit.")
        res = runOnShell("find / -type d \( -perm -0002 -a ! -perm -1000 \) 2>/dev/null")
        if res == "":
	    logging("There are no world-writable directories that lack the sticky bit.")
	    return True
	logging("There are world-writable directories that lack the sticky bit.")
	return False

def fixRule38697():
	logging("Changing the sticky bit on a world-writable directory.\
After changing that, only the owner of a given file may remove that file from the directory.")
	listOfFile = runOnShell("find / -type d \( -perm -0002 -a ! -perm -1000 \) 2>/dev/null").splitlines()
	for filePath in listOfFile:
	    runOnShell("chmod o+t "+filePath)

def checkRule38698():
    #To check whether aide service is installed or not
    if OsName.lower() == "ubuntu":
        aideConfFilePath = "/etc/aide/aide.conf"
        cronPackage = "cron"
    else:
        aideConfFilePath = "/etc/aide.conf"
        cronPackage = "cronie"

    if not CheckPackage(cronPackage):
        logging("Cron is used to detect the presence of unauthorized software on organizational information systems and \
notify designated organizational officials in accordance with the organization defined frequency.")
        return False

    logging("Checking aide package entry in /etc/crontab and /etc/cron.*/* files.")
    res = runOnShell('grep "aide -c ' + aideConfFilePath  + '" /etc/crontab /etc/cron.*/* | grep -w nice | grep -v ":#"')
    if res:
        logging("The operating system employs automated mechanisms to detect the presence of unauthorized software on organizational \
information systems and notify designated organizational officials in accordance with the organization defined frequency.")
        return True
    else:
        logging("The operating system does not employ automated mechanisms to detect the presence of unauthorized software on \
organizational information systems and notify designated organizational officials in accordance with the organization defined frequency.")
        return False

def fixRule38698():
    aideBinFilePath = "/usr/sbin/aide"
    logging("Checking if cron is installed on the system.")
    if not os.path.exists("/etc/crontab"):
        if not InstallPackage("cronie"):
            return None

    aideConfFilePath = "/etc/aide.conf"
    if (OsName.lower() == "redhat" or OsName.lower() == "centos") and OsVersion < (7,0):
        niceBinFilePath = "/bin/nice"
    else:
        if OsName.lower() == "ubuntu":
            aideBinFilePath = "/usr/bin/aide"
            aideConfFilePath = "/etc/aide/aide.conf"
        niceBinFilePath = "/usr/bin/nice"

    cronFlag = False # To add aide entry in cron file
    cronEntry = "" # Contains the content of /etc/fstab file
    cronLogMessage = "05 4 * * * root " + niceBinFilePath + " -n +10 " + aideBinFilePath + " -c " + aideConfFilePath + " --check\n"

    logging("Adding aide package as part of cron jobs.")
    crontabFileLines = open("/etc/crontab").readlines()
    for cronLine in crontabFileLines:
        if (aideConfFilePath in cronLine) or (aideBinFilePath in cronLine):
            if not cronFlag:
                if "Cloud Raxak" not in lastLine:
                    cronEntry += "# Cloud Raxak updated next line\n"
                cronEntry += cronLogMessage
                cronFlag = True
        else:
            cronEntry += cronLine
            lastLine = cronEntry

    if not cronFlag:
        if "Cloud Raxak" not in lastLine:
            cronEntry += "# Cloud Raxak updated next line\n"
        cronEntry += cronLogMessage

    fout = open("/etc/crontab", "wt")
    if fout != None:
        fout.write(cronEntry)
        fout.close()

def checkRule38699():
	systemAccountUID = uid_value
	systemAccountUID = int(uid_value)-1
	filteredRes = runOnShell("find / -perm -0002 -type d -uid +" + str(systemAccountUID) + " -print 2>>/dev/null").splitlines()
	#Checking if world-writable diretcory exists
	if filteredRes == "":
	        logging("There are no world-writable directories that are not owned by a system account.")
		return True
		
	count = 0
	for line in filteredRes:
	     if tokenMatchIC("No such file", line):
		   count = count + 1	

	#If all lines contains 'no such file or directory'	
	if count == len(filteredRes):
		logging("There are no world-writable directories that are not owned by a system account.")
	        return True
		
	logging("All the above world-writable directories should be owned by root or another system account. \
Allowing a user account to own a word-writable directory is undesirable. If you would like to change \
the owner of word-writable directories, run the rule as part of force remediation which will change the world-writable directories\
 ownership which are not owned by a system account to root.")
	return None


def fixRule38699():
	systemAccountUID = uid_value
	systemAccountUID = int(systemAccountUID)-1
	listOfDirectory = runOnShell("find / -perm -0002 -type d -uid +" + str(systemAccountUID) + " -print 2>>/dev/null").splitlines()
	for dirPath in listOfDirectory:
		if os.path.isdir(dirPath):
			runOnShell('chown root '+ dirPath)

def checkRule38700():
    #To check whether aide service is installed or not
    if OsName.lower() == "ubuntu":
        aideConfFilePath = "/etc/aide/aide.conf"
        cronPackage = "cron"
    else:
        aideConfFilePath = "/etc/aide.conf"
        cronPackage = "cronie"

    if not CheckPackage(cronPackage):
        logging("Cron provides a near real-time alert when any of the organization defined list of compromise or potential compromise \
indicators occurs on the system..")
        return False

    logging("Checking aide package entry in /etc/crontab and /etc/cron.*/* files.")
    res = runOnShell('grep "aide -c ' + aideConfFilePath  + '" /etc/crontab /etc/cron.*/* | grep -w nice | grep -v ":#"')
    if res:
        logging("The operating system provides a near real-time alert when any of the organization defined list of compromise \
or potential compromise indicators occurs.")
        return True
    else:
        logging("The operating system does not provide a near real-time alert when any of the organization defined list of compromise \
or potential compromise indicators occurs.")
        return False

def fixRule38700():
    aideBinFilePath = "/usr/sbin/aide"
    logging("Checking if cron is installed on the system.")
    if not os.path.exists("/etc/crontab"):
        if not InstallPackage("cronie"):
            return None

    aideConfFilePath = "/etc/aide.conf"
    if (OsName.lower() == "redhat" or OsName.lower() == "centos") and OsVersion < (7,0):
        niceBinFilePath = "/bin/nice"
    else:
        if OsName.lower() == "ubuntu":
            aideBinFilePath = "/usr/bin/aide"
            aideConfFilePath = "/etc/aide/aide.conf"
        niceBinFilePath = "/usr/bin/nice"

    cronFlag = False # To add aide entry in cron file
    cronEntry = "" # Contains the content of /etc/fstab file
    cronLogMessage = "05 4 * * * root " + niceBinFilePath + " -n +10 " + aideBinFilePath + " -c " + aideConfFilePath + " --check\n"

    logging("Adding aide package as part of cron jobs.")
    crontabFileLines = open("/etc/crontab").readlines()
    for cronLine in crontabFileLines:
        if (aideConfFilePath in cronLine) or (aideBinFilePath in cronLine):
            if not cronFlag:
                if "Cloud Raxak" not in lastLine:
                    cronEntry += "# Cloud Raxak updated next line\n"
                cronEntry += cronLogMessage
                cronFlag = True
        else:
            cronEntry += cronLine
            lastLine = cronEntry

    if not cronFlag:
        if "Cloud Raxak" not in lastLine:
            cronEntry += "# Cloud Raxak updated next line\n"
        cronEntry += cronLogMessage

    fout = open("/etc/crontab", "wt")
    if fout != None:
        fout.write(cronEntry)
        fout.close()

def checkRule38701():
	#ASG - Check file exists or not
	if not os.path.exists('/etc/xinetd.d/tftp'):
		logging("tftp service is not configured with xinetd. Hence, this rule is not applicable.")
		return True
	# Checking the servcie status and runlevels.
	if not checkServiceRunlevel ("xinetd"):
		return False
        logging("Checking if tftp is configured.")
	secureOption = runOnShell('grep -w server_args /etc/xinetd.d/tftp | grep -v "^#"')
	if secureOption == "":
		logging("The TFTP daemon is not configured properly as the tftp secure path is not defined. Please configure it manually.")
		return None
	# Split the line for Checking the option "-s" or "--secure"
	secureoptionList = secureOption.split("=")
	try:
		optionsList = secureoptionList[1].split()
	except IndexError:
		logging("The TFTP daemon is not configured properly as the parameter is not defined properly. Please configure it manually.")
		return None

	optionFlag = False
	pathFlag = False
	for option in optionsList:
		if OsName.lower() == "ubuntu":
			optionStatus = tokenMatch(option, "-s")
		else:
			optionStatus = tokenMatch(option, "-s") or tokenMatch(option, "--secure")

		if optionStatus:
			optionFlag = True
			indexofOption = optionsList.index(option)

		if os.path.exists(option):
			pathFlag = True
			indexofPath = optionsList.index(option)

	if not pathFlag:
		logging("The TFTP daemon is not configured properly, as there is no path define or \
the configure path is not present for tftp on the host file system. Hence configure it manually.")
		return None

	if optionFlag and (indexofOption < indexofPath):
		logging ("The TFTP daemon is in secure mode which provides access only to a single directory on the host file system.")
		return True

	logging ("The TFTP daemon is not in secure mode which provides access only to a single directory on the host file system.")
	return False


def fixRule38701():
	with open('/etc/xinetd.d/tftp', "r") as fileContent:
		fileString = ""
		for serverargsLine in fileContent:
			if "server_args" in serverargsLine:
				pathFlag = False
				serverargsLine = re.sub( '\n', ' ', serverargsLine)
				serverargsList = serverargsLine.split("=")
				try:
					optionsList = serverargsList[1].split()
				except IndexError:
					logging("The TFTP daemon is not configured properly, please configure it manually.")
					return None
				for indx in range(len(optionsList)):
					if "s" in optionsList[indx] or "secure" in optionsList[indx]:
						optionsList[indx] = ""
						serverargsList[1] = " ".join(optionsList)
					if os.path.exists(optionsList[indx]):
						pathFlag = True
				if pathFlag:
					serverargsList[1] = "-s " + serverargsList[1]
					serverargsLine = "= ".join(serverargsList)
					fileString += serverargsLine + '\n'
				else:
					fileString += serverargsLine
			else:
				fileString += serverargsLine
		fout = open('/etc/xinetd.d/tftp', "wt")
		if fout != None:
			logging("Configuring the tftp service to operate in secure mode which provides access only to a single directory on the host file system.")
			fout.write(fileString)
			fout.close()
	RunService("xinetd")

def checkRule38702():
        #By default
        if OsName.lower() == "ubuntu":
            #File path  for ubuntu
            configFile = "/etc/vsftpd.conf"
            service_status = "dpkg -s vsftpd"
        else:
            #File path for centOS
            configFile = "/etc/vsftpd/vsftpd.conf"
            service_status = "rpm -q vsftpd"
        #TODO:if listen=YES in vsftpd.conf it will run standalone mode if its "NO" it will run as xinetd service.
        #commenting below line as xinetd does not run vsftpd now.
        #To check vsftpd file from xinetd.
        #startupFile = runOnShell("grep vsftpd /etc/xinetd.d/*")
        #if startupFile and not("No such file or directory" in startupFile) and startupFile !="":
        #    configFile = runOnShell("grep server_args " + startupFile)
        #    if configFile:
        #        return True
        #check vsftpd by default path
        #Checking whether vsftpd is installed or not
        logging("Checking whether 'vsftpd' package is installed or not.")
        res = runOnShell(service_status)
        if not(("not installed" in res) or ("deinstall ok" in res)):
            logging("'vsftpd' package is installed in your system.")
            if os.path.exists(configFile):
                #grep xferlog_enable=YES inside config file
                logging("Checking whether 'vsftpd' is configured for logging or verbose mode.")
                ret = runOnShell('grep -e "xferlog_enable" -e "xferlog_std_format" -e "log_ftp_protocol" ' + configFile + '| grep -v "#"')
                transd_return = ret.translate(string.maketrans("\n\t\r", "   "))
                transd_return = transd_return.split(" ")
                transd_return_len = len(transd_return)
                flag1 = flag2 = flag3 = False
                if transd_return_len == 4:
                   for line in transd_return:
                       if isL(line) and ("xferlog_enable" in line or "xferlog_std_format" in line or "log_ftp_protocol" in line):
                           if re.match(r'.*\s*(\bxferlog_enable=YES\b)\s*', line) and len(line) == 18:
                                flag1 = True
                           elif re.match(r'.*\s*(\bxferlog_std_format=NO\b)\s*', line) and len(line) == 21:
                                flag2 = True
                           elif re.match(r'.*\s*(\blog_ftp_protocol=YES\b)\s*', line) and len(line) == 20:
                                flag3 = True
            else:
                    logging("The service 'vsftpd' is installed but the file path "+ configFile +" does not exist, Please fix it manually")
                    return None
            if (flag1 and flag2 and flag3):
               logging("'vsftpd' is configured for logging or verbose mode.")
            else:
               logging("'vsftpd' is not configured properly for logging or verbose mode. Please configure 'vsftpd' for logging or verbose mode.")
            return flag1 and flag2 and flag3

        logging("'vsftpd' package is not installed on your system.")
        return True 

        
def fixRule38702():
        if OsName.lower() == "ubuntu":
            #File path for ubuntu
            configFile="/etc/vsftpd.conf"
        else:
            #File path for centOS
            configFile="/etc/vsftpd/vsftpd.conf"
        #open the config file
        logging("Checking whether 'vsftpd' is configured for logging or verbose mode.")
        with open(configFile, "r") as f:
            s = ""
            lastLine = ""
            flag1 = flag2 = flag3 = False
            for line in f:
                 #Scenario-1->If pattern exist with wrong value.
                 if isL(line) and ("xferlog_enable" in line or "xferlog_std_format" in line or "log_ftp_protocol" in line):
                     values = line.split("=")
                     values = map(str.strip, values)
                     listLen = len(values)
                     #check for 1 pattern xferlog_enable
                     if values[0] == "xferlog_enable":
                         if listLen == 2:
                             if (re.match(r'.*\s*(\bYES\b)\s*', values[1])) and (not tokenMatch("Cloud Raxak updated next line",lastLine)):
                                  s += "# Cloud Raxak updated next line\n"
                             s += values[0] +"=YES\n"
                             flag1 = True
                         else:
                             if not tokenMatch("Cloud Raxak updated next line",lastLine):
                                  s += "# Cloud Raxak updated next line\n"
                             s += values[0] +"=YES\n"
                             flag1 = True
                     #check for 2 pattern xferlog_std_format
                     elif values[0] =="xferlog_std_format":
                         if listLen == 2:
                             if (re.match(r'.*\s*(\bNO\b)\s*', values[1])) and (not tokenMatch("Cloud Raxak updated next line",lastLine)):
                                  s += "# Cloud Raxak updated next line\n"
                             s += values[0] +"=NO\n"
                             flag2 = True
                         else:
                             if not tokenMatch("Cloud Raxak updated next line",lastLine):
                                  s += "# Cloud Raxak updated next line\n"
                             s += values[0] +"=YES\n"
                             flag2 = True
                     #check for 3 pattern log_ftp_protocol
                     elif values[0] =="log_ftp_protocol":
                         if listLen == 2:
                             if (re.match(r'.*\s*(\bYES\b)\s*', values[1])) and (not tokenMatch("Cloud Raxak updated next line",lastLine)):
                                  s += "# Cloud Raxak updated next line\n"
                             s += values[0] +"=YES\n"
                             flag3 = True
                         else:
                             if not tokenMatch("Cloud Raxak updated next line",lastLine):
                                  s += "# Cloud Raxak updated next line\n"
                             s += values[0] +"=YES\n"
                             flag3 = True
                     lastLine=line
                 else:
                     s += line
                     lastLine=line
        #Scenario-2->If pattern does not exist.
        if not(flag1):
             if not tokenMatch("Cloud Raxak updated next line",lastLine):
                 s += "# Cloud Raxak updated next line\n"
             s += "xferlog_enable=YES\n"
        if not(flag2):
             if not tokenMatch("Cloud Raxak updated next line",lastLine): 
                 s += "# Cloud Raxak updated next line\n"
             s += "xferlog_std_format=NO\n"
        if not(flag3):
             if not tokenMatch("Cloud Raxak updated next line",lastLine):
                 s += "# Cloud Raxak updated next line\n"
             s += "log_ftp_protocol=YES\n"
        fout = None
        try:
             logging("Configuring the system for logging or verbose mode.")
             fout = open(configFile, "wt")
             fout.write(s)
        finally:
             if (fout is not None):
                  fout.close()

        runOnShell("service vsftpd restart")


def checkRule50001():
        res = runOnShell('ls -l /etc/gshadow')
        ret = res.split(" ")[2] == "root"
        return ret
	return False

def fixRule50001():
	runOnShell('chown root /etc/gshadow')

def checkRule50002():
        res = runOnShell('ls -l /etc/gshadow')
        return res.split(" ")[3] == "root"

def fixRule50002():
	runOnShell('chgrp root /etc/gshadow')

def checkRule50003():
        res = runOnShell('ls -l /etc/gshadow')
#note: new linux ls-l returns a . or a + in column 11 if there is an alternate (SELinux ACL)
# access control active. So just splitting on " " does not work. The 11th character could be
# a . or a + or any other printing character
        return res.split(" ")[0][0:10] == "-r--------"

def fixRule50003():
	runOnShell('chmod 400 /etc/gshadow')

def checkRule50004():
        res = runOnShell('ls -l /etc/passwd')
        return res.split(" ")[2] == "root"

def fixRule50004():
	runOnShell('chown root /etc/passwd')

def checkRule50005():
        res = runOnShell('ls -l /etc/passwd')
        return res.split(" ")[3] == "root"

def fixRule50005():
	runOnShell('chgrp root /etc/passwd')

def checkRule50006():
        res = runOnShell('ls -l /etc/passwd')
        return "-rw-r--r--" in res.split(" ")[0]

def fixRule50006():
	runOnShell('chmod 0644 /etc/passwd')

def checkRule50007():
        res = runOnShell('grep PASS_MIN_LEN /etc/login.defs | grep -v "^#" | awk -F" " \'{ print $2 }\'')
        if res and int(res) == 5 :
            return True
        else:
            return False

def fixRule50007():
        with open('/etc/login.defs', "r") as f:
            s = ""
            for line in f:
                if tokenMatch("Cloud Raxak updated next line", line):
		    continue
                elif isL(line) and tokenMatch("PASS_MIN_LEN", line):
                    s += "PASS_MIN_LEN\t"+str(5)+"\n"
                else:
                    s += line

            fout = None
            try:
                fout = open('/tmp/login.defs', "w")
                fout.write(s)
            finally:
                if (fout is not None):
                    fout.close()

            runOnShell("cp -f /tmp/login.defs /etc/login.defs")
            runOnShell("rm -f /tmp/login.defs")

def checkRule50008():
        res = runOnShell('ls /etc/ntp.conf 2>/dev/null')
	if res and not("No such file or directory" in res):
		return False
	else:
		return True		

def fixRule50008():
        res = runOnShell('rm -f /etc/ntp.conf')

def checkRule50009():
	#Checking ssh configuration file validity
	#If there are any errors, not restarting ssh
	if checkSSHDSyntax() == None:
	    return None

        res = runOnShell('grep -iw PrintLastLog /etc/ssh/sshd_config | grep -v "#" ')
        if not res:
            return False
        else:
		if res.startswith("#PrintLastLog"):
            		if "yes" in res.lower():
		                return True
		        else:
                		return False
		else:
                	return False

def fixRule50009():
        if checkSSHDSyntax() == None:
            return None

        runOnShell("cp -f /etc/ssh/sshd_config /tmp/sshd_config")
        runOnShell("chmod 644 /tmp/sshd_config")

        with open("/tmp/sshd_config", "r") as f:
            flag = False
            s = ""
            for line in f:
                if isL(line) and tokenMatchIC("PrintLastLog", line):
                    s += "#PrintLastLog yes\n"
                    flag = True
                else:
                    s += line

	if not(flag):
	    s += "#PrintLastLog yes\n"

	fout = None
	try:
	    fout = open("/tmp/sshd_config_new", 'w')
	    fout.write(s)
	finally:
	    if fout is not None:
		fout.close()

	runOnShell("cp -f /tmp/sshd_config_new /etc/ssh/sshd_config")
	runOnShell("rm -f /tmp/sshd_config_new")

	#Enabling ssh service and run leves
	RunService("ssh")

def checkRule50010():
	if not CheckService("auditd"):
		return False
        res = runOnShell('grep -w num_logs /etc/audit/auditd.conf | grep -v "^#" | awk -F"= " \'{ print $2 }\'')
        if res:
            return int(res) == 4

        return False

def fixRule50010():
        if not InstallPackage("audit"):
            return None

        flag = False
        runOnShell("cp -f /etc/audit/auditd.conf /tmp/auditd.conf")
        runOnShell("chmod 644 /tmp/auditd.conf")
        with open('/tmp/auditd.conf', "r") as f:
            s = ""
            lastLine= ""
            for line in f:
                if tokenMatch("Cloud Raxak updated next line", line):
		    continue
                if "num_logs" in line:
                    s += "num_logs = 4\n"
                    flag = True
                else:
                    s += line

            if not(flag):
                s += "num_logs = 4\n"
            fout = None
            try:
                fout = open('/tmp/auditd_new.conf', "wt")
                fout.write(s)
            finally:
                if (fout is not None):
                    fout.close()

	    RunService("auditd") 	
            runOnShell("cp -f /tmp/auditd_new.conf /etc/audit/auditd.conf")
            runOnShell("rm -f /tmp/auditd_new.conf")
        runOnShell("rm -f /tmp/auditd.conf")


def checkRule50011():
	if not CheckService("auditd"):
		return False

        res = runOnShell('grep -w max_log_file_action /etc/audit/auditd.conf | grep -v "^#" | awk -F"= " \'{ print $2 }\'')
        if res:
            if "rotate" in res.lower():
                return True
        return False

def fixRule50011():
        if not InstallPackage("audit"):
            return None

        flag = False
        runOnShell("cp -f /etc/audit/auditd.conf /tmp/auditd.conf")
        runOnShell("chmod 644 /tmp/auditd.conf")
        with open('/tmp/auditd.conf', "r") as f:
            s = ""
            for line in f:
                if tokenMatch("Cloud Raxak updated next line", line):
		    continue
                if "max_log_file_action" in line:
                    s += "max_log_file_action = ROTATE\n"
                    flag = True
                else:
                    s += line

            if not(flag):
                s += "max_log_file_action = ROTATE\n"
            fout = None
            try:
                fout = open('/tmp/auditd_new.conf', "w")
                fout.write(s)
            finally:
                if (fout is not None):
                    fout.close()

	    RunService("auditd") 	
            runOnShell("cp -f /tmp/auditd_new.conf /etc/audit/auditd.conf")
            runOnShell("rm -f /tmp/auditd_new.conf")
        runOnShell("rm -f /tmp/auditd.conf")

def checkRule50012():
	if not CheckService("auditd"):
		return False

        res = runOnShell('grep -w max_log_file /etc/audit/auditd.conf | grep -v "^#" | awk -F"= " \'{ print $2 }\'')
        if res:
            return int(res) == 5

        return False

def fixRule50012():
        if not InstallPackage("audit"):
            return None

        flag = False
        runOnShell("cp -f /etc/audit/auditd.conf /tmp/auditd.conf")
        runOnShell("chmod 644 /tmp/auditd.conf")
        with open('/tmp/auditd.conf', "r") as f:
            s = ""
            lastLine= ""
            for line in f:
                if tokenMatch("Cloud Raxak updated next line", line):
		    continue
                if tokenMatchIC("max_log_file", line):
                    s += "max_log_file = 5\n"
                    flag = True
                else:
                    s += line
            if not(flag):
                s += "max_log_file = 5\n"
            fout = None
            try:
                fout = open('/tmp/auditd_new.conf', "w")
                fout.write(s)
            finally:
                if (fout is not None):
                    fout.close()

	    RunService("auditd") 	
            runOnShell("cp -f /tmp/auditd_new.conf /etc/audit/auditd.conf")
            runOnShell("rm -f /tmp/auditd_new.conf")
        runOnShell("rm -f /tmp/auditd.conf")

def checkRule50013():
        res = runOnShell('grep PASS_MIN_DAYS /etc/login.defs | grep -v "^#" | awk -F" " \'{ print $2 }\'')
        if res and int(res) == 0:
            return True
        else:
            return False

def fixRule50013():
        with open('/etc/login.defs', "r") as f:
            s = ""
            for line in f:
                if tokenMatch("Cloud Raxak updated next line", line):
		    continue
                elif isL(line) and tokenMatch("PASS_MIN_DAYS", line):
                    s += "PASS_MIN_DAYS\t"+str(0)+"\n"
                else:
                    s += line

            fout = None
            try:
                fout = open('/tmp/login.defs', "w")
                fout.write(s)
            finally:
                if (fout is not None):
                    fout.close()

            runOnShell("cp -f /tmp/login.defs /etc/login.defs")
            runOnShell("rm -f /tmp/login.defs")
        return True 

def checkRule50014():
        res = runOnShell('grep PASS_MAX_DAYS /etc/login.defs | grep -v "^#" | awk -F" " \'{ print $2 }\'')
        if res and int(res) == 99999:
            return True
        else:
            return False

def fixRule50014():
        with open('/etc/login.defs', "r") as f:
            s = ""
            for line in f:
                if tokenMatch("Cloud Raxak updated next line", line):
		    continue
                elif isL(line) and tokenMatch("PASS_MAX_DAYS", line):
                    s += "PASS_MAX_DAYS\t"+str(99999)+"\n"
                else:
                    s += line

            fout = None
            try:
                fout = open('/tmp/login.defs', "w")
                fout.write(s)
            finally:
                if (fout is not None):
                    fout.close()

            runOnShell("cp -f /tmp/login.defs /etc/login.defs")
            runOnShell("rm -f /tmp/login.defs")
        return True 

def checkRule50015():
        res = runOnShell('grep PASS_WARN_AGE /etc/login.defs | grep -v "^#" | awk -F" " \'{ print $2 }\'')
        if res and int(res) == 7:
            return True
        else:
            return False

def fixRule50015():
        with open('/etc/login.defs', "r") as f:
            s = ""
            for line in f:
                if tokenMatch("Cloud Raxak updated next line", line):
		    continue
                elif isL(line) and tokenMatch("PASS_WARN_AGE", line):
                    s += "PASS_WARN_AGE\t"+str(7)+"\n"
                else:
                    s += line

            fout = None
            try:
                fout = open('/tmp/login.defs', "w")
                fout.write(s)
            finally:
                if (fout is not None):
                    fout.close()

            runOnShell("cp -f /tmp/login.defs /etc/login.defs")
            runOnShell("rm -f /tmp/login.defs")
        return True 

def checkRule43150():
    # The unit below checks whether system is a GUI based system.
    logging("Checking whether the system is a GUI based system.")
    display_manager = ""
    if OsName.lower() == "ubuntu":
        if not CheckPackage("ubuntu-desktop") or not CheckPackage("xorg"):
            logging("Since this system is not a GUI based system, this rule is not applicable.")
            return 3
        if not os.path.exists('/etc/X11/default-display-manager'):
            logging("The file 'default-display-manager' stores which display manager the operating system uses, but this file is not available. Please fix this manually.")
            return None
        display_manager = runOnShell('cat /etc/X11/default-display-manager')
    else:
        if (OsName.lower() == "redhat" or OsName.lower() == "centos") and OsVersion < (7,0):
            display_manager = "gconftool-2"
            if not os.path.exists('/usr/bin/gconftool-2'):
                logging("Since this system is not a GUI based system, this rule is not applicable.")
                return 3
        else:
            display_manager = "gdm"
            if not CheckPackage("gdm"):
                logging("Since this system is not a GUI based system, this rule is not applicable.")
                return 3
            checkVal = runOnShell('sudo -u gdm gsettings get org.gnome.login-screen disable-user-list')
            if tokenMatch("true", checkVal):
                logging("The login user list is disabled.")
                return True
            else:
                logging("The login user list is not disabled.")
                return False

    logging("Checking whether the login user list is disabled.")
    if "gconftool-2" in display_manager:
	# Check whether user has set a system wide configuration in gconf.xml.mandatory, if not then check in gconf.xml.defaults
	if os.path.exists('/etc/gconf/gconf.xml.mandatory/apps/gdm/simple-greeter') or \
		os.path.exists('/etc/gconf/gconf.xml.mandatory/%gconf-tree.xml'):
		res = runOnShell('gconftool-2 --direct --config-source xml:readwrite:/etc/gconf/gconf.xml.mandatory --get /apps/gdm/simple-greeter/disable_user_list')
	else:
		res = runOnShell('gconftool-2 --direct --config-source xml:readwrite:/etc/gconf/gconf.xml.defaults --get /apps/gdm/simple-greeter/disable_user_list')
        res = res.translate(string.maketrans("\n\t\r", "   "))
        if tokenMatchIC("true", res):
            logging("The login user list is disabled.")
            return True
        else:
            logging("The login user list is not disabled.")
            return False
    elif "lightdm" in display_manager:
        if not os.path.exists('/etc/lightdm'):
            logging("The directory for 'lightdm' package was not found. Please fix this manually.")
            return None

        check_disabled = runOnShell('egrep -i "\[SeatDefaults]|greeter-hide-users|allow-guest|greeter-show-manual-login" /etc/lightdm/lightdm.conf.d/*[0-9][0-9]*.conf | grep -v "^#"')
        if "Error" in check_disabled:
            logging("Configuration for disabling the login user list was not found.")
            return False
        check_disabled = check_disabled.splitlines()
        ref_list = ['[SeatDefaults]', 'allow-guest=false', 'greeter-hide-users=true', 'greeter-show-manual-login=true']

        # If there is even a single white space after "true" in greeter-hide-users=true the functionality does not work, so the rule will fail in this case.
        for config_line in check_disabled:
            check_space = len(config_line) - len(config_line.rstrip())
            if "greeter-hide-users" in config_line and check_space > 0:
                logging("Configuration for disabling the login user list is not configured correctly.")
                return False

        # remove whitespaces
        check_disabled = [re.sub('\s+', '', ele) for ele in check_disabled]
        if len(check_disabled) != 4:
            logging("Configuration for disabling the login user list is not configured correctly.")
            return False

        count_obj = 0
        for element1 in check_disabled:
            for element2 in ref_list:
                if element2 in element1:
                    count_obj = count_obj + 1
            if count_obj > 4:
                    break

        if count_obj == 4:
            logging("The login user list is disabled.")
            return True
        else:
            logging("The login user list is not disabled.")
            return False
    elif "gdm" in display_manager:
        if not os.path.exists('/etc/dconf/db/gdm.d/00-upstream-settings'):
            logging("The configuration file for 'gdm' package is not available. Please fix this manually.")
            return None

        check_disabled = runOnShell('egrep -w "disable-user-list|\[org/gnome/login-screen]" /etc/dconf/db/gdm.d/* 2>/dev/null | grep -v "#"')
        check_disabled = check_disabled.translate(string.maketrans(":"," "))
        if not check_disabled:
            logging("The configuration for disabling login user list was not found.")
            return False
        if check_disabled.count("00",0,len(check_disabled)) >= 2:
            if "00-upstream-settings" not in check_disabled or (check_disabled.count("00",0,len(check_disabled)) > 2 and "00-upstream-settings" in check_disabled):
                logging("One or more than one configuration file for disabling login user list has the same prefix as the default configuration file.")
                return False

        check_disabled = check_disabled.splitlines()
        count_parameters = float(len(check_disabled)/2.0)
        # check_disabled_parameter is for checking the parameters inside the file.
        check_disabled_parameter = check_disabled
        check_disabled_parameter = [re.sub('\s+', '', ele) for ele in check_disabled_parameter]
        ref_list = ['[org/gnome/login-screen]', 'disable-user-list=true']

        count_obj = 0
        try:
            for i in range(len(check_disabled_parameter)):
                if ref_list[0] in check_disabled_parameter[i]:
                    i = i + 1
                    if ref_list[1] in check_disabled_parameter[i]:
                    # Check if both parameters are from the same config file or not.
                        for j in range(len(check_disabled)):
                            check_disabled_path_one = check_disabled[j].split()
                            j = j + 1
                            check_disabled_path_two = check_disabled[j].split()
                            if check_disabled_path_one[0] == check_disabled_path_two[0]:
                                count_obj = count_obj + 1
                                break
        except IndexError:
            logging("The configuration for disabling login user list is not configured correctly.")
            return False

        if float(count_obj) == count_parameters:
            logging("The configuration for disabling login user list is configured correctly.")
            return True
        else:
            logging("The configuration for disabling login user list is not configured correctly.")
            return False

def fixRule43150():
    display_manager = ""
    if (OsName.lower() == "redhat" or OsName.lower() == "centos") and (OsVersion < (7,0)):
        display_manager = "gconftool-2"
    elif OsName.lower() == "ubuntu":
        display_manager = runOnShell('cat /etc/X11/default-display-manager')
    elif (OsName.lower() == "redhat" or OsName.lower() == "centos") and (OsVersion >= (7,0)):
        runOnShell('sudo -u gdm dbus-launch gsettings set org.gnome.login-screen disable-user-list true')
        logging("Logout or reboot the system to reflect the changes made.")

    if "gconftool-2" in display_manager:
	# While fixing, make changes that will be effected system wide, even if the xml file is not available, our fix solution creates it automatically.
        runOnShell('gconftool-2 --direct --config-source xml:readwrite:/etc/gconf/gconf.xml.mandatory --type bool --set /apps/gdm/simple-greeter/disable_user_list true')
        logging("Logoff or reboot the system to reflect changes.")
    elif "gdm" in display_manager:
        if not os.path.exists('/etc/dconf/db/gdm.d/00-upstream-settings'):
            logging("The configuration file for 'gdm' package is not available. Please fix this manually.")
            return None

        check_disabled_str = runOnShell('egrep -w "disable-user-list|\[org/gnome/login-screen]" /etc/dconf/db/gdm.d/* 2>/dev/null | grep -v "#"')
        check_disabled_str = check_disabled_str.translate(string.maketrans(":"," "))
        if check_disabled_str != "":
            check_disabled = check_disabled_str.splitlines()

            filepathlist = []
            for config_file_path in check_disabled:
                check_disabled_path = config_file_path.split()
                filepathlist.append(check_disabled_path[0])
            filepathlist = list(set(filepathlist))

            for config_file in filepathlist:
                flag_disable = False
                with open(config_file,"r") as file_data:
                    disable_user_list = ""
                    lastLine = ""
                    for line in file_data:
                        if isL(line) and (("disable-user-list" in line) or ("[org/gnome/login-screen]" in line)):
                            if not flag_disable:
                                logging("Updating the configuration for disabling the login user list.")
                                if not tokenMatch('Cloud Raxak updated next line',lastLine):
                                    disable_user_list += "# Cloud Raxak updated next line.\n"
                                disable_user_list += "[org/gnome/login-screen]\ndisable-user-list=true\n"
                                flag_disable = True
                        else:
                            disable_user_list += line
                            lastLine = line
                if not flag_disable:
                    logging("Adding the configuration for disabling the login user list.")
                    if not tokenMatch('Cloud Raxak updated next line',lastLine):
                        disable_user_list += "# Cloud Raxak updated next line.\n"
                    disable_user_list += "[org/gnome/login-screen]\ndisable-user-list=true\n"
                    fout = None
                try:
                    fout = open(config_file, 'wt')
                    fout.write(disable_user_list)
                finally:
                    if fout is not None:
                        fout.close()
            # If there is another config file with the same prefix as 00-upstream settings, rename that file with a higher prefix.
            if check_disabled_str.count("00",0,len(check_disabled_str)) >= 2:
                if "00-upstream-settings" not in check_disabled_str or (check_disabled_str.count("00",0,len(check_disabled_str)) > 2 and "00-upstream-settings" in check_disabled_str):
                    try:
                        wrong_file = runOnShell('egrep -w "disable-user-list|\[org/gnome/login-screen]" /etc/dconf/db/gdm.d/* 2>/dev/null | grep -v "#" | grep -v "00-upstream-settings" | grep "00"')
                        wrong_file = wrong_file.translate(string.maketrans(":"," "))
                        wrong_file = wrong_file.split()
                        runOnShell('mv ' + wrong_file[0] + ' /etc/dconf/db/gdm.d/01-hide-user-list')
                    except IndexError:
                        wrong_file = runOnShell('egrep -w "disable-user-list|\[org/gnome/login-screen]" /etc/dconf/db/gdm.d/* 2>/dev/null | grep -v "#" | grep "00"').splitlines()
                        no_of_files = len(wrong_file)
                        file_rename = wrong_file[no_of_files-1]
                        file_rename_split = file_rename.split(':')
                        runOnShell('mv ' + file_rename_split[0] + ' /etc/dconf/db/gdm.d/01-hide-user-list')
        else:
            flag_disable = False
            with open("/etc/dconf/db/gdm.d/00-upstream-settings","r") as file_data:
                disable_user_list = ""
                lastLine = ""
                for line in file_data:
                    if isL(line) and (("disable-user-list" in line) or ("[org/gnome/login-screen]" in line)):
                        if not flag_disable:
                            logging("Updating the configuration for disabling the login user list.")
                            if not tokenMatch('Cloud Raxak updated next line',lastLine):
                                    disable_user_list += "# Cloud Raxak updated next line.\n"
                            disable_user_list += "[org/gnome/login-screen]\ndisable-user-list=true\n"
                            flag_disable = True
                    else:
                        disable_user_list += line
                        lastLine = line
            if not flag_disable:
                logging("Adding the configuration for disabling the login user list.")
                if not tokenMatch('Cloud Raxak updated next line',lastLine):
                    disable_user_list += "# Cloud Raxak updated next line.\n"
                disable_user_list += "[org/gnome/login-screen]\ndisable-user-list=true\n"
            fout = None
            try:
                fout = open("/etc/dconf/db/gdm.d/00-upstream-settings", 'wt')
                fout.write(disable_user_list)
            finally:
                if fout is not None:
                        fout.close()
        runOnShell('dconf update')
        logging("Logout or reboot the system to reflect changes.")
    elif "lightdm" in display_manager:
        if not os.path.exists('/etc/lightdm'):
            logging("The directory for 'lightdm' package is not available. Please fix this manually.")
            return None

        if os.path.exists('/etc/lightdm/lightdm.conf.d/'):
            check_disabled = runOnShell('egrep -i "\[SeatDefaults]|greeter-hide-users|allow-guest|greeter-show-manual-login" /etc/lightdm/lightdm.conf.d/*[0-9][0-9]*.conf -H | grep -v ^"#"')
            if (check_disabled != "") and ("Error" not in check_disabled):
                check_disabled = check_disabled.translate(string.maketrans(":"," "))
                check_disabled = check_disabled.splitlines()
                check_disabled_element = check_disabled[0].split()
                filepath = check_disabled_element[0]
                flag_disable = False
                with open(filepath) as file_data:
                    disable_user_list = ""
                    lastLine = ""
                    for line in file_data:
                        if isL(line) and (("[SeatDefaults]" in line) or ("greeter-hide-users" in line) or ("allow-guest" in line) or ("greeter-show-manual-login" in line)):
                            if not flag_disable:
                                logging("Updating the configuration for disabling the login user list.")
                                if not tokenMatch('Cloud Raxak updated next line',lastLine):
                                    disable_user_list += "# Cloud Raxak updated next line.\n"
                                disable_user_list += "[SeatDefaults]\nallow-guest=false\ngreeter-hide-users=true\ngreeter-show-manual-login=true\n"
                                flag_disable = True
                        else:
                            disable_user_list += line
                            lastLine = line
                if not flag_disable:
                    logging("Adding the configuration for disabling the login user list.")
                    if not tokenMatch('Cloud Raxak updated next line',lastLine):
                        disable_user_list += "# Cloud Raxak updated next line.\n"
                    disable_user_list += "[SeatDefaults]\nallow-guest=false\ngreeter-hide-users=true\ngreeter-show-manual-login=true\n"
                fout = None
                try:
                    fout = open(filepath, 'wt')
                    fout.write(disable_user_list)
                finally:
                    if fout is not None:
                        fout.close()
            else:
                # If directory lightdm.conf.d exists create only the config file.
                runOnShell('touch /etc/lightdm/lightdm.conf.d/50-myconfig.conf')
                fout = None
                try:
                    fout = open("/etc/lightdm/lightdm.conf.d/50-myconfig.conf", 'wt')
                    disable_user_list = "[SeatDefaults]\nallow-guest=false\ngreeter-hide-users=true\ngreeter-show-manual-login=true\n"
                    fout.write(disable_user_list)
                finally:
                    if fout is not None:
                        fout.close()
        else:
            # If both directory and config file do not exist, create directory and config file.
            runOnShell('mkdir -p /etc/lightdm/lightdm.conf.d/')
            runOnShell('touch /etc/lightdm/lightdm.conf.d/50-myconfig.conf')
            fout = None
            try:
                fout = open("/etc/lightdm/lightdm.conf.d/50-myconfig.conf", 'wt')
                disable_user_list = "[SeatDefaults]\nallow-guest=false\ngreeter-hide-users=true\ngreeter-show-manual-login=true\n"
                fout.write(disable_user_list)
            finally:
                if fout is not None:
                    fout.close()

def checkRule50016():
        return False

def fixRule50016():
        return True 

def checkRule50017():
        return False

def fixRule50017():
        return True 

def checkRule51875():
    logging("Checking the settings for information regarding the number of unsuccessful login attempts.") 
    checkLoginFile = runOnShell('grep "session\s*required\s*pam_lastlog.so" /etc/pam.d/login | grep -v "^#"')
    checkLogin = checkLoginFile.translate(string.maketrans("\n\t\r", "   ")).strip()
    checkLogin = re.match(r'.*\s*(\bshowfailed\b)\s*', checkLogin)
    showFailed = False
    checkPostLoginEntry = False
    checkAuth = ""
    checkOs = False

    if not OsName.lower() == "ubuntu":
	# Checking the entry in /etc/pam.d/system-auth
        checkAuth = runOnShell('grep -w session /etc/pam.d/system-auth | grep -w required | grep -w pam_lastlog.so | grep -v "^#"')
        checkAuth = checkAuth.translate(string.maketrans("\n\t\r", "   ")).strip()
        matchObj = re.match(r'.*\s*(\bshowfailed\b)\s*', checkAuth)

        #If OsVersion > (7,0)
	if (OsName.lower() == "redhat" or OsName.lower() == "centos") and OsVersion >= (7,0):
	    checkOs = True
	    # Checking the default entry in /etc/pam.d/postlogin
	    checkPostloginOption = runOnShell('grep "session\s*\[default\=1\]\s*pam_lastlog.so" /etc/pam.d/postlogin | grep -v "^#"')
	    checkPostloginOption = checkPostloginOption.translate(string.maketrans("\n\t\r", "   ")).strip()
	    checkPostloginOption = re.match(r'.*\s*(\bshowfailed\b)\s*', checkPostloginOption)

	    checkPostlogin = runOnShell('grep "session\s*optional\s*pam_lastlog.so" /etc/pam.d/postlogin | grep -v "^#"')
	    checkPostlogin = checkPostlogin.translate(string.maketrans("\n\t\r", "   ")).strip()
	    checkPostlogin = re.match(r'.*\s*(\bshowfailed\b)\s*', checkPostlogin)

	    if checkPostlogin and checkPostloginOption:
	        checkPostLoginEntry = True
	        showFailed = True
	    elif checkLogin and checkPostLoginEntry:
	        showFailed = True
	    else:
	        pass

    # 1) Checking if the line is without showfailed parameter in checkAuth and also the parameter (showfailed) 
    # does not exist in login file, then the condition is false.
    # 2) If showfailed parameter is not in the line in the /etc/pam.d/login file, then the condition is false.
    # 3) In Centos < 7 if the line in both the files /system-auth and /login does not exist, them the condition is fail.   

    if (checkAuth != "" and matchObj == None and checkLogin == None) or (checkLoginFile != "" and checkLogin == None)or (checkAuth == "" and checkLogin == None and not checkOs ):
        logging("Configuration for the information regarding the number of unsuccessful login attempts is not correct.")
        return False
    elif not showFailed and checkOs:
        logging("Configuration for the information regarding the number of unsuccessful login attempts is not correct.")
        return False
    else:
        logging("Configuration for the information regarding the number of unsuccessful login attempts is correct.")
        return True

def fixRule51875():
    checkOs = False
    if OsName.lower() == "ubuntu":
        pathList = ["/etc/pam.d/login"]
    elif (OsName.lower() == "redhat" or OsName.lower() == "centos") and OsVersion >= (7,0):
        checkOs = True
        pathList = ["/etc/pam.d/system-auth","/etc/pam.d/login"]
        checkDefault = runOnShell('grep "session\s*\[default\=1\]\s*pam_lastlog.so" /etc/pam.d/postlogin | grep -v "^#"')
        checkOptional = runOnShell('grep "session\s*optional\s*pam_lastlog.so" /etc/pam.d/postlogin | grep -v "^#"')

        # If the postline file does not contain the showfailed lines, update the showfailed line in /postline file.
        if checkDefault == "" and checkOptional == "":
            updateDefaultLine = runOnShell('sed -i "/^session.*pam_succeed_if.so/a session     [default=1]     pam_lastlog.so nowtmp showfailed" /etc/pam.d/postlogin ')
            updateOptionalLine = runOnShell('sed -i "/^session.*pam_succeed_if.so/a session     optional   pam_lastlog.so silent noupdate showfailed" /etc/pam.d/postlogin ')
        elif checkDefault == "":
            updateDefaultLine = runOnShell('sed -i "/^session.*pam_succeed_if.so/a session     [default=1]     pam_lastlog.so nowtmp showfailed" /etc/pam.d/postlogin ')
        elif checkOptional == "":
            updateOptionalLine = runOnShell('sed -i "/^session.*pam_succeed_if.so/a session     optional   pam_lastlog.so silent noupdate showfailed" /etc/pam.d/postlogin ')
        else:
            matchDefault = re.match(r'.*\s*(\bshowfailed\b)\s*', checkDefault)
            matchOptional = re.match(r'.*\s*(\bshowfailed\b)\s*', checkOptional)
	    # update the showfailed parameter.
            if matchDefault == None:
                updateDefaultLine = runOnShell('sed -i "s/session[ ]*\[default=1][ ]*pam_lastlog.so.*/session     [default=1]   pam_lastlog.so nowtmp showfailed/g" /etc/pam.d/postlogin')
            if matchOptional == None:
                updateOptionalLine = runOnShell('sed -i "s/session[ ]*optional[ ]*pam_lastlog.so.*/session     optional      pam_lastlog.so silent noupdate showfailed/g" /etc/pam.d/postlogin')
    else:
        pathList = ["/etc/pam.d/system-auth","/etc/pam.d/login"]

    logging("Modifying the settings for getting information regarding the number of unsuccessful login attempts.")
    for filePath in pathList:
        checkResult = runOnShell('grep -w session '+ filePath +'  | grep -w required | grep -w pam_lastlog.so | grep -v "^#"')
        with open(filePath, "r") as fileContent:
            fileString = ""
            lastLine = ""
            for line in fileContent:
                moduleSearchObj = re.search('session\s*required\s*pam_lastlog.so',line)
                if moduleSearchObj != None and checkResult != "":
                    if isL(line):
                        line = line.translate(string.maketrans("\n\t\r", "   ")).strip()
                        matchObj = re.match(r'.*\s*(\bshowfailed\b)\s*', checkResult)
                        if matchObj == None:
                            line = line.translate(string.maketrans("\n", " ")).strip()
                            line = line+' showfailed'
                            if not tokenMatch('Cloud Raxak updated next line', lastLine):
                                fileString += "# Cloud Raxak updated next line\n"
                        fileString += line + '\n'
                elif checkResult == "" and not checkOs:
                    if re.search('session\s*required\s*pam_limits.so',line):
                        fileString += line + "# Cloud Raxak updated next line\nsession     required     pam_lastlog.so showfailed\n"
                        continue
                    fileString += line
                else:
                    fileString += line
                lastLine = line
        fout = None
        fout = open(filePath, 'wt')
        if fout != None:
            fout.write(fileString)
            fout.close()

def checkRule54381():
    if not CheckService("auditd"):
        return False
    if not os.path.exists('/etc/audit/auditd.conf'):
        logging("The configuration file for audit daemon was not found. Please fix this manually.")
        return None

    logging("Checking whether audit daemon is configured to take appropriate action when available audit storage volume becomes dangerously low.")
    check_mode = runOnShell('grep -w admin_space_left_action /etc/audit/auditd.conf | grep -v "^#"')
    if not check_mode:
        logging("Configuration for taking appropriate action in case if audit storage volume becomes dangerously low was not found.")
        return False

    check_mode_value = getValueOfKey("admin_space_left_action", check_mode.strip("\n"))
    if check_mode_value is None:
        logging("Configuration for taking appropriate action in case if audit storage volume becomes dangerously low is not defined.")
        return False
    elif any(ele == check_mode_value.lower() for ele in ['single', 'halt', 'suspend']):
        logging("Audit is configured properly to take appropriate action in case if audit storage volume becomes dangerously low.")
        return True
    else:
        logging("Audit is not configured properly to take appropriate action in case if audit storage volume becomes dangerously low.")
        return False

def fixRule54381():
    if not InstallPackage("audit"):
        return None

    if not os.path.exists('/etc/audit/auditd.conf'):
        logging("The configuration file for audit daemon was not found. Please fix this manually.")
        return None

    # Removing Unnecessary spaces
    runOnShell('sed -ie "s/^[ \t]*admin_space_left_action/admin_space_left_action/;s/[ \t]*=/ =/;s/=[ \t]*/= /" /etc/audit/auditd.conf')
    with open("/etc/audit/auditd.conf", "r") as file_data:
        flag_mode = False
        change_mode = ""
        lastLine = ""
        for line in file_data:
            if isL(line) and "admin_space_left_action" in line:
                if not flag_mode:
                    logging("Updating configuration for taking appropriate action in case if audit storage volume becomes dangerously low.")
                    if not tokenMatch('Cloud raxak updated next line',lastLine):
                        change_mode += "# Cloud raxak updated next line\n"
                    change_mode += "admin_space_left_action = SINGLE\n"
                    flag_mode = True
            else:
                change_mode += line
                lastLine = line
    if not(flag_mode):
        logging ("Adding configuration for taking appropriate action in case if audit storage volume becomes dangerously low.")
        if not tokenMatch('Cloud raxak updated next line',lastLine):
            change_mode += "# Cloud raxak updated next line\n"
        change_mode += "admin_space_left_action = SINGLE\n"
    writeFile("/etc/audit/auditd.conf",change_mode,'wt')

    logging("Restarting audit service.")
    RunService("auditd")

def checkRule57569():
    ''' Description: Checking whether mount point /tmp is having noexec optoin in /etc/fstab.'''

    if not check_fstab_config():
        return None

    noexecFlag = False
    mount_option_list = ["noexec", "user", "users"]
    logging("Finding any entry that start with /tmp.")
    res = runOnShell('grep -w "/tmp" /etc/mtab /etc/fstab | grep -v ":\s*#"')
    if res == "":
        logging("/tmp directory is not mounted in /etc/fstab.")
        return True
    res = res.splitlines()
    for line in res:
        line = line.split(":")
        mountFileName = line[0]
        # Handling any space at the start of the line.
        line = line[1].translate(string.maketrans("\n\t\r", "   ")).strip()
        line = line.split(" ")
        line = filter(None, line)
        if not line:
            continue
        if mountFileName == "/etc/fstab" and ((OsVersion <= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
            try:
                if re.match(r'^tmpfs\b', line[0]) and re.match(r'^/tmp\b', line[1]) and ("user" in line[3] or "users" in line[3]):
                    noexecFlag = True
                    break
            except:
                noexecFlag = False
        if re.match(r'^/tmp\b', line[1]):
            noexecFlag = False
            try:
                mount_option = line[3].split(',') #Spliting the mount option to check noexec option present or not.
                #Checking the mount option from right to left.
                for mount_index in xrange(len(mount_option) - 1, -1, -1):
                    ele = mount_option[mount_index]
                    if ele in mount_option_list:
                        noexecFlag = True
                        break
                    elif "exec" == ele:
                        noexecFlag = None
                        break
                    else:
                        pass
            except:
                noexecFlag = None

    if not noexecFlag:
        logging("/tmp partition mounted on system have entry in /etc/fstab with no 'noexec' option. Please add 'noexec' option for /tmp partition.")
        return False
    else:
        logging("/tmp partitions mounted on system do not have the ability to execute binary files.")
        return True

def fixRule57569():
    ''' Description: Adding noexec option to /tmp mount point entry in /etc/fstab.'''

    #Take bakeup of fstab file before fixing.
    file_config_backup("/etc/fstab")

    #Check for any configuration error in fstab file.
    if not check_fstab_config():
        return None

    # Updating the /etc/fstab file for /tmp mount option with noexec option.
    lastLine = ""
    newLine = ""
    noexecFlag = False
    logging("Finding any entry that start with /tmp.")
    fileContent = open ("/etc/fstab", "r").readlines()
    for line in fileContent:
        if isL(line) and "/tmp" in line:
                noexecFlag = True
                if "Cloud Raxak updated next line" not in lastLine:
                    lastLine += "# Cloud Raxak updated next line\n"
                newLine += fix_fstab_conf(line,"noexec","exec","/tmp")
        else:
            newLine += line
        lastLine = line

    if not noexecFlag:
        res = runOnShell('grep -w /tmp /etc/mtab | grep -v ":\s*#"')
        if "Cloud Raxak updated next line" not in lastLine:
            lastLine += "# Cloud Raxak updated next line\n"
        newLine += fix_fstab_conf(res,"noexec","exec","/tmp")

    fout = None
    try:
        fout = open('/etc/fstab', 'wt')
        fout.write(newLine)
    finally:
        if (fout is not None):
            fout.close()

    logging("Changes made in fstab configuration file, remounting the /tmp partition for effecting the changes.")
    runOnShell("mount -o remount /tmp")

################# PCI DSS Rules ##################################

def checkRule56000():
    ''' Checking the system accounts which are unlocked. '''
    uidMin = runOnShell('awk \'{ if($1 == "UID_MIN") print $2;}\' /etc/login.defs', False).strip()
    usersinPasswd = runOnShell("awk -F: '{print $1}' /etc/passwd", False).splitlines()
    listOfUsers = ""
    for uname in usersinPasswd:
        # getting the uid's
        uid = runOnShell("/usr/bin/id -u " + uname, False)
        try:
            if (1< int(uid) < int(uidMin)):
                if OsName.lower() == "ubuntu":
                    lockPasswd = runOnShell("passwd -S " + uname + "|grep -v L", False)
                else:
                    lockPasswd = runOnShell("passwd -S " + uname + "|grep -v LK", False)
                if lockPasswd:
                    listOfUsers += ", " + uname
        except (ValueError, TypeError):
            logging("The normal system users UID_MIN value is not in proper format in /etc/login.defs file, or invalid format of UID in password file. So check it manually.")
            return None

    if listOfUsers:
        logging("The system account(s) " + listOfUsers.lstrip(',') + " are enabled.")
        return False
    logging("Login access is disabled for all system account's other than root.")
    return True

def fixRule56000():
    ''' Locking the system accounts which are unlocked. '''
    uidMin = runOnShell('awk \'{ if($1 == "UID_MIN") print $2;}\' /etc/login.defs', False).strip()
    usersinPasswd = runOnShell("awk -F: '{print $1}' /etc/passwd", False).splitlines()
    for uname in usersinPasswd:
        uid = runOnShell("/usr/bin/id -u " + uname, False)
        try:
            if (1< int(uid) < int(uidMin)):
                if OsName.lower() == "ubuntu":
                    lockPasswd = runOnShell("passwd -S " + uname + "|grep -v L", False)
                else:
                    lockPasswd = runOnShell("passwd -S " + uname + "|grep -v LK", False)

                if lockPasswd:
                    runOnShell("passwd -l " + uname)
        except (ValueError, TypeError):
            logging("The normal system users UID_MIN value is not in proper format in /etc/login.defs file, \
or invalid format of UID in /etc/passwd file. So check it manually.")
            return None

def checkRule56001():
    ''' Description: Checking whether /etc/passwd, /etc/shadow and /etc/group files are having legacy accounts.'''
    legacyAccStr = runOnShell("grep '^+' /etc/passwd /etc/shadow /etc/group")

    if legacyAccStr:
        logging("The legacy user account(s) exist on the system.")
        return False
    else:
        logging("The legacy user account(s) do not exist on the system.")
        return True

def fixRule56001():
    ''' Description: Deleting the legacy accounts from /etc/passwd, /etc/shadow and /etc/group.'''
    legacyAcc = runOnShell("grep '^+' /etc/passwd /etc/shadow /etc/group")

    if "/etc/passwd" in legacyAcc:
        legacyAccount = ""
        userList = []
        with open("/etc/passwd", "r") as passwdFile:
            for legacyUserLine in passwdFile:
                if legacyUserLine.startswith("+"):
                    try:
                        GIDFromPasswd = legacyUserLine.split(":")[3].strip()
                        if GIDFromPasswd != "" and GIDFromPasswd.isdigit():
                            unameFromGroup = runOnShell("getent group " + GIDFromPasswd).split(":")[0]
                            if unameFromGroup == "":
                                logging("Removing the legacy entrie(s) " + legacyUserLine.split(":")[0] + " from /etc/passwd file.")
                                continue
                            logging ('Replacing the legacy user name ' + legacyUserLine.split(":")[0] + ' in "/etc/passwd" file with ' \
+ unameFromGroup + ' username from "/etc/group" file.')

                            unameFromPasswd = legacyUserLine.split(":")
                            unameFromPasswd[0] = unameFromGroup
                            userList.append(unameFromPasswd[0])
                            legacyAccount += ":".join(unameFromPasswd)
                        else:
                            logging("Removing the legacy entrie(s) " + legacyUserLine.split(":")[0] + " from /etc/passwd file.")
                    except (IndexError, ValueError):
                        logging("Removing the legacy entrie(s) " + legacyUserLine.split(":")[0] + " from /etc/passwd file.")
			continue
                else:
                    legacyAccount += legacyUserLine

    fout = open("/etc/passwd", 'wt')
    if fout != None:
        fout.write(legacyAccount)
        fout.close()

    duplicateEntries = ""
    # Deleting the legacy account after changing the username.
    if userList:
        for legacyUser in userList:
            logging("Deleting legacy account(s) " + legacyUser + ", to prevent the hackers to gain privileged access on the system.")
            if OsName.lower() == "ubuntu":
                userdelRes = runOnShell ("userdel " + legacyUser)
            else:
                userdelRes = runOnShell ("userdel -r " + legacyUser)

            if "cannot remove entry" in userdelRes:
                duplicateEntries += legacyUser + "\n"

    # If Legacy accounts in shadow, group files.
    if "/etc/shadow" in legacyAcc or "/etc/group" in legacyAcc:
        logging("Removing the legacy account(s) lines form '/etc/shadow', '/etc/group' file(s).")
        runOnShell("sed -i '/^+/ d' /etc/shadow /etc/group")

    # It is the intimation to the user for notifying duplicated user accounts
    if duplicateEntries != "":
        logging("The below mentioned duplicated user accounts are available on your system. Please manually handle/remove these users.\n" \
+ duplicateEntries)

def checkRule56002():
	flag_owner = True
	flag_group = True
	flag_permission = True
	logging('Checking the file path /etc/crontab exists or not.')
	if os.path.exists('/etc/crontab'):
		# Getting the file permission , ownership and group ownership.
		file_info = runOnShell('stat --format=%U,%G,%a /etc/crontab')
		file_info_list = file_info.translate(string.maketrans("\n\t\r", "   ")).strip(" ").split(",")
		#Converting string to octal.
		tmpOct = int(file_info_list[2],8)
		if not tokenMatch('root',file_info_list[0]):
			logging("Owner of the file is not root.")
			flag_owner = False
		if not tokenMatch('root',file_info_list[1]):
			logging("Group Owner of the file is not root.")
			flag_group = False
		if tmpOct & 0177:
			logging("File permission is not 600.")
			flag_permission = False
		#Checking any of the flag for permission , ownership and group ownership is false.
		if flag_owner and flag_group and flag_permission:
			logging('Permission, ownership and group ownership of /etc/crontab file is correctly configured.')
			return True
		else:
			return False
	logging('File path /etc/crontab does not exist.')
	return True

def fixRule56002():
	logging('Checking the file path /etc/crontab exists or not.')
	if os.path.exists('/etc/crontab'):
		# Getting the file permission , ownership and group ownership.
		file_info = runOnShell('stat --format=%U,%G,%a /etc/crontab')
		file_info_list = file_info.translate(string.maketrans("\n\t\r", "   ")).strip(" ").split(",")
		#Converting string to octal.
		tmpOct = int(file_info_list[2],8)
		if not tokenMatch('root',file_info_list[0]):
			runOnShell('chown root /etc/crontab')
		if not tokenMatch('root',file_info_list[1]):
			runOnShell('chgrp root /etc/crontab')
		if tmpOct & 0177:
			runOnShell('chmod 600 /etc/crontab')

def checkRule56003():
	flag_owner = True
	flag_group = True
	flag_permission = True
	logging('Checking the file path /etc/cron.weekly exists or not.')
	if os.path.exists('/etc/cron.weekly'):
		# Getting the file permission , ownership and group ownership.
		file_info = runOnShell('stat --format=%U,%G,%a /etc/cron.weekly')
		file_info_list = file_info.translate(string.maketrans("\n\t\r", "   ")).strip(" ").split(",")
		#Converting string to octal.
		tmpOct = int(file_info_list[2],8)
		if not tokenMatch('root',file_info_list[0]):
			logging("Owner of the file is not root.")
			flag_owner = False
		if not tokenMatch('root',file_info_list[1]):
			logging("Group Owner of the file is not root.")
			flag_group = False
		if tmpOct & 0077:
			logging("File permission is not 700.")
			flag_permission = False
		#Checking any of the flag for permission , ownership and group ownership is false.
		if flag_owner and flag_group and flag_permission:
			logging('Permission, ownership and group ownership of /etc/cron.weekly file is correctly configured.')
			return True
		else:
			return False
	logging('File path /etc/cron.weekly does not exist.')
	return True

def fixRule56003():
	logging('Checking the file path /etc/cron.weekly exists or not.')
	if os.path.exists('/etc/cron.weekly'):
		# Getting the file permission , ownership and group ownership.
		file_info = runOnShell('stat --format=%U,%G,%a /etc/cron.weekly')
		file_info_list = file_info.translate(string.maketrans("\n\t\r", "   ")).strip(" ").split(",")
		#Converting string to octal.
		tmpOct = int(file_info_list[2],8)
		if not tokenMatch('root',file_info_list[0]):
			runOnShell('chown root /etc/cron.weekly')
		if not tokenMatch('root',file_info_list[1]):
			runOnShell('chgrp root /etc/cron.weekly')
		if tmpOct & 0077:
			runOnShell('chmod 700 /etc/cron.weekly')

def checkRule56004():
	flag_owner = True
	flag_group = True
	flag_permission = True
	logging('Checking the file path /etc/cron.monthly exists or not.')
	if os.path.exists('/etc/cron.monthly'):
		# Getting the file permission , ownership and group ownership.
		file_info = runOnShell('stat --format=%U,%G,%a /etc/cron.monthly')
		file_info_list = file_info.translate(string.maketrans("\n\t\r", "   ")).strip(" ").split(",")
		#Converting string to octal.
		tmpOct = int(file_info_list[2],8)
		if not tokenMatch('root',file_info_list[0]):
			logging("Owner of the file is not root.")
			flag_owner = False
		if not tokenMatch('root',file_info_list[1]):
			logging("Group Owner of the file is not root.")
			flag_group = False
		if tmpOct & 0077:
			logging("File permission is not 700.")
			flag_permission = False
		#Checking any of the flag for permission , ownership and group ownership is false.
		if flag_owner and flag_group and flag_permission:
			logging('Permission, ownership and group ownership of /etc/cron.monthly file is correctly configured.')
			return True
		else:
			return False

	logging('File path does not exist.')
	return True

def fixRule56004():
	logging('Checking the file path /etc/cron.monthly exists or not.')
	if os.path.exists('/etc/cron.monthly'):
		# Getting the file permission , ownership and group ownership.
		file_info = runOnShell('stat --format=%U,%G,%a /etc/cron.monthly')
		file_info_list = file_info.translate(string.maketrans("\n\t\r", "   ")).strip(" ").split(",")
		#Converting string to octal.
		tmpOct = int(file_info_list[2],8)
		if not tokenMatch('root',file_info_list[0]):
			runOnShell('chown root /etc/cron.monthly')
		if not tokenMatch('root',file_info_list[1]):
			runOnShell('chgrp root /etc/cron.monthly')
		if tmpOct & 0077:
			runOnShell('chmod 700 /etc/cron.monthly')

def checkRule56005():
	flag_owner = True
	flag_group = True
	flag_permission = True
	logging('Checking the file path /etc/cron.hourly exists or not.')
	if os.path.exists('/etc/cron.hourly'):
		# Getting the file permission , ownership and group ownership.
		file_info = runOnShell('stat --format=%U,%G,%a /etc/cron.hourly')
		file_info_list = file_info.translate(string.maketrans("\n\t\r", "   ")).strip(" ").split(",")
		#Converting string to octal.
		tmpOct = int(file_info_list[2],8)
		if not tokenMatch('root',file_info_list[0]):
			logging("Owner of the file is not root.")
			flag_owner = False
		if not tokenMatch('root',file_info_list[1]):
			logging("Group Owner of the file is not root.")
			flag_group = False
		if tmpOct & 0077:
			logging("File permission is not 700.")
			flag_permission = False
		#Checking any of the flag for permission , ownership and group ownership is false.
		if flag_owner and flag_group and flag_permission:
			logging('Permission, ownership and group ownership of /etc/cron.hourly file is correctly configured.')
			return True
		else:
			return False
	logging('File path does not exist.')
	return True

def fixRule56005():
	logging('Checking the file path /etc/cron.hourly exists or not.')
	if os.path.exists('/etc/cron.hourly'):
		# Getting the file permission , ownership and group ownership.
		file_info = runOnShell('stat --format=%U,%G,%a /etc/cron.hourly')
		file_info_list = file_info.translate(string.maketrans("\n\t\r", "   ")).strip(" ").split(",")
		#Converting string to octal.
		tmpOct = int(file_info_list[2],8)
		if not tokenMatch('root',file_info_list[0]):
			runOnShell('chown root /etc/cron.hourly')
		if not tokenMatch('root',file_info_list[1]):
			runOnShell('chgrp root /etc/cron.hourly')
		if tmpOct & 0077:
			runOnShell('chmod 700 /etc/cron.hourly')

def checkRule56006():
	flag_owner = True
	flag_group = True
	flag_permission = True
	logging('Checking the file path /etc/cron.daily exists or not.')
	if os.path.exists('/etc/cron.daily'):
		# Getting the file permission , ownership and group ownership.
		file_info = runOnShell('stat --format=%U,%G,%a /etc/cron.daily')
		file_info_list = file_info.translate(string.maketrans("\n\t\r", "   ")).strip(" ").split(",")
		#Converting string to octal.
		tmpOct = int(file_info_list[2],8)
		if not tokenMatch('root',file_info_list[0]):
			logging("Owner of the file is not root.")
			flag_owner = False
		if not tokenMatch('root',file_info_list[1]):
			logging("Group Owner of the file is not root.")
			flag_group = False
		if tmpOct & 0077:
			logging("File permission is not 700.")
			flag_permission = False
		#Checking any of the flag for permission , ownership and group ownership is false.
		if flag_owner and flag_group and flag_permission:
			logging('Permission, ownership and group ownership of /etc/cron.daily file is correctly configured.')
			return True
		else:
			return False
	logging('File path does not exist.')
	return True

def fixRule56006():
	logging('Checking the file path /etc/cron.daily exists or not.')
	if os.path.exists('/etc/cron.daily'):
		# Getting the file permission , ownership and group ownership.
		file_info = runOnShell('stat --format=%U,%G,%a /etc/cron.daily')
		file_info_list = file_info.translate(string.maketrans("\n\t\r", "   ")).strip(" ").split(",")
		#Converting string to octal.
		tmpOct = int(file_info_list[2],8)
		if not tokenMatch('root',file_info_list[0]):
			runOnShell('chown root /etc/cron.daily')
		if not tokenMatch('root',file_info_list[1]):
			runOnShell('chgrp root /etc/cron.daily')
		if tmpOct & 0077:
			runOnShell('chmod 700 /etc/cron.daily')

def checkRule56007():
	flag_owner = True
	flag_group = True
	flag_permission = True
	logging('Checking the file path /etc/cron.d exists or not.')
	if os.path.exists('/etc/cron.d'):
		# Getting the file permission , ownership and group ownership.
		file_info = runOnShell('stat --format=%U,%G,%a /etc/cron.d')
		file_info_list = file_info.translate(string.maketrans("\n\t\r", "   ")).strip(" ").split(",")
		#Converting string to octal.
		tmpOct = int(file_info_list[2],8)
		if not tokenMatch('root',file_info_list[0]):
			logging("Owner of the file is not root.")
			flag_owner = False
		if not tokenMatch('root',file_info_list[1]):
			logging("Group Owner of the file is not root.")
			flag_group = False
		if tmpOct & 0077:
			logging("File permission is not 700.")
			flag_permission = False
		#Checking any of the flag for permission , ownership and group ownership is false.
		if flag_owner and flag_group and flag_permission:
			logging('Permission, ownership and group ownership of /etc/cron.d file is correctly configured.')
			return True
		else:
			return False
	logging('File path does not exist.')
	return True

def fixRule56007():
	logging('Checking the file path /etc/cron.d exists or not.')
	if os.path.exists('/etc/cron.d'):
		# Getting the file permission , ownership and group ownership.
		file_info = runOnShell('stat --format=%U,%G,%a /etc/cron.d')
		file_info_list = file_info.translate(string.maketrans("\n\t\r", "   ")).strip(" ").split(",")
		#Converting string to octal.
		tmpOct = int(file_info_list[2],8)
		if not tokenMatch('root',file_info_list[0]):
			runOnShell('chown root /etc/cron.d')
		if not tokenMatch('root',file_info_list[1]):
			runOnShell('chgrp root /etc/cron.d')
		if tmpOct & 0077:
			runOnShell('chmod 700 /etc/cron.d')

def checkRule56008():
	flag_owner = True
	flag_group = True
	flag_permission = True
	logging('Checking the file path /etc/anacrontab exists or not.')
	if os.path.exists('/etc/anacrontab'):
		# Getting the file permission , ownership and group ownership.
		file_info = runOnShell('stat --format=%U,%G,%a /etc/anacrontab')
		file_info_list = file_info.translate(string.maketrans("\n\t\r", "   ")).strip(" ").split(",")
		#Converting string to octal.
		tmpOct = int(file_info_list[2],8)
		if not tokenMatch('root',file_info_list[0]):
			logging("Owner of the file is not root.")
			flag_owner = False
		if not tokenMatch('root',file_info_list[1]):
			logging("Group Owner of the file is not root.")
			flag_group = False
		if tmpOct & 0177:
			logging("File permission is not 600.")
			flag_permission = False
		#Checking any of the flag for permission , ownership and group ownership is false.
		if flag_owner and flag_group and flag_permission:
			logging('Permission, ownership and group ownership of /etc/anacrontab file is correctly configured.')
			return True
		else:
			return False
	logging('File path does not exist.')
	return True

def fixRule56008():
	logging('Checking the file path /etc/anacrontab exists or not.')
	if os.path.exists('/etc/anacrontab'):
		# Getting the file permission , ownership and group ownership.
		file_info = runOnShell('stat --format=%U,%G,%a /etc/anacrontab')
		file_info_list = file_info.translate(string.maketrans("\n\t\r", "   ")).strip(" ").split(",")
		#Converting string to octal.
		tmpOct = int(file_info_list[2],8)
		if not tokenMatch('root',file_info_list[0]):
			runOnShell('chown root /etc/anacrontab')
		if not tokenMatch('root',file_info_list[1]):
			runOnShell('chgrp root /etc/anacrontab')
		if tmpOct & 0177:
			runOnShell('chmod 600 /etc/anacrontab')

def checkRule56009():
    ''' Description: Checking whether mount point /tmp is having nosuid optoin in /etc/fstab.'''

    if not check_fstab_config():
        return None

    nosuidFlag = False
    mount_option_list = ["nosuid", "group", "owner", "user", "users"]
    logging("Finding any entry that start with /tmp.")
    res = runOnShell('grep -w "/tmp" /etc/mtab /etc/fstab | grep -v ":\s*#"')
    if res == "":
        logging("/tmp directory is not mounted in /etc/fstab.")
        return True
    res = res.splitlines()
    for line in res:
        line = line.split(":")
        mountFileName = line[0]
        # Handling any space at the start of the line.
        line = line[1].translate(string.maketrans("\n\t\r", "   ")).strip()
        line = line.split(" ")
        line = filter(None, line)
        if not line:
            continue
        if mountFileName == "/etc/fstab" and ((OsVersion <= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
            try:
                if re.match(r'^tmpfs\b', line[0]) and re.match(r'^/tmp\b', line[1]) and ("user" in line[3] or "users" in line[3]):
                    nosuidFlag = True
                    break
            except:
                nosuidFlag = False
        if re.match(r'^/tmp\b', line[1]):
            try:
                mount_option = line[3].split(',') #Spliting the mount option to check nosuid option present or not.
                #Checking the mount option from right to left.
                for mount_index in xrange(len(mount_option) - 1, -1, -1):
                    ele = mount_option[mount_index]
                    if ele in mount_option_list:
                        nosuidFlag = True
                        break
                    elif "suid" == ele:
                        nosuidFlag = False
                        break
                    else:
                        pass
            except:
                nosuidFlag = False

    if not nosuidFlag:
        logging("/tmp partition mounted on system have entry in /etc/fstab with no 'nosuid' option. Please add 'nosuid' option for /tmp partition.")
        return False
    else:
    	logging("/tmp partitions mounted on system do not allow set-user-identifier or set-group-identifier bits to take effect.")
    	return True

def fixRule56009():
    ''' Description: Adding nosuid option to /tmp mount point entry in /etc/fstab.'''

    #Take bakeup of fstab file before fixing.
    file_config_backup("/etc/fstab")

    #Check for any configuration error in fstab file.
    if not check_fstab_config():
        return None

    # Updating the /etc/fstab file for /tmp mount option with nosuid option.
    lastLine = ""
    newLine = ""
    fstabFlag = False
    logging("Finding any entry that start with /tmp.")
    fileContent = open ("/etc/fstab", "r").readlines()
    for line in fileContent:
        if isL(line) and "/tmp" in line:
                fstabFlag = True
                if "Cloud Raxak updated next line" not in lastLine:
                    lastLine += "# Cloud Raxak updated next line\n"
                newLine += fix_fstab_conf(line,"nosuid","suid","/tmp")
        else:
            newLine += line
        lastLine = newLine

    if not fstabFlag:
        res = runOnShell('grep -w /tmp /etc/mtab | grep -v ":\s*#"')
        if "Cloud Raxak updated next line" not in lastLine:
            lastLine += "# Cloud Raxak updated next line\n"
        newLine += fix_fstab_conf(res,"nosuid","suid","/tmp")

    fout = None
    try:
        fout = open('/etc/fstab', 'wt')
        fout.write(newLine)
    finally:
        if (fout is not None):
            fout.close()

    logging("Changes made in fstab configuration file, remounting the /tmp partition for effecting the changes.")
    runOnShell("mount -o remount /tmp")

def checkRule56011():
    ''' Description: Checking whether mount point /tmp is having nodev optoin in /etc/fstab.'''

    if not check_fstab_config():
        return None

    nodevFlag = False
    mount_option_list = ["nodev", "group", "owner", "user", "users"]
    logging("Finding any entry that start with /tmp.")
    res = runOnShell('grep -w "/tmp" /etc/mtab /etc/fstab | grep -v ":\s*#"')
    if res == "":
        logging("/tmp directory is not mounted in /etc/fstab.")
        return True
    res = res.splitlines()
    for line in res:
        line = line.split(":")
        mountFileName = line[0]
        # Handling any space at the start of the line.
        line = line[1].translate(string.maketrans("\n\t\r", "   ")).strip()
        line = line.split(" ")
        line = filter(None, line)
        if not line:
            continue
        if mountFileName == "/etc/fstab" and ((OsVersion <= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
            try:
                if re.match(r'^tmpfs\b', line[0]) and re.match(r'^/tmp\b', line[1]) and ("user" in line[3] or "users" in line[3]):
                    nodevFlag = True
                    break
            except:
                nodevFlag = False
        if re.match(r'^/tmp\b', line[1]):
            try:
                mount_option = line[3].split(',') #Spliting the mount option to check nodev option present or not.
                #Checking the mount option from right to left.
                for mount_index in xrange(len(mount_option) - 1, -1, -1):
                    ele = mount_option[mount_index]
                    if ele in mount_option_list:
                        nodevFlag = True
                        break
                    elif "dev" == ele:
                        nodevFlag = None
                        break
                    else:
                        pass
            except:
                nodevFlag = False

    if not nodevFlag:
        logging("/tmp partition mounted on system have entry in /etc/fstab with no 'nodev' option. Please add 'nodev' option for /tmp partition.")
        return False
    else:
        logging("/tmp partitions mounted on system do not interpret character or block special devices on the file system.")
        return True

def fixRule56011():
    ''' Description: Adding nodev option to /tmp mount point entry in /etc/fstab.'''

    #Take bakeup of fstab file before fixing.
    file_config_backup("/etc/fstab")

    #Check for any configuration error in fstab file.
    if not check_fstab_config():
        return None

    # Updating the /etc/fstab file for /tmp mount option with nodev option.
    lastLine = ""
    newLine = ""
    nodevlag = False
    logging("Finding any entry that start with /tmp.")
    fileContent = open ("/etc/fstab", "r").readlines()
    for line in fileContent:
        if isL(line) and "/tmp" in line:
                nodevlag = True
                if "Cloud Raxak updated next line" not in lastLine:
                    lastLine += "# Cloud Raxak updated next line\n"
                newLine += fix_fstab_conf(line,"nodev","dev","/tmp")
        else:
            newLine += line
        lastLine = newLine

    if not nodevlag:
        res = runOnShell('grep -w /tmp /etc/mtab | grep -v ":\s*#"')
        if "Cloud Raxak updated next line" not in lastLine:
            lastLine += "# Cloud Raxak updated next line\n"
        newLine += fix_fstab_conf(res,"nodev","dev","/tmp")

    fout = None
    try:
        fout = open('/etc/fstab', 'wt')
        fout.write(newLine)
    finally:
        if (fout is not None):
            fout.close()

    logging("Changes made in fstab configuration file, remounting the /tmp partition for effecting the changes.")
    runOnShell("mount -o remount /tmp")

def checkRule56012():
	''' This rule intends to disable the core dumps '''	
	if not os.path.exists('/etc/sysctl.conf'):
		logging("/etc/sysctl.conf file does not exist , fix it manually to disable the core dump parameter.")
		return None

	logging("Checking if kernel parameter is disabled.")
	if OsName.lower() == "amazon linux ami":
		core_dump_value = runOnShell("sysctl 'fs.suid_dumpable' | grep -w 'fs.suid_dumpable = 0'")
	else:
		core_dump_value = runOnShell("sysctl -a | grep -w 'fs.suid_dumpable = 0'")
	if core_dump_value == "":
		logging("Core dump parameter is enabled.")
		return False

	logging("Loading the setting defined during boot time to verify the Core dump after system reboot.")
	reboot_value = runOnShell("grep -w 'fs.suid_dumpable = 0' /etc/sysctl.conf | grep -v '^#'")
	reboot_value = reboot_value.translate(string.maketrans("\n\t\r", "   "))
	if reboot_value == "":
		logging("Core dump setting is not configured.")
	        return False

	if keyValEqMatch_new("fs.suid_dumpable","0",reboot_value):
		logging("Core dump parameter is disabled.")
		return True
	else:
		logging("Core dump parameter is enabled.")
		return False

def fixRule56012():
	logging("Disabling the core dump parameter.")
	#Disabling  the parameter value at runtime.
	runOnShell("sysctl -w fs.suid_dumpable=0")
	try:
		#Disabling the parameter value permanently.
		file_data = ""
		with open("/etc/sysctl.conf", "r") as filehandler:
		    flag = False
		    lastLine = ""
		    for line in filehandler:
		        if isL(line) and "fs.suid_dumpable" in line:
		            if not tokenMatch('Cloud Raxak updated next line',lastLine):
		                file_data += "# Cloud Raxak updated next line\n"
		            file_data += "fs.suid_dumpable = 0\n"
		            flag = True
		        else:
		            file_data += line
		            lastLine = line
		    if not(flag):
		        file_data += "# Cloud Raxak updated next line\n"
		        file_data += "fs.suid_dumpable = 0\n"

		fout = open("/etc/sysctl.conf", 'wt')
		fout.write(file_data)
		fout.close()
	
	except IOError:
		logging("/etc/sysctl.conf file does not exist.")

def checkRule56013():
    logging("Checking for cron.deny file in the system, which restrict access to cron.")
    if os.path.exists('/etc/cron.deny'):
        logging('File /etc/cron.deny exists in the system.')
        return False
    else:
        logging('File /etc/cron.deny does not exist in the system.')
        return True

def fixRule56013():
    logging("Removing file /etc/cron.deny from the system.")
    #Performing the remove operation.
    runOnShell("rm -f /etc/cron.deny")

def checkRule56014():
	flag_owner = True
	flag_group = True
	flag_permission = True
	logging('Checking the file path /etc/cron.allow exists or not.')
	if os.path.exists('/etc/cron.allow'):
		# Getting the file permission , ownership and group ownership.
		file_info = runOnShell('stat --format=%U,%G,%a /etc/cron.allow')
		file_info_list = file_info.translate(string.maketrans("\n\t\r", "   ")).strip(" ").split(",")
		#Converting string to octal.
		tmpOct = int(file_info_list[2],8)
		if not tokenMatch('root',file_info_list[0]):
			logging("Owner of the file is not root.")
			flag_owner = False
		if not tokenMatch('root',file_info_list[1]):
			logging("Group Owner of the file is not root.")
			flag_group = False
		if tmpOct & 0177:
			logging("File permission is not 600.")
			flag_permission = False
		#Checking any of the flag for permission , ownership and group ownership is false.
		if flag_owner and flag_group and flag_permission:
			logging('Permission, ownership and group ownership of /etc/cron.allow file is correctly configured.')
			return True
		else:
			return False
	logging('File path does not exist.')
	return True

def fixRule56014():
	logging('Checking the file path /etc/cron.allow exists or not.')
	if os.path.exists('/etc/cron.allow'):
		# Getting the file permission , ownership and group ownership.
		file_info = runOnShell('stat --format=%U,%G,%a /etc/cron.allow')
		file_info_list = file_info.translate(string.maketrans("\n\t\r", "   ")).strip(" ").split(",")
		#Converting string to octal.
		tmpOct = int(file_info_list[2],8)
		if not tokenMatch('root',file_info_list[0]):
			runOnShell('chown root /etc/cron.allow')
		if not tokenMatch('root',file_info_list[1]):
			runOnShell('chgrp root /etc/cron.allow')
		if tmpOct & 0177:
			runOnShell('chmod 600 /etc/cron.allow')

def checkRule56015():
    logging("Checking for at.deny file in the system. Users listed in the at.deny file cannot use 'at' to \
schedule jobs or to check the 'at queue status'.")
    if os.path.exists('/etc/at.deny'):
        logging('File /etc/at.deny exists in the system.')
        return False
    else:
        logging('File /etc/at.deny does not exist in the system.')
        return True

def fixRule56015():
    logging("Removing file /etc/at.dieny from the system.")
#   Performing the remove operation.
    runOnShell("rm -f /etc/at.deny")


def checkRule56016():
	flag_owner = True
	flag_group = True
	flag_permission = True
	logging('Checking the file path /etc/at.allow exists or not.')
	if os.path.exists('/etc/at.allow'):
		# Getting the file permission , ownership and group ownership.
		file_info = runOnShell('stat --format=%U,%G,%a /etc/at.allow')
		file_info_list = file_info.translate(string.maketrans("\n\t\r", "   ")).strip(" ").split(",")
		#Converting string to octal.
		tmpOct = int(file_info_list[2],8)
		if not tokenMatch('root',file_info_list[0]):
			logging("Owner of the file is not root.")
			flag_owner = False
		if not tokenMatch('root',file_info_list[1]):
			logging("Group Owner of the file is not root.")
			flag_group = False
		if tmpOct & 0177:
			logging("File permission is not 600.")
			flag_permission = False
		#Checking any of the flag for permission , ownership and group ownership is false.
		if flag_owner and flag_group and flag_permission:
			logging('Permission, ownership and group ownership of at.allow file is correctly configured.')
			return True
		else:
			return False
	logging('File path does not exist.')
	return True

def fixRule56016():
	logging('Checking the file path /etc/at.allow exists or not.')
	if os.path.exists('/etc/at.allow'):
		# Getting the file permission , ownership and group ownership.
		file_info = runOnShell('stat --format=%U,%G,%a /etc/at.allow')
		file_info_list = file_info.translate(string.maketrans("\n\t\r", "   ")).strip(" ").split(",")
		#Converting string to octal.
		tmpOct = int(file_info_list[2],8)
		if not tokenMatch('root',file_info_list[0]):
			runOnShell('chown root /etc/at.allow')
		if not tokenMatch('root',file_info_list[1]):
			runOnShell('chgrp root /etc/at.allow')
		if tmpOct & 0177:
			runOnShell('chmod 600 /etc/at.allow')

def checkRule56017():
	if OsName.lower() == "redhat" or OsName.lower() == "centos" or OsName.lower() == "amazon linux ami":
		if CheckPackage("setroubleshoot") or CheckPackage("setroubleshoot-server"):
			return False
		else:
			return True
	elif OsName.lower() == "ubuntu":
		if CheckPackage("selinux") or CheckPackage("selinux-basics"):
			return False
		else:
			return True
	else:
		logging("Currently not supporting this operating system: " + OsName.lower())
		return 3

def fixRule56017():
	if OsName.lower() == "ubuntu":
		logging("Uninstalling SElinux package from the system.")
		# SElinux is unstable on Ubuntu distributions, so remove this package completely.
		if CheckPackage("selinux"):
                        # DEBIAN_FRONTEND=noninteractive is used to suppress the debconf errors that appear in the console log.
			checkDpkg = runOnShell('DEBIAN_FRONTEND=noninteractive apt-get -y purge selinux', False)
		else:
			checkDpkg = runOnShell('DEBIAN_FRONTEND=noninteractive apt-get -y purge selinux-basics', False)
		if "dpkg was interruped" in checkDpkg:
			logging("dpkg is not properly configured, dpkg needs to be properly configured using command 'dpkg --configure -a'. Please fix it manually.")
			return None
	else:
		logging("Uninstalling SETroubleshoot package from the system.")
		# If setroubleshoot is installed, remove setroubleshoot-server also because if we remove only setroubleshoot, 
		# functionality of SElinux still works with setroubleshoot-server installed.
		if CheckPackage("setroubleshoot"):
			runOnShell('rpm -e setroubleshoot --nodeps;rpm -e setroubleshoot-server --nodeps')
		else:
			runOnShell('rpm -e setroubleshoot-server --nodeps')

def checkRule56018():
    '''checking if password fields are empty in sgadow file.'''
    res = runOnShell("grep '^[^:]*::' /etc/shadow | cut -d: -f1")
    if res:
        res = res.split("\n")
        res = ",".join(res).strip(',')
        logging("The " + res + " user(s) does not have password, hence please check it manually.")
        return None
    else:
        logging("Password fields are not empty.")
        return True

def fixRule56018():
    '''Sending rule to manual if found password field is empty.'''
    res = runOnShell("grep '^[^:]*::' /etc/shadow | cut -d: -f1")
    if res:
        res = res.split("\n")
        res = ",".join(res).strip(',')
        logging("The " + res + " user(s) does not have password, So create the password for " + res + " user(s) manually.")
        return None

def checkRule56019():
    '''Description: Checking the accounts and home directories. '''
    logging("Checking the users home directories.")
    homeDirList = runOnShell("awk -F: '$3>=" + str(uid_value) + "&& $3<=" + str(uid_max_value ) + "{print $1, $6}' /etc/passwd", False).splitlines()
    dirStr = ""
    for dirPath in homeDirList:
        # Checking home directory in passwd file.
        dirPath = dirPath.split()
        if len(dirPath) != 2 or not os.path.exists(dirPath[1]):
            dirStr += ", " + dirPath[0]
    if dirStr:
        logging("The " + dirStr.lstrip(',') + " user(s) has no valid home directory specified in /etc/passwd, please check it manually.")
        return None
    logging("The user(s) has valid home directory specified in /etc/passwd.")
    return True

def fixRule56019():
    logging("At present, we are not providing fix for this rule. If the user home directorie do not exist, create them and make sure the respective user owns the directory as manually.")
    return None

def checkRule56020():
    ''' Description: Checking /var/tmp directory is bind mounted on /tmp in /etc/fstab file. '''

    #checking for any configuration error in file.(Any entry with less than 6 column.)
    fstabAllEntries = open ("/etc/fstab", 'r').readlines()
    for line in fstabAllEntries:
        if isL(line):
            line = line.translate(string.maketrans("\n\t\r", "   ")).strip().split()
            if len(line) < 3:
                 logging ("The below mentioned fstab configuration file entry has less than 3 columns which is wrong configuration. \
Please fix it manually.\n{0}".format (" ".join (line)))
                 return None
            elif len(line) > 3:
                optionList = line[3].split(",")
                if any (re.match ("^\d+", option) for option in optionList):
                    logging ("The below mentioned entry has integer option. Please fix it manually.\n{0}".format (" ".join (line)))
                    return None

    if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
        res = runOnShell("grep -w ^/var/tmp /etc/fstab | grep -w bind | grep -v '^#'")
    else:
        res = runOnShell("grep -w ^/var/tmp /etc/fstab /etc/mtab | grep -w bind | grep -v ':\s*#'")
    if not res:
        logging("/var/tmp directory is not mounted to /tmp with bind option.")
        return False
    else:
        #For centos7 check only /etc/fstab file.
        if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
            bindEntry = runOnShell("findmnt -l |egrep '\[/tmp\]|\[/var/tmp\]'|cut -d' ' -f1|egrep '\/tmp|\/var\/tmp'")
            if "/tmp" in bindEntry:
                logging("/var/tmp directory is mounted to /tmp with bind option.")
                return True
            logging("/var/tmp directory is not mounted properly to /tmp.")
            return False
        else:
            #Checking for mount bind entry in both the files fstab and mtab.
            flagForMtab = False
            flagForFstab = False
            for line in res.splitlines():
                if line.startswith('/etc/mtab'):
                    flagForMtab = True
                if line.startswith('/etc/fstab'):
                    flagForFstab = True
            if not flagForMtab or not flagForFstab:
                logging("/var/tmp directory is not mounted properly to /tmp.")
                return False
            else:
                logging("/var/tmp directory is mounted to /tmp with bind option.")
                return True

def fixRule56020():
    ''' Description: Mounting /var/tmp to /tmp directory. '''

    filename = "/etc/fstab"
    # Taking backup of fstab file.
    fileContent = open (filename, "r").readlines()
    timestamp = time.strftime("%Y%m%d-%H%M")
    fstabBackupFile = filename + timestamp
    shutil.copyfile(filename,fstabBackupFile)

    #checking for any configuration error in file.(Any entry with less than 6 column.)
    for line in fileContent:
        if isL(line):
             line = line.translate(string.maketrans("\n\t\r", "   ")).strip().split()
             if len(line) < 3:
                  logging ("The below mentioned fstab configuration file entry has less than 3 columns which is wrong configuration. \
Please fix it manually.\n{0}".format (" ".join (line)))
                  return None
             #Checking for any configuration error in file.(any device with wrong mounting point.)
             elif len(line) > 3:
                  optionList = line[3].split(",")
                  if any (re.match ("^\d+", option) for option in optionList):
                     logging ("The below mentioned entry has integer option. Please fix it manually.\n{0}".format (" ".join (line)))
                     return None

    #checking any entry present in fstab and mtab.
    caseFlag = False
    if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
        bindFlag = False
        res = runOnShell("grep -w ^/var/tmp /etc/fstab | grep -v '^#'")
        bindEntry = runOnShell("findmnt -l |egrep '\[/tmp\]|\[/var/tmp\]'|cut -d' ' -f1|egrep '\/tmp|\/var\/tmp'")
        #/var/tmp mounted on system but entry missing in fstab.
        if not res and bindEntry:
            bindFlag = True
        #/var/tmp not mounted and entry missing in fstab.
        elif not res and not bindEntry:
            bindFlag = True
            runOnShell("mount --bind /var/tmp /tmp")
        #Adding /var/tmp entry in fstab.
        if bindFlag:
            caseFlag = True
            line = "/var/tmp /tmp xfs bind 0 0"
            runOnShell("sh -c \"echo '" + line + "' >> /etc/fstab\"")
    else:
        res = runOnShell("grep -w ^/var/tmp /etc/fstab /etc/mtab | grep -v ':\s*#'")
        #No entry in fstab and mtab.
        if not res:
            #Bind mounting the /var/tmp to /tmp directory.
            caseFlag = True
            runOnShell("mount --bind /var/tmp /tmp")
            runOnShell("sh -c 'tail -1 /etc/mtab >> /etc/fstab'")
        #If entry is present in any one file.
        else:
            flagForMtab = False
            flagForFstab = False
            for line in res.splitlines():
                if line.startswith('/etc/mtab'):
                    flagForMtab = True
                    mtabEntry = line.split(":")[1]
                if line.startswith('/etc/fstab'):
                   flagForFstab = True
            # If entry is present in mtab but not in fstab.
            if flagForMtab == True and flagForFstab == False:
                runOnShell("sh -c \"echo '" + mtabEntry + "' >> /etc/fstab\"")
                caseFlag = True

    if not caseFlag:
        lastLine = ""
        flag = True
        nosuidlag = False
        logging("Finding any entry that start with /var/tmp")
        newLine = ""
        for line in fileContent:
            if isL(line):
                if "/var/tmp" in line:
                    # Handling any space at the start of the line.
                    line = line.translate(string.maketrans("\n\t\r", "   ")).strip()
                    line = line.split(" ")
                    line = filter(None, line)
                    if not line:
                        continue
                    if "/tmp" in line[1]:
                        nosuidlag = False
                        optionList = []
                        try:
                            mountOption = line[3].split(',') #Spliting the mount option to check nosuid option present or not.
                            #Checking the mount option from right to left.
                            optionList = [ele for ele in mountOption if (ele != "bind")]
                        except:
                            pass
                        optionList.append('bind')
                        logging("Adding bind option to the line.")
                        if len(line) > 3:
                            if len(line) == 4:
                               line.append("0")
                            if len(line) == 5:
                               line.append("0")
                            if "Cloud Raxak updated next line" not in lastLine:
                                lastLine += "# Cloud Raxak updated next line\n"
                            newLine += line[0] + " " + line[1] + " "  + line[2] + " " + ",".join(optionList) + " " + line[4] + " " + line[5] + "\n"
                        elif len(line) == 3:
                            if "Cloud Raxak updated next line" not in lastLine:
                                lastLine += "# Cloud Raxak updated next line\n"
                            newLine += line[0] + " " + line[1] + " "  + line[2] + " " + ",".join(optionList) + " 0 0" + "\n"
                else:
                    newLine += line
            else:
                newLine += line

        fout = None
        try:
            fout = open(filename, 'wt')
            fout.write(newLine)
        finally:
            if (fout is not None):
                fout.close()

        # In case of mounted and if entry is wrong we need to remount the /tmp directory.
        if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
            runOnShell("mount -a")
        else:
            logging("Changes made in fstab configuration file, mounting the /tmp partition for effecting the changes.")
            if flagForMtab and flagForFstab:
                runOnShell("mount -o remount /tmp")
            else:
                runOnShell("mount /tmp")

def checkRule56021():
    ''' Description: Checking whether mount point /dev/shm is having nosuid optoin in /etc/fstab.'''

    if not check_fstab_config():
        return None

    if OsName.lower() == 'ubuntu':
        mountPoint = "/run/shm"
    else:
        mountPoint = "/dev/shm"
    nosuidFlag = False
    mount_option_list = ["nosuid", "group", "owner", "user", "users"]
    logging("Finding any entry that start with " + mountPoint + ".")
    res = runOnShell('grep -w ' + mountPoint + ' /etc/mtab /etc/fstab | grep -v ":\s*#"')
    if res == "":
        logging(mountPoint+" directory is not mounted in /etc/fstab.")
        return True
    res = res.splitlines()
    for line in res:
        line = line.split(":")
        mountFileName = line[0]
        # Handling any space at the start of the line.
        line = line[1].translate(string.maketrans("\n\t\r", "   ")).strip()
        line = line.split(" ")
        line = filter(None, line)
        if not line:
            continue
        if mountFileName == "/etc/fstab" and ((OsVersion <= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
            try:
                if re.match(r'^tmpfs\b', line[0]) and mountPoint in line[1] and ("user" in line[3] or "users" in line[3]):
                    nosuidFlag = True
                    break
            except:
                nosuidFlag = False
        if mountPoint in line[1]:
            try:
                mount_option = line[3].split(',') #Spliting the mount option to check nosuid option present or not.
                #Checking the mount option from right to left.
                for mount_index in xrange(len(mount_option) - 1, -1, -1):
                    ele = mount_option[mount_index]
                    if ele in mount_option_list:
                        nosuidFlag = True
                        break
                    elif "suid" == ele:
                        nosuidFlag = False
                        break
                    else:
                        pass
            except:
                nosuidFlag = False

    if not nosuidFlag:
        logging(mountPoint + " partition mounted on system does not have nosuid option.")
        return False
    else:
        logging(mountPoint+" partitions mounted on system do not allow set-user-identifier or \
set-group-identifier bits to take effect.")
        return True

def fixRule56021():
    ''' Description: Adding nosuid option to /dev/shm mount point entry in /etc/fstab.'''

    #Take bakeup of fstab file before fixing.
    file_config_backup("/etc/fstab")

    #Check for any configuration error in fstab file.
    if not check_fstab_config():
        return None

    # Updating the /etc/fstab file for /dev/shm mount option with nosuid option.
    if OsName.lower() == 'ubuntu':
        mountPoint = "/run/shm"
    else:
        mountPoint = "/dev/shm"
    lastLine = ""
    newLine = ""
    fstabFlag = False
    logging("Finding any entry that start with " + mountPoint + ".")
    fileContent = open ("/etc/fstab", "r").readlines()
    for line in fileContent:
        if isL(line) and mountPoint in line:
                fstabFlag = True
                if "Cloud Raxak updated next line" not in lastLine:
                    lastLine += "# Cloud Raxak updated next line\n"
                newLine += fix_fstab_conf(line,"nosuid","suid",mountPoint)
        else:
            newLine += line
        lastLine = newLine

    if not fstabFlag:
        res = runOnShell('grep -w ' + mountPoint + ' /etc/mtab | grep -v ":\s*#"')
        if "Cloud Raxak updated next line" not in lastLine:
            lastLine += "# Cloud Raxak updated next line\n"
        newLine += fix_fstab_conf(res,"nosuid","suid",mountPoint)

    fout = None
    try:
        fout = open('/etc/fstab', 'wt')
        fout.write(newLine)
    finally:
        if (fout is not None):
            fout.close()

    logging("Changes made in fstab configuration file, remounting the " + mountPoint + " partition for effecting the changes.")
    runOnShell("mount -o remount " + mountPoint)

def checkRule56022():
    '''Description: Checking whether mount point /dev/shm is having noexec optoin in /etc/fstab.'''

    if not check_fstab_config():
        return None

    if OsName.lower() == 'ubuntu':
        mountPoint = "/run/shm"
    else:
        mountPoint = "/dev/shm"
    noexecFlag = False
    mount_option_list = ["noexec", "user", "users"]
    logging("Finding any entry that start with " + mountPoint + ".")
    res = runOnShell('grep -w ' + mountPoint + ' /etc/mtab /etc/fstab | grep -v ":\s*#"')
    if res == "":
        logging(mountPoint + " directory is not mounted in /etc/fstab.")
        return True
    res = res.splitlines()
    for line in res:
        line = line.split(":")
        mountFileName = line[0]
        # Handling any space at the start of the line.
        line = line[1].translate(string.maketrans("\n\t\r", "   ")).strip()
        line = line.split(" ")
        line = filter(None, line)
        if not line:
            continue
        if mountFileName == "/etc/fstab" and ((OsVersion <= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
            try:
                if re.match(r'^tmpfs\b', line[0]) and mountPoint in line[1] and ("user" in line[3] or "users" in line[3]):
                    noexecFlag = True
                    break
            except:
                noexecFlag = False
        if mountPoint in line[1]:
            noexecFlag = False
            try:
                mount_option = line[3].split(',') #Spliting the mount option to check noexec option present or not.
                #Checking the mount option from right to left.
                for mount_index in xrange(len(mount_option) - 1, -1, -1):
                    ele = mount_option[mount_index]
                    if ele in mount_option_list:
                        noexecFlag = True
                        break
                    elif "exec" == ele:
                        noexecFlag = False
                        break
                    else:
                        pass
            except:
                noexecFlag = False

    if not noexecFlag:
        logging(mountPoint + " partition mounted on system have entry in /etc/fstab without 'noexec' option. \
\nPlease add 'noexec' option for /tmp partition.")
        return False
    else:
        logging(mountPoint+" partitions mounted on system do not have the ability to execute binary files.")
        return True

def fixRule56022():
    ''' Description: Adding noexec option to /dev/shm mount point entry in /etc/fstab.'''

    #Take bakeup of fstab file before fixing.
    file_config_backup("/etc/fstab")

    #Check for any configuration error in fstab file.
    if not check_fstab_config():
        return None

    # Updating the /etc/fstab file for /dev/shm mount option with noexec option.
    if OsName.lower() == 'ubuntu':
        mountPoint = "/run/shm"
    else:
        mountPoint = "/dev/shm"
    lastLine = ""
    newLine = ""
    fstabFlag = False
    logging("Finding any entry that start with " + mountPoint + ".")
    fileContent = open ("/etc/fstab", "r").readlines()
    for line in fileContent:
        if isL(line) and mountPoint in line:
                fstabFlag = True
                if "Cloud Raxak updated next line" not in lastLine:
                    lastLine += "# Cloud Raxak updated next line\n"
                newLine += fix_fstab_conf(line,"noexec","exec",mountPoint)
        else:
            newLine += line
        lastLine = line

    if not fstabFlag:
        res = runOnShell('grep -w ' + mountPoint + ' /etc/mtab | grep -v ":\s*#"')
        if "Cloud Raxak updated next line" not in lastLine:
            lastLine += "# Cloud Raxak updated next line\n"
        newLine += fix_fstab_conf(res,"noexec","exec",mountPoint)

    fout = None
    try:
        fout = open('/etc/fstab', 'wt')
        fout.write(newLine)
    finally:
        if (fout is not None):
            fout.close()

    logging("Changes made in fstab configuration file, remounting the " + mountPoint + " partition for effecting the changes.")
    runOnShell("mount -o remount " + mountPoint)

def checkRule56023():
    ''' Description: Checking whether mount point /home is having nodev optoin in /etc/fstab.'''

    if not check_fstab_config():
        return None

    nodevFlag = False
    mount_option_list = ["nodev", "group", "owner", "user", "users"]
    logging("Finding any entry that start with /home.")
    res = runOnShell('grep -w /home /etc/mtab /etc/fstab | grep -v ":\s*#"')
    if res == "":
        logging("/home directory is not mounted in /etc/fstab.")
        return True
    res = res.splitlines()
    for line in res:
        line = line.split(":")
        mountFileName = line[0]
        # Handling any space at the start of the line.
        line = line[1].translate(string.maketrans("\n\t\r", "   ")).strip()
        line = line.split(" ")
        line = filter(None, line)
        if not line:
            continue
        if mountFileName == "/etc/fstab" and ((OsVersion <= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
            try:
                if re.match(r'^tmpfs\b', line[0]) and re.match(r'^/home\b', line[1]) and ("user" in line[3] or "users" in line[3]):
                    nodevFlag = True
                    break
            except:
                nodevFlag = False
        if re.match(r'^/home\b', line[1]):
            try:
                mount_option = line[3].split(',') #Spliting the mount option to check nodev option present or not.
                #Checking the mount option from right to left.
                for mount_index in xrange(len(mount_option) - 1, -1, -1):
                    ele = mount_option[mount_index]
                    if ele in mount_option_list:
                        nodevFlag = True
                        break
                    elif "dev" == ele:
                        nodevFlag = False
                        break
                    else:
                        pass
            except:
                nodevFlag = False

    if not nodevFlag:
        logging("/home partition mounted on system have entry in /etc/fstab without 'nodev' option. \
\nPlease add 'nodev' option for /home partition.")
        return False
    else:
        logging("/home partitions mounted on system do not interpret character or block special devices on the file system.")
        return True

def fixRule56023():
    ''' Description: Adding nodev option to /home mount point entry in /etc/fstab.'''

    #Take bakeup of fstab file before fixing.
    file_config_backup("/etc/fstab")

    #Check for any configuration error in fstab file.
    if not check_fstab_config():
        return None

    # Updating the /etc/fstab file for /home mount option with nodev option.
    lastLine = ""
    newLine = ""
    nodevFlag = False
    logging("Finding any entry that start with /home.")
    fileContent = open ("/etc/fstab", "r").readlines()
    for line in fileContent:
        if isL(line) and "/home" in line:
                nodevFlag = True
                if "Cloud Raxak updated next line" not in lastLine:
                    lastLine += "# Cloud Raxak updated next line\n"
                newLine += fix_fstab_conf(line,"nodev","dev","/home")
        else:
            newLine += line
        lastLine = line

    if not nodevFlag:
        res = runOnShell('grep -w /home /etc/mtab | grep -v ":\s*#"')
        if "Cloud Raxak updated next line" not in lastLine:
            lastLine += "# Cloud Raxak updated next line\n"
        newLine += fix_fstab_conf(res,"nodev","dev","/home")

    fout = None
    try:
        fout = open('/etc/fstab', 'wt')
        fout.write(newLine)
    finally:
        if (fout is not None):
            fout.close()

    logging("Changes made in fstab configuration file, remounting the /home partition for effecting the changes.")
    runOnShell("mount -o remount /home")

def checkRule56024():
    ''' Description: Checking whether mount point /dev/shm is having nodev optoin in /etc/fstab.'''

    if not check_fstab_config():
        return None

    if OsName.lower() == 'ubuntu':
        mountPoint = "/run/shm"
    else:
        mountPoint = "/dev/shm"
    nodevFlag = False
    mount_option_list = ["nodev", "group", "owner", "user", "users"]
    logging("Finding any entry that start with " + mountPoint + ".")
    res = runOnShell('grep -w ' + mountPoint + ' /etc/mtab /etc/fstab | grep -v ":\s*#"')
    if res == "":
        logging(mountPoint + " directory is not mounted in /etc/fstab.")
        return True
    res = res.splitlines()
    for line in res:
        line = line.split(":")
        mountFileName = line[0]
        # Handling any space at the start of the line.
        line = line[1].translate(string.maketrans("\n\t\r", "   ")).strip()
        line = line.split(" ")
        line = filter(None, line)
        if not line:
            continue
        if mountFileName == "/etc/fstab" and ((OsVersion <= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
            try:
                if re.match(r'^tmpfs\b', line[0]) and mountPoint in line[1] and ("user" in line[3] or "users" in line[3]):
                    nodevFlag = True
                    break
            except:
                nodevFlag = False
        if mountPoint in line[1]:
            try:
                mount_option = line[3].split(',') #Spliting the mount option to check nodev option present or not.
                #Checking the mount option from right to left.
                for mount_index in xrange(len(mount_option) - 1, -1, -1):
                    ele = mount_option[mount_index]
                    if ele in mount_option_list:
                        nodevFlag = True
                        break
                    elif "dev" == ele:
                        nodevFlag = False
                        break
                    else:
                        pass
            except:
                nodevFlag = False

    if not nodevFlag:
        logging(mountPoint + " partition mounted on system have entry in /etc/fstab without 'nodev' option. \
\nPlease add 'nodev' option for /dev/shm partition.")
        return False
    else:
        logging("nodev option is applied on " + mountPoint + " partition.")
        return True


def fixRule56024():
    ''' Description: Adding nodev option to /dev/shm mount point entry in /etc/fstab.'''

    #Take bakeup of fstab file before fixing.
    file_config_backup("/etc/fstab")

    #Check for any configuration error in fstab file.
    if not check_fstab_config():
        return None

    # Updating the /etc/fstab file for /dev/shm mount option with nodev option.
    if OsName.lower() == 'ubuntu':
        mountPoint = "/run/shm"
    else:
        mountPoint = "/dev/shm"
    lastLine = ""
    newLine = ""
    fstabFlag = False
    logging("Finding any entry that start with " + mountPoint + ".")
    fileContent = open ("/etc/fstab", "r").readlines()
    for line in fileContent:
        if isL(line) and mountPoint in line:
                fstabFlag = True
                if "Cloud Raxak updated next line" not in lastLine:
                    lastLine += "# Cloud Raxak updated next line\n"
                newLine += fix_fstab_conf(line,"nodev","dev",mountPoint)
        else:
            newLine += line
        lastLine = newLine

    if not fstabFlag:
        res = runOnShell('grep -w ' + mountPoint + ' /etc/mtab | grep -v ":\s*#"')
        if "Cloud Raxak updated next line" not in lastLine:
            lastLine += "# Cloud Raxak updated next line\n"
        newLine += fix_fstab_conf(res,"nodev","dev",mountPoint)

    fout = None
    try:
        fout = open('/etc/fstab', 'wt')
        fout.write(newLine)
    finally:
        if (fout is not None):
            fout.close()

    logging("Changes made in fstab configuration file, remounting the " + mountPoint + " partition for effecting the changes.")
    runOnShell("mount -o remount " + mountPoint)

def checkRule56025():
    if checkSSHDSyntax() == None:
        return None
    maxAuthVal = 4
    minAuthVal = 0
    maxAuth = runOnShell('grep -iw MaxAuthTries /etc/ssh/sshd_config  | grep -v "^#" | awk -F" " \'{ print $2 }\'')
    try:
        if int(maxAuth) <= maxAuthVal and maxAuth > minAuthVal:
           logging("'MaxAuthTries' parameter is correctly configured.")
           return True
        else:
           logging("'MaxAuthTries' parameter value is not correctly configured.")
           return False
    except (ValueError):
        logging("'MaxAuthTries' parameter is not correctly configured.")
        return False

def fixRule56025():
    if checkSSHDSyntax() == None:
        return None

    lastLine = ""
    fileString = ""
    updatelog = False
    fileSplit = open("/etc/ssh/sshd_config").readlines()
    logging("Updating the value of MaxAuthTries in ssh configuration.")
    for line in fileSplit:
        if isL(line) and tokenMatchIC("MaxAuthTries", line):
            if not updatelog:
                if not tokenMatch("Cloud Raxak updated next line", lastLine):
                    fileString += "# Cloud Raxak updated next line\n"
                fileString += "MaxAuthTries 4\n"
                updatelog = True
        else:
            fileString += line
            lastLine = line

    if not(updatelog):
        if not tokenMatch("Cloud Raxak updated next line", lastLine):
            fileString += "\n# Cloud Raxak updated next line\n"
        fileString += "MaxAuthTries 4\n"

    fout = None
    fout = open("/etc/ssh/sshd_config", 'wt')
    if fout != None:
        fout.write(fileString)
        fout.close()

    #Reloading the ssh service.
    RunService("ssh")

def checkRule56026():
	flag_owner = True
	flag_group = True
	flag_permission = True
	logging('Checking the file path /etc/ssh/sshd_config exists or not.')
	if os.path.exists('/etc/ssh/sshd_config'):
		# Getting the file permission , ownership and group ownership.
		file_info = runOnShell('stat --format=%U,%G,%a /etc/ssh/sshd_config')
		file_info_list = file_info.translate(string.maketrans("\n\t\r", "   ")).strip(" ").split(",")
		#Converting string to octal.
		tmpOct = int(file_info_list[2],8)
		if not tokenMatch('root',file_info_list[0]):
			logging("Owner of the file is not root.")
			flag_owner = False
		if not tokenMatch('root',file_info_list[1]):
			logging("Group Owner of the file is not root.")
			flag_group = False
		if tmpOct & 0177:
			logging("File permission is not 600.")
			flag_permission = False
		#Checking any of the flag for permission , ownership and group ownership is false.
		if flag_owner and flag_group and flag_permission:
			logging('Permission, ownership and group ownership of /etc/ssh/sshd_config file is correctly configured.')
			return True
		else:
			return False
	logging('File path does not exist.')
	return True

def fixRule56026():
	logging('Checking the file path /etc/ssh/sshd_config exists or not.')
	if os.path.exists('/etc/ssh/sshd_config'):
		# Getting the file permission , ownership and group ownership.
		file_info = runOnShell('stat --format=%U,%G,%a /etc/ssh/sshd_config')
		file_info_list = file_info.translate(string.maketrans("\n\t\r", "   ")).strip(" ").split(",")
		#Converting string to octal.
		tmpOct = int(file_info_list[2],8)
		if not tokenMatch('root',file_info_list[0]):
			runOnShell('chown root /etc/ssh/sshd_config')
		if not tokenMatch('root',file_info_list[1]):
			runOnShell('chgrp root /etc/ssh/sshd_config')
		if tmpOct & 0177:
			runOnShell('chmod 600 /etc/ssh/sshd_config')

def checkRule56028():
	if OsName.lower() == "redhat" or OsName.lower() == "centos" or OsName.lower() == "amazon linux ami":
		if CheckPackage("talk-server"):
			return False
		else:
			return True
	elif OsName.lower() == "ubuntu":
		if CheckPackage("talkd"):
			return False
		else:
			return True
	else:
		logging("Currently not supporting this operating system: " + OsName.lower())
                return 3

def fixRule56028():
	if OsName.lower() == "ubuntu":
		logging("Uninstalling talkd package from the system.")
		# Using DEBIAN_FRONTEND=noninteractive as prefix suppresses the debconf errors that show up on console log.
		if "dpkg was interrupted" in runOnShell('DEBIAN_FRONTEND=noninteractive apt-get -y purge talkd', False):
			logging("dpkg is not properly configured, it needs to be configured properly using command 'dpkg --configure -a'. Please fix this manually.")
			return None
	else:
		logging("Uninstalling talk-server package from the system.")
		runOnShell('rpm -e talk-server --nodeps')	

def checkRule56029():
	# The package "talk" is exactly the same across linux distros: Redhat,Centos 6.X and 7.0, Ubuntu 14.04
	if CheckPackage("talk"):
		return False
	else:
		return True

def fixRule56029():
	logging("Uninstalling Talk package from the system.")
	if OsName.lower() == "ubuntu":
		if "dpkg was interrupted" in runOnShell('DEBIAN_FRONTEND=noninteractive apt-get -y purge talk', False):
			logging("dpkg is not properly configured, it needs to be configured properly using command 'dpkg --configure -a'. Please fix this manually.")
			return None
	else:
		runOnShell('rpm -e talk --nodeps')
	
def checkRule56030():
	if OsName.lower() == "redhat" or OsName.lower() == "centos" or OsName.lower() == "amazon linux ami":
		if CheckPackage("net-snmp"):
			return False
		else:
			return True
	elif OsName.lower() == "ubuntu":
		if CheckPackage("snmpd"):
			return False
		else:
			return True
	else:
		logging("Currently not supporting this operating system: " + OsName.lower())
                return 3

def fixRule56030():
	if OsName.lower() == "ubuntu":
		logging("Uninstalling snmpd package from the system.")
		if "dpkg was interrupted" in runOnShell('DEBIAN_FRONTEND=noninteractive apt-get -y purge snmpd', False):
			logging("dpkg is not properly configured, it needs to be configured properly using command 'dpkg --configure -a'. Please fix this manually.")
			return None
	else:
		logging("Uninstalling net-snmp package from the system.")
		runOnShell('rpm -e net-snmp --nodeps')

def checkRule56031():
	if OsName.lower() == "redhat" or OsName.lower() == "centos" or OsName.lower() == "amazon linux ami":
		if CheckPackage("ypserv"):
			return False
		else:
			return True
	elif OsName.lower() == "ubuntu":
		if CheckPackage("nis"):
			return False
		else:
			return True
	else:
		logging("Currently not supporting this operating system: " + OsName.lower())
		return 3

def fixRule56031():
	if OsName.lower() == "ubuntu":
		logging("Uninstalling NIS-server package from the system.")
		if "dpkg was interrupted" in runOnShell('DEBIAN_FRONTEND=noninteractive apt-get -y purge nis', False):
			logging("dpkg is not properly configured, it needs to be configured properly using command 'dpkg --configure -a'. Please fix this manually.")
			return None
	else:
		logging("Uninstalling ypserv - NIS server package from the system.")
		runOnShell('rpm -e ypserv --nodeps')

def checkRule56032():
	if OsName.lower() == "redhat" or OsName.lower() == "centos" or OsName.lower() == "amazon linux ami":
		if CheckPackage("ypbind"):
			return False
		else:
			return True
	elif OsName.lower() == "ubuntu":
		if CheckPackage("nis"):
			return False
		else:
			return True
	else:
                logging("Currently not supporting this operating system: " + OsName.lower())
                return 3

def fixRule56032():
	if OsName.lower() == "ubuntu":
		logging("Uninstalling NIS client package from the system.")
		if "dpkg was interrupted" in runOnShell('DEBIAN_FRONTEND=noninteractive apt-get -y purge nis', False):
			logging("dpkg is not properly configured, it needs to be configured properly using command 'dpkg --configure -a'. Please fix this manually.")
			return None
	else:
		logging("Uninstalling ypbind - NIS package from the system.")
		runOnShell('rpm -e ypbind --nodeps')

def checkRule56033():
	if OsName.lower() == "redhat" or OsName.lower() == "centos" or OsName.lower() == "amazon linux ami":
		if CheckPackage("mcstrans"):
			return False
		else:
			return True
	elif OsName.lower() == "ubuntu":
		if CheckPackage("policycoreutils"):
			return False
		else:
			return True
	else:
		logging("Currently not supporting this operating system: " + OsName.lower())
                return 3

def fixRule56033():
	if OsName.lower() == "ubuntu":
		logging("Uninstalling Translation (policycoreutils) package from the system.")
		if "dpkg was interrupted" in runOnShell('DEBIAN_FRONTEND=noninteractive apt-get -y purge policycoreutils', False):
			logging("dpkg is not properly configured, it needs to be configured properly using command 'dpkg --configure -a'. Please fix this manually.")
			return None
	else:
		logging("Uninstalling MCS Translation (mcstrans) package from the system.")
		runOnShell('rpm -e mcstrans --nodeps')

def checkRule56034():
	if OsName.lower() == "redhat" or OsName.lower() == "centos" or OsName.lower() == "amazon linux ami":
		if CheckPackage("httpd"):
			return False
		else:
			return True
	elif OsName.lower() == "ubuntu":
		logging("Checking whether apache2 package is installed on system.")
		res_apache2 = runOnShell('dpkg -s apache2 | grep Status')
		if "deinstall" in res_apache2 or "not installed" in res_apache2 or "error" in res_apache2:
			logging("'apache2' is not installed on the system.")
			return True
		else:
			logging("'apache2' is installed on the system, so need to uninstall this package.")
			return False
	else:
		logging("Currently not supporting this operating system: " + OsName.lower())
                return 3

def fixRule56034():
	if ((OsName.lower() == "redhat" or OsName.lower() == "centos") and (OsVersion < (7,0))) or (OsName.lower() == "amazon linux ami"):
		logging("Uninstalling HTTP Server daemon from the system.")
		runOnShell('rpm -e httpd --nodeps;rpm -e httpd-tools --nodeps;rpm -e apr-util --nodeps;rpm -e apr-util-ldap --nodeps')
	# In centos 7, httpd does not require apr-util-ldap as a dependency.
	elif (OsName.lower() == "redhat" or OsName.lower() == "centos") and (OsVersion >= (7,0)):
		logging("Uninstalling HTTP Server daemon from the system.")
		runOnShell('rpm -e httpd --nodeps;rpm -e httpd-tools --nodeps;rpm -e apr-util --nodeps')
	else:
		logging("Uninstalling 'apache2' from the system.")
		if "dpkg was interrupted" in runOnShell('DEBIAN_FRONTEND=non apt-get -y purge apache2', False):
			logging("dpkg is not properly configured, it needs to be configured properly using command 'dpkg --configure -a'. Please fix this manually.")
			return None

def checkRule56035():
	if OsName.lower() == "redhat" or OsName.lower() == "centos" or OsName.lower() == "amazon linux ami":
		if CheckPackage("squid"):
			return False
		else:
			return True
	elif OsName.lower() == "ubuntu":
		logging("Checking whether HTTP Proxy Server(squid3) package is installed on the system.")
		checkSquid3 = runOnShell('dpkg -s squid3 | grep "Status"', False)
		if "deintsall" in checkSquid3 or "error" in checkSquid3 or "not installed" in checkSquid3:
			logging("Package 'squid3' is not installed on system.")
			return True
		else:
			logging("Package 'squid3' is installed on system.")
			return False
	else:
		logging("Currently not supporting this operating system: " + OsName.lower())
                return 3

def fixRule56035():
	logging("Uninstalling HTTP Proxy Server(squid) package from the system.")
	if OsName.lower() == "ubuntu":
		if "dpkg was interrupted" in runOnShell('DEBIAN_FRONTEND=noninteractive apt-get -y purge squid3', False):
			logging("dpkg is not properly configured, it needs to be configured properly using command 'dpkg --configure -a'. Please fix this manually.")
			return None
	else:
		runOnShell('rpm -e squid --nodeps')

def checkRule56036():
	'''
	This rule checks whether there are any dovecot packages installed. If they are, it uninstalls them from the system.
	"dovecot-core"(Ubuntu machines) or "dovecot"(Redhat and Centos machines) is actually the main mail server engine.
	"dovecot-mysql" or "dovecot-pgsql" are just packages that provide support for the respective databases but require
	the main dovecot engine to function properly so we are removing all the dovecot packages.
	'''
	logFlag = False
	if OsName.lower() == "redhat" or OsName.lower() == "centos" or OsName.lower() == "amazon linux ami":
		checkDovecot = runOnShell('rpm -qa | grep -w dovecot')
		if checkDovecot:
			logFlag = True
	elif OsName.lower() == "ubuntu":
		checkDovecotList = runOnShell('dpkg --list | cut -d" " -f3 | grep -w dovecot').splitlines()
		for package in checkDovecotList:
			res = runOnShell('dpkg -s ' + package +' | grep Status', False)
                        if not ("deinstall" in res or "error" in res or "not installed" in res):
				logFlag = True
				break
	else:
		logging("Currently not supporting this operating system: " + OsName.lower())
                return 3

	if logFlag:
		logging("Dovecot(IMAP and POP3 services) service is installed on the system.")
		return False
	else:
		logging("Dovecot(IMAP and POP3 services) service is not installed on the system.")
		return True

def fixRule56036():
	logging("Uninstalling Dovecot(IMAP and POP3 services) service from the system.")
	if OsName.lower() == "ubuntu":
		checkDovecot = runOnShell('dpkg --list | cut -d" " -f3 | grep -w dovecot', False)
		checkDovecotList = checkDovecot.splitlines()
		for package in checkDovecotList:
			res = runOnShell('dpkg -s ' + package + ' | grep Status', False)
			if not ("deinstall" in res or "error" in res or "not installed" in res):
				checkDpkg = runOnShell('DEBIAN_FRONTEND=noninteractive apt-get -y purge ' + package , False)
				if "dpkg was interrupted" in checkDpkg:
					logging("dpkg is not properly configured, it needs to be configured properly using command 'dpkg --configure -a'. \
Please fix this manually.")
					return None
	else:
		checkDovecot = runOnShell('rpm -qa | grep -w dovecot', False)
		checkDovecotList = checkDovecot.splitlines()
		for package in checkDovecotList:
			runOnShell('rpm -e ' + package + ' --nodeps')

def checkRule56037():
	if OsName.lower() == "redhat" or OsName.lower() == "centos" or OsName.lower() == "amazon linux ami":
		if CheckPackage("bind"):
			return False
		else:
			return True
	elif OsName.lower() == "ubuntu":
		if CheckPackage("bind9"):
			return False
		else:
			return True
	else:
		logging("Currently not supporting this operating system: " + OsName.lower())
                return 3

def fixRule56037():
	logging("Uninstalling DNS Server package from the system.")
	if OsName.lower() == "ubuntu":
		if "dpkg was interrupted" in runOnShell('DEBIAN_FRONTEND=noninteractive apt-get -y purge bind9', False):
			logging("dpkg is not properly configured, it needs to be configured properly using command 'dpkg --configure -a'. Please fix this manually.")
                        return None
	else:
		runOnShell('rpm -e bind --nodeps')

def checkRule56038():
	'''This function intends to disable the tcpmux-server''' 
    	if OsName.lower() == "ubuntu":
		logging("This rule is not applicable for ubuntu.")
		return None
	
	logging("Checking if Extended Internet Services Daemon is installed.")
	if not os.path.exists('/usr/sbin/xinetd'):
		logging("Extended Internet Services daeamon (xinetd) is not installed which supports tcpmux-server service ,\
 hence tcpmux-server does not exist on the system.")
		return True

	logging("Checking xinetd service status.")
	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
	    service_status = runOnShell('systemctl is-active xinetd.service').replace('\n','')
	    if service_status in ["inactive", "unknown","failed"]:
		logging("Extended Internet Services daeamon (xinetd) is not running.")
	        return True
	elif "stopped" in runOnShell('service xinetd status').replace('\n',''):
		logging("Extended Internet Services daeamon (xinetd) is not running.")
		return True

	logging("Checking if tcpmux-server is installed.")
	if not os.path.exists('/etc/xinetd.d/tcpmux-server'):
		logging("TCP Port Service Multiplexer is not installed.")
		return True

	logging("Checking the status of TCP Port Service Multiplexer (tcpmux-server).")
	if "off" in runOnShell("chkconfig --list tcpmux-server").translate(string.maketrans("\n\t\r", "   ")):
		logging("TCP Port Service Multiplexer is disabled.")
		return True

	logging("TCP Port Service Multiplexer is enabled.")
	return False

	
def fixRule56038():
	runOnShell('chkconfig tcpmux-server off; service xinetd restart')

def checkRule56039():
	'''This function intends to disable cups daemon(printer)''' 

	logging("Checking the installation of Common Unix Printing System.")
	if not os.path.exists('/usr/sbin/cupsd'):
		logging("Common Unix Printing System is not installed.")
		return True

	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		service_status = runOnShell('systemctl is-active cups.service').replace('\n','')
		if service_status == "active":
			logging("Common Unix Printing System service is running.")
			return False 

		service_at_runlevel = runOnShell("systemctl is-enabled cups.service").replace('\n','')
		if service_at_runlevel == "enabled":
			logging("Common Unix Printing System service is enabled at runlevel.")
			return False
	else:
		if OsName.lower() == 'ubuntu':
			token_match = "start/running,"
			service_at_level_command = "sysv-rc-conf --list cups"
		else:
			token_match = "running..."
			service_at_level_command = "chkconfig --list cups"
		
		logging("Checking the status of Common Unix Printing System.")
		service_status = runOnShell('service cups status').translate(string.maketrans("\n\t\r", "   "))
		service_run = False
		if tokenMatchIC(token_match,service_status):
			logging("Common Unix Printing System service is running.")
			service_run = True
		
		logging("Checking the status of Common Unix Printing System service at runlevel.")
		service_at_level = runOnShell(service_at_level_command)
		service_at_level = service_at_level.translate(string.maketrans("\n\t\r", "   "))
		if "on" in service_at_level: 
			logging("Common Unix Printing System service is on at runlevel.")
			service_run = True
		
		if service_run:
			return False
	

	logging("Common Unix Printing System is not running.")
	return True

	
def fixRule56039():
	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		runOnShell("systemctl disable cups.service;systemctl stop cups.service")
	elif OsName.lower() == "ubuntu":
		runOnShell("service cups stop ;sysv-rc-conf --level 0123456S cups off")
	else :
		runOnShell('chkconfig --level 0123456 cups off; service cups stop')


def checkRule56040():
    '''This function intends to disable the nfs and rpcbind service.''' 

    service_name = ""
    if OsName.lower() == "ubuntu":
        service_name = "nfs-kernel-server"
    else:
        service_name = "nfs-utils"
    
    if not CheckPackage(service_name):
        return True
    
    logging("\nChecking the status of NFS(Network File System)")
    if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
        nfs_runlevel = runOnShell("systemctl is-enabled nfs-server").replace('\n','')
        nfs_status = runOnShell('systemctl is-active nfs-server').replace('\n','')
        logging("\nNFS(Network File System) use the rpcbind service for backward compatibility as \
 rpcbind responds to requests for RPC services and sets up connections to the requested RPC service, hence checking the status of rpcbind service.")
        rpc_status = runOnShell('systemctl is-active rpcbind.service').replace('\n','')
        if nfs_status == "active" or nfs_runlevel == "enabled" or rpc_status == "active":
            return False
    elif OsName.lower() == "ubuntu":
        nfsd_status =  runOnShell('service nfs-kernel-server status').translate(string.maketrans("\n\t\r", "   "))
        nfsd_runlevel =  runOnShell('sysv-rc-conf --list nfs-kernel-server').translate(string.maketrans("\n\t\r", "   "))
        rpcbind_status =  runOnShell('service rpcbind status').translate(string.maketrans("\n\t\r", "   "))
        rpcbind_runlevel =  runOnShell('sysv-rc-conf --list rpcbind').translate(string.maketrans("\n\t\r", "   "))
        if "nfsd running" in nfsd_status or "on" in nfsd_runlevel or "on" in rpcbind_runlevel or "start/running" in rpcbind_status :
    	    logging("Autofs (Automated file system mounting) service is on at runlevel.")
    	    return False
    else:
        nfs_status =  runOnShell('service nfs status').translate(string.maketrans("\n\t\r", "   "))
        logging("\nChecking the status of nfs service at runlevel.")
        nfs_level =  runOnShell('chkconfig --list nfs').translate(string.maketrans("\n\t\r", "   "))
        logging("\nNFS(Network File System) use the rpcbind service for backward compatibility as \
 rpcbind responds to requests for RPC services and sets up connections to the requested RPC service, hence checking the status of rpcbind service.")
        rpcbind_status = runOnShell('service rpcbind status').translate(string.maketrans("\n\t\r", "   "))
        logging("\nChecking the status of rpcbind service at runlevel.")
        rpcbind_level =  runOnShell('chkconfig --list rpcbind').translate(string.maketrans("\n\t\r", "   "))
        if ( ("on" in nfs_level or "on" in rpcbind_level) or ("running" in rpcbind_status or "running" in nfs_status) ):
    	    return False

    return True
	
def fixRule56040():
	if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
            runOnShell("systemctl disable nfs-server; systemctl stop nfs-server;\
 systemctl stop rpcbind.service")
	elif OsName.lower() == "ubuntu":
            runOnShell('service rpcbind stop ; service nfs-kernel-server stop ; \
sysv-rc-conf --level 0123456S nfs-kernel-server  off ; sysv-rc-conf --level 0123456 rpcbind off')
	else:
            rpc_status = runOnShell("service rpcbind status")
            nfs_status = runOnShell("service nfs status")
            if "stopped" not in rpc_status:
                runOnShell('service rpcbind stop')
            if "stopped" not in nfs_status:
                runOnShell('service nfs stop')
            runOnShell('chkconfig --level 0123456 nfs off ; chkconfig --level 0123456 rpcbind off')


def checkRule56041():
    '''This function intends to disable the daytime-stream''' 
    if not pci_service_check("daytime","tcp"):
	return False
    return True	
	
def fixRule56041():
    pci_service_fix('daytime','tcp')

def checkRule56042():
    '''This function intends to disable the daytime-dgram''' 
    if not pci_service_check("daytime","udp"):
	return False
    return True	

def fixRule56042():
    pci_service_fix('daytime','udp')

def checkRule56043():
    '''This function intends to disable the chargen-stream''' 
    if not pci_service_check("chargen","tcp"):
	return False
    return True	

def fixRule56043():
    pci_service_fix('chargen','tcp')

def checkRule56044():
    '''This function intends to disable the chargen-dgram''' 
    if not pci_service_check("chargen","udp"):
        return False
    return True	

def fixRule56044():
    pci_service_fix('chargen','udp')

def checkRule56045():
    '''This function intends to disable the echo-stream service.''' 
    if not pci_service_check("echo","tcp"):
        return False
    return True	

def fixRule56045():
    pci_service_fix('echo','tcp')

def checkRule56079():
    '''This function intends to disable the echo-dgram service.''' 
    if not pci_service_check("echo","udp"):
        return False
    return True	

def fixRule56079():
    pci_service_fix('echo','udp')

def checkRule56047():
	if OsName.lower() == "ubuntu":
		file_list = ["/var/log/syslog", "/var/log/auth.log", "/var/log/mail.log", "/var/log/cron.log", "/var/log/boot.log"]
	else:
		file_list = ["/var/log/messages", "/var/log/secure", "/var/log/maillog", "/var/log/cron", "/var/log/spooler", "/var/log/boot.log"]
	wrongOwnerList = []
	wrongGroupOwnerList = []
	wrongPermissionList = []
	fileFoundFlag = False
	for filePath in file_list:
		if os.path.exists(filePath):
			logging('Checking ownership, group ownership and permission of file ' + filePath)
			fileFoundFlag = True
			# Getting the file permission , ownership and group ownership.
			file_info = runOnShell('stat --format=%U,%G,%a '+filePath, False)
			file_info_list = file_info.translate(string.maketrans("\n\t\r", "   ")).strip(" ").split(",")
			# Converting string to octal.
			tmpOct = int(file_info_list[2],8)
			if not tokenMatch('root',file_info_list[0]):
				wrongOwnerList.append(filePath)
			if not tokenMatch('root',file_info_list[1]):
				wrongGroupOwnerList.append(filePath)
			if tmpOct & 0177:
				wrongPermissionList.append(filePath)

	if wrongOwnerList or wrongGroupOwnerList or wrongPermissionList:
		if wrongOwnerList:
			logging("Ownership of the following file(s) " + ', '.join(wrongOwnerList) + " is not set properly.")
		if wrongGroupOwnerList:
			logging("Group ownership of the following file(s) " + ', '.join(wrongGroupOwnerList) + " is not set properly.")
		if wrongPermissionList:
			logging("Permission of the following file(s) " + ', '.join(wrongPermissionList) + " is not set properly.")
		return False

	if fileFoundFlag:
		logging('Permission, ownership and group ownership of file(s) is configured correctly.')
	else:
		logging('**WARNING** : None of the following critical log files ' + ', '.join(file_list) + ' exist on your system. Please check your rsyslog configuration properly.')
	return True

def fixRule56047():
	if OsName.lower() == "ubuntu":
		file_list = ["/var/log/syslog", "/var/log/auth.log", "/var/log/mail.log", "/var/log/cron.log", "/var/log/boot.log"]
	else:
		file_list = ["/var/log/messages", "/var/log/secure", "/var/log/maillog", "/var/log/cron", "/var/log/spooler", "/var/log/boot.log"]
	wrongOwnerList = []
	wrongGroupOwnerList = []
	wrongPermissionList = []
	for filePath in file_list:
		if os.path.exists(filePath):
			# Getting the file permission , ownership and group ownership.
			file_info = runOnShell('stat --format=%U,%G,%a '+filePath, False)
			file_info_list = file_info.translate(string.maketrans("\n\t\r", "   ")).strip(" ").split(",")
			# Converting string to octal.
			tmpOct = int(file_info_list[2],8)
			if not tokenMatch('root',file_info_list[0]):
				runOnShell('chown root '+filePath, False)
				wrongOwnerList.append(filePath)
			if not tokenMatch('root',file_info_list[1]):
				runOnShell('chgrp root '+filePath, False)
				wrongGroupOwnerList.append(filePath)
			if tmpOct & 0177:
				runOnShell('chmod 600 '+filePath, False)
				wrongPermissionList.append(filePath)

	if wrongOwnerList:
		logging("Updated ownership of following file(s) " + ', '.join(wrongOwnerList) + ".")
	if wrongGroupOwnerList:
		logging("Updated group ownership of the following file(s) " + ', '.join(wrongGroupOwnerList) + ".")
	if wrongPermissionList:
		logging("Updated permission of the following file(s) " + ', '.join(wrongPermissionList) + ".")

def checkRule56048():
    # Check whether rsyslog is configured properly. If not rule is marked as manual. If it is configured properly, check whether remote logging is enabled.
    if not check_rsyslog_config():
        return None

    if OsName.lower() == "ubuntu":
        configFile = "/etc/default/rsyslog"
        keyWord = "RSYSLOGD_OPTIONS"
    else:
        configFile = "/etc/sysconfig/rsyslog"
        keyWord = "SYSLOGD_OPTIONS"

    logging("Checking whether system is enabled to send logs to remote log host.")
    try:
        rsyslogVersion = runOnShell('rsyslogd -v | grep -w rsyslogd', False).split(".")
        splitResult = rsyslogVersion[0].split()
        # In versions 6 and above of rsyslogd, the options "-r" and "-c" have been disabled by the developers of rsyslog.
        if int(splitResult[1]) >= 6:
            logging("The system is enabled to send logs to remote log host.")
            return True

        syslogOption = runOnShell('grep -w ' + keyWord + ' ' + configFile + ' | grep -v "^#"').strip()
        if not syslogOption:
            logging("Rsyslog version not defined. Please fix this manually. Force remediation will make rsyslog run with \
it's latest version depending on the version of your operating system.")
            return None
        if re.search(r'([A-Z]\s+=\s+)|([A-Z]=\s+)', syslogOption, re.M|re.I):
            logging("The configuration for enabling the system to send logs to remote log host is not configured properly.")
            return False
        options = syslogOption.split("=")
        if options[1] == '""' or options[1] == '"-r"':
            logging("You have not specified the version of rsyslog to be used. If you are using compatibility mode, it is \
recommended to specify the version. Please fix this manually. Force remediation will make rsyslog run with it's latest version \
depending on the version of your operating system.")
            return None
        # In versions 3 and above of rsyslogd, the options "-r" is optional. If rsyslog.conf is configured properly then syslogs are 
        # forwarded to remote server by default. Option "-r" is supported only from versions 0 to 2
        elif re.search(r'-c [3-5]', options[1], re.M|re.I):
            logging("The system is enabled to send logs to remote log host.")
            return True

        expOne = re.search(r'-r -c [0-9]', options[1], re.M|re.I)
        expTwo = re.search(r'-c [0-9] -r', options[1], re.M|re.I)
    except (IndexError, ValueError):
        logging("The configuration for enabling the system to send logs to remote log host is not configured properly.")
        return False

    if expOne or expTwo:
        logging("The system is enabled to send logs to remote log host.")
        return True
    else:
        logging("The system is not enabled to send logs to remote log host.")
        return False

def fixRule56048():
    if OsName.lower() == "ubuntu":
        configFile = "/etc/default/rsyslog"
        keyWord = "RSYSLOGD_OPTIONS"
    else:
        configFile = "/etc/sysconfig/rsyslog"
        keyWord = "SYSLOGD_OPTIONS"

    if not os.path.exists(configFile):
        logging("File path " + configFile + " is not available. Please fix this manually.")
        return None

    rsyslogVersion = runOnShell('rsyslogd -v | grep -w rsyslogd', False).split(".")
    splitResult = rsyslogVersion[0].split()
    # In versions 6 and above of rsyslogd, the options "-r" and "-c" are disabled by default.
    if int(splitResult[1]) < 6:
        syslogOption = runOnShell('grep -w ' + keyWord + ' ' + configFile + ' | grep -v "^#"').strip()
        options = syslogOption.split("=")
        optionsFlag = False
        with open(configFile, "r") as fileData:
            changeLine = ""
            lastLine = ""
            for line in fileData:
                if isL(line) and keyWord in line:
                    if not optionsFlag:
                        logging("Updating configuration for sending logs to remote hosts.")
                        if not tokenMatch('Cloud Raxak updated next line',lastLine):
                            changeLine += "# Cloud Raxak updated next line\n"
                        try:
                            options = syslogOption.split("=")
                            if re.search(r'-c [0-2]', options[1], re.M|re.I):
                                selectedVersion = re.findall('\d',options[1])
                                changeLine += keyWord + '="-c ' + selectedVersion[0] + ' -r"'
                            else:
                                changeLine += keyWord + '="-c ' + splitResult[1] + '"'
                        except IndexError:
                            changeLine += keyWord + '="-c ' + splitResult[1] + '"'
                        optionsFlag = True
                else:
                    changeLine += line
                    lastLine = line
        if not optionsFlag:
            logging("Adding configuration for sending logs to remote hosts.")
            if not tokenMatch('Cloud Raxak updated next line',lastLine):
                changeline += "# Cloud Raxak updated next line\n"
            changeline += keyWord + '="-c ' + splitResult[1] + '"'
        writeFile(configFile, changeLine, 'wt')
        logging("Restarting rsyslog service.")
        RunService("rsyslog")

def checkRule56049():
	logging('Checking the file path /etc/hosts.deny exists or not.')
	if os.path.exists('/etc/hosts.deny'):
		# Getting the file permission , ownership and group ownership.
		tmpOct =int(runOnShell('stat --format=%a /etc/hosts.deny'),8)
		#Converting string to octal.
		if tmpOct & 0133:
			logging('Permissions for file /etc/hosts.deny is not equal to 644 or less.')
			return False
		else:
			logging('Permissions for file /etc/hosts.deny is correctly configured.')
			return True

	logging('File path does not exist.')
	return True

def fixRule56049():
	logging('Checking the file path /etc/hosts.deny exists or not.')
	if os.path.exists('/etc/hosts.deny'):
		# Getting the file permission , ownership and group ownership.
		file_permission = runOnShell('stat --format=%a /etc/hosts.deny')
		if not tokenMatch('644',file_permission):
			runOnShell('chmod 644 /etc/hosts.deny')

def checkRule56050():
	logging('Checking the file path /etc/hosts.allow exists or not.')
	if os.path.exists('/etc/hosts.allow'):
		# Getting the file permission , ownership and group ownership.
		tmpOct =int(runOnShell('stat --format=%a /etc/hosts.allow'),8)
		#Converting string to octal.
		if tmpOct & 0133:
			logging('Permissions for file /etc/hosts.allow is not equal to 644 or less.')
			return False
		else:
			logging('Permissions for file /etc/hosts.allow is correctly configured.')
			return True

	logging('File path does not exist.')
	return True

def fixRule56050():
	logging('Checking the file path /etc/hosts.allow exists or not.')
	if os.path.exists('/etc/hosts.allow'):
		# Getting the file permission , ownership and group ownership.
		file_permission = runOnShell('stat --format=%a /etc/hosts.allow')
		if not tokenMatch('644',file_permission):
			runOnShell('chmod 644 /etc/hosts.allow')

def checkRule56051():
    '''This rule verifies that tcp_wrappers package is installed on the system.'''
    if OsName.lower() == "ubuntu":
	if not CheckPackage("tcpd"):
		return False
        else:
            runOnShell("dpkg --list | grep tcpd")
    else:
	if not CheckPackage("tcp_wrappers"):
		return False

    logging("Checking if host files exist on the system.")
    if (not os.path.exists('/etc/hosts.allow')) or (not os.path.exists('/etc/hosts.deny')):
        logging("Host's access file(s) does not exist.")
	return False
    logging("The TCP is configured on the system.")
    return True

def fixRule56051():
    if OsName.lower() == "ubuntu":
	pkgName = "tcpd"
    else:
	pkgName = "tcp_wrappers"
 
    if not CheckPackage(pkgName):
        if not InstallPackage(pkgName):
            return None
    if (not os.path.exists('/etc/hosts.allow')) or (not os.path.exists('/etc/hosts.deny')):
        if OsName.lower() == "ubuntu":
            logging("Creating the host file(s) on the system.")
            runOnShell('touch /etc/hosts.allow')
            runOnShell('touch /etc/hosts.deny')
        else:
            logging("Installing host files on the system.")
            runOnShell("yum reinstall setup -y", False)

def checkRule56052():
    checkStatus = False
    logging("Checking for the latest OS release information on the system.")
    if OsName.lower() == "ubuntu":
        if "No new release found" in runOnShell("/usr/bin/do-release-upgrade -p"):
            checkStatus = True
    elif OsName.lower() == "redhat":
        if runOnShell("yum check-update | grep redhat-release-server").strip() == "":
            checkStatus = True
    elif OsName.lower() == "amazon linux ami":
        if runOnShell("yum check-update | grep amzn-updates").strip() == "":
            checkStatus = True
    else:
        if runOnShell("yum check-update | grep centos-release").strip() == "":
            checkStatus = True

    if checkStatus:
	logging("There are no updates available for latest OS release.")
	return True
    else:
        logging("Updates are available for the latest OS release, user intervention is required so need to fix it manually.")
        return None

def fixRule56052():
    logging("User intervention is required to review the OS release, so need to fix it manually.")
    return None

def checkRule56053():
    '''This rule produces a list of users who are allowed to use at/cron for review.'''
    #checking whether at and cron package is installed.
    atLogMessage = ""
    cronLogMessage = ""
    atFlag = False
    cronFlag = False
    #check for at.allow.
    if CheckPackage("at"):
        logging("Checking the system configuration for allowing to use 'at' daemon.")
        #check whether at.allow exist.
        if os.path.exists('/etc/at.allow'):
            atAllowList = runOnShell('cat /etc/at.allow | grep -v "^#"', False)
            atAllowList = atAllowList.translate(string.maketrans("\n\t\r", "   ")).split()
            #checking for entry present in at.allows.
            if len(atAllowList) >= 1:
                atLogMessage = "'" + ", ".join(atAllowList) + "' user(s) listed in the at.allow files can run the 'at' daemon."
                atFlag = True
            else:
                atLogMessage = "Please add user(s) to allow 'at' daemon  to authorized user(s)."
        else:
            atLogMessage = "'at.allow' file not found. Please create the file and add user(s) to allow 'at' daemon to authorized user(s)"

    #If at package is not installed.
    else:
        atFlag = True

    #check for cron.allow.
    if OsName.lower() == "ubuntu":
        cronPackage = "cron"
    else:
        cronPackage = "crontabs"
    if CheckPackage(cronPackage):
        logging("Checking the system configuration for allowing to use 'cron' daemon.")
        #check whether cron.allow exist.
        if os.path.exists('/etc/cron.allow'):
            cronAllowList = runOnShell('cat /etc/cron.allow | grep -v "^#"', False)
            cronAllowList = cronAllowList.translate(string.maketrans("\n\t\r", "   ")).split()
            #checking for entry present in cron.allows.
            if len(cronAllowList) >= 1:
                cronLogMessage = "'" + ", ".join(cronAllowList) +"' user(s) listed in the cron.allow files can run the 'cron' daemon."
                cronFlag = True
            else:
                cronLogMessage = "Please add user(s) to allow 'cron' daemon to authorized user(s)."
        else:
            cronLogMessage = "'cron.allow' file not found. Please create the file and add user(s) to allow 'cron' daemon to authorized user(s)"

    #If cron package is not installed.
    else:
        cronFlag = True

    #providing log message according to conditions.
    if atFlag and cronFlag:
        logging(atLogMessage + "\n" + cronLogMessage)
        return True
    elif atFlag and not cronFlag:
        logging(cronLogMessage)
    elif not atFlag and cronFlag:
        logging(atLogMessage)
    else:
        logging(atLogMessage + "\n" + cronLogMessage)
    return None

def fixRule56053():
    logging("Please add user(s) to restrict at/cron to authorized user(s).")
    return None

def checkRule56058():
    logging("Checking the Allowed users to specify which user(s) can access ssh services.")
    check_AllowUsers  = runOnShell('grep -iw AllowUsers /etc/ssh/sshd_config | grep -v "^#"')
    logging("Checking the Deny users to specify which user(s) can not access ssh services.")
    check_DenyUsers  = runOnShell('grep -iw DenyUsers /etc/ssh/sshd_config | grep -v "^#"')
    logging("Checking the Allowed Groups to specify which group user(s) can access ssh services.")
    check_AllowGroups  = runOnShell('grep -iw AllowGroups /etc/ssh/sshd_config | grep -v "^#"')
    logging("Checking the Deny Groups to specify which group user(s) can not access ssh services.")
    check_DenyGroups  = runOnShell('grep -iw DenyGroups /etc/ssh/sshd_config | grep -v "^#"')
    if check_AllowUsers == "" and check_DenyUsers == "" and check_AllowGroups == "" and check_DenyGroups == "":
        logging("There are no Allowed Users, DenyUsers, AllowGroups and DenyGroups in the configuration file.")
	return True
    logging("The list is as following:" + "\n" + check_AllowUsers +  check_DenyUsers + check_AllowGroups + check_DenyGroups)
    logging("For limiting the users access via SSH, manual intervention is required so need to fix it manually.")
    return None

def fixRule56058():
    logging("For limiting the users access via SSH, manual intervention is required so need to fix it manually.")
    return None

def checkRule56055():
    res = runOnShell("awk -F ':' '{print $1, $3}' /etc/passwd", False)
    res = filter (lambda ele: not ele.isspace(), res.splitlines())
    if OsName.lower() == "ubuntu":
        # This file is having reserved uid's of system users.
        filePath = "/usr/share/base-passwd/passwd.master"
    else:
        filePath = "/usr/share/doc/setup*/uidgid"
    filePath = filePath.strip('\n')
    userName = ""
    diffUid = ""
    logging("Checking the system accounts existency in " + filePath + " file.")
    for userAcc in res:
        try:
            uname = userAcc.split()[0]
            uid = userAcc.split()[1]
            if OsName.lower() == "ubuntu":
                # checking if the user is exist in reserved uid's file.
                account = runOnShell("grep  ^" + uname + " " + filePath, False)
            else:
                account = runOnShell("grep  ^" + uname + "[[:blank:]] " + filePath, False)
            if account == "":
                # user does not exist in reserved uid's file
                userName += ", " + uname
            if OsName.lower() == "ubuntu":
                if account != "":
                    regUid = account.split(":")
                    # comparing the account uid with reserved uid's.
                    if uid != regUid[2]:
                        diffUid += ", " + uname
            else:
                if account != "":
                    regUid = account.split()
                    # Comparing the uid and reserved uid's of system accounts.
                    if uid != regUid[1]:
                        diffUid += ", " + uname
        except IndexError:
            logging ("Some synatax error in '/etc/passwd' or '" + filePath + "' file. So check it manually.")
            return None
    if userName or diffUid:
        if userName:
            logging("The following mentioned account(s) : " + userName.lstrip(',') + " do/does not exist in " + filePath + " file. Please check the uid(s) of these account(s) manually.")
        if diffUid:
            logging("The uid(s) of the following mentioned account(s) : " + diffUid.lstrip(',') + " is not matching with thier respective reserved uid(s), please take necessary action manually.")
        return None
    logging("Reserved UIDs are assigned to system accounts only.")
    return True

def fixRule56055():
    logging("The account(s) have reserved uid(s), So need to take necessary action manually.")
    return None

def checkRule56056():
    '''This rule produces a list of utilities installed on the system for reviewing.'''
    logging('Checking the list of utilities installed on the system for reviewing.')
    if OsName.lower() == "ubuntu":
        utilitiesList = runOnShell("basename -a $(dpkg -L $(dpkg --list |grep -i utilities|cut -d' ' -f3) |egrep '/s?bin/')", False).strip()
    else:
        utilitiesList = runOnShell("rpm -ql coreutils passwd shadow-utils file findutils sysvinit-tools procps | grep -w 'bin\|sbin'", False).strip()
    # Some duplicate utilities also show up in the list since there are same uitilities which belong to two or more different packages
    # so remove those duplicate entries. This majorly happens in case of Ubuntu machines.
    formatStringSplit = utilitiesList.splitlines()
    formatStringSplit = list(set(formatStringSplit))
    display_list_as_columns(formatStringSplit, 4)
    if utilitiesList == "":
        logging('**ALERT** : None of the core utilities(For eg: cat, tail, mkdir) are installed on your system. Please install the core \
utilities and also check your entire system properly. Core utilities not installed can make the system behave absurdly and may lead to \
crashing your applications.')
    else:
        logging('Please review the list of utilities installed on the system manually to ensure that it is legitimate.')
    return None

def fixRule56056():
    return None

def checkRule56057():
    '''User should review the list of packages installed on the system and ensure that it is legitimate. \
    This rule produces a list of packages installed on the system for review.'''
    logging('Checking the list of packages installed on the system for the review.')
    if OsName.lower() == "ubuntu":
        utilitiesList = runOnShell('dpkg --list |cut -d" " -f3')
    else:
        utilitiesList = runOnShell('rpm -qa')
    if utilitiesList == "":
	logging('Packages are not installed on the system.')
        return True
    logging('Please review the list of packages installed on the system and ensure that it is legitimate.')
    return None

def fixRule56057():
    logging("Please review the list of packages installed on the system and ensure that it is legitimate.")
    return None

def checkRule56046():
	'''This rule verifies that /var/log/btmp file in the system, containing log of last bad login attempts. If the btmp file does not exist then create the /var/log/btmp file.'''
        logging("Checking for btmp file in the system, containing log of last bad login attempts.")
        if os.path.exists('/var/log/btmp'):
            logging('File containing log of last bad login attempts exist in the system.')
            return True
        else:
            logging('File containing log of last bad login attempts does not exist, so need to create the file.')
            return False

def fixRule56046():
	logging("Creating the btmp file in the system, containing log of last bad login attempts.")
	runOnShell('touch /var/log/btmp')
	logging("Changing the permission and group owner required for the btmp file, containing log of last bad login attempts.")
	runOnShell('chmod 600 /var/log/btmp; chgrp utmp /var/log/btmp')

def checkRule56071():
	logging('Checking the group id of the root user.')
	root_gid = runOnShell('id -g root')
	if root_gid and int(root_gid) == 0:
		logging('The group id of the root is 0.')
		return True
	else:
		logging('The group id of the root is not 0.')
		return False

def fixRule56071():
	logging ('Updating the GID of the root user to 0.')
	runOnShell('usermod -g 0 root')

def checkRule56073():
    logging("Checking for duplicate UID.")
    uid = runOnShell("awk -F: '{print $3}' /etc/passwd | sort |uniq -d")
    uid = uid.translate(string.maketrans("\n\t\r", "   "))
    #Converting uid to list and regular expression removes the invalid values '.!,:?'
    uid_list  = re.sub(r'[.!,;?]', ' ', uid).split()
    if uid_list != "":
	duplicate_uid = False
        for value in uid_list:
            runOnShell('grep :x:'+ value +': /etc/passwd')
	    duplicate_uid = True
        if duplicate_uid:
            logging("Multiple users are having similar UID, please change the UID manually.")
            return None
    logging('There are no users with similar UID.')
    return True

def fixRule56073():
    logging("Multiple users are having similar UID, please change the UID using command 'usermod -u <new_UID> <username>' manually.")
    return None

def checkRule56027():
    '''This rule verifies that LogLevel parameter is set to INFO (informational messages)'''

    if checkSSHDSyntax() == None:
        return None
    logging("Checking the level of logging in the ssh configuration.")
    logLevel = runOnShell('grep -iw LogLevel /etc/ssh/sshd_config  | grep -v "^#" | awk -F" " \'{ print $2 }\'')
    try:
        logResult = logLevel.translate(string.maketrans("\n\t\r", "   ")).strip()
        matchObj = re.match(r'\bINFO\b', logResult)
        if matchObj != None:
           logging("The level of logging is correctly configured.")
           return True
        else:
           logging("The level of logging is not configured.")
           return False
    except (ValueError):
        logging("The level of logging is not correctly configured.")
        return False

def fixRule56027():
    if checkSSHDSyntax() == None:
        return None

    lastLine = ""
    fileString = ""
    updateLog = False
    fileSplit = open("/etc/ssh/sshd_config").readlines()
    logging("Updating the level of logging in ssh configuration.")
    for line in fileSplit:
        if isL(line) and tokenMatchIC("LogLevel", line):
            if not tokenMatch("Cloud Raxak updated next line",lastLine):
                fileString += "# Cloud Raxak updated next line\n"
            fileString += "LogLevel INFO\n"
            updateLog = True
        else:
            fileString += line
            lastLine=line
    if not(updateLog):
        if not tokenMatch('Cloud Raxak updated next line', lastLine):
            fileString += "\n# Cloud Raxak updated next line\n"
        fileString += "LogLevel INFO\n"
    fout = None
    try:
        fout = open("/etc/ssh/sshd_config", 'w')
        fout.write(fileString)
    finally:
        if fout is not None:
            fout.close()

    #Enabling ssh service and run leves
    RunService("ssh")

def checkRule56059():
	'''This functions intends to list out the audit event if configured 
	 	and notify the user to remove it manually if not required.. '''

	logging("Checking if auditd package is installed.")
	if not os.path.exists('/sbin/auditd'):
		logging("auditd package is not installed, hence there is no audit event type configured.")
		return True 

    	if  OsName.lower() == 'ubuntu':	
        	file_path = '/etc/audit/audit.rules'
    	elif OsVersion >= (7,0):
		file_path = '/etc/audit/rules.d/audit.rules'
	else:
		file_path = '/etc/audit/audit.rules'

        if (OsName.lower() == 'amazon linux ami'):
            logging("Checking if system call auditing is disabled.")
	    if runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' "+file_path) != "" :
                logging("System call auditing is enabled hence need to disable system call to audit the events properly.")
                return False

	logging("Displaying the list of audit events if exist.")
    	runOnShell("auditctl -R "+file_path)
	if "No rules" not in runOnShell("auditctl -l"):
		logging("Please remove the unnecessary audit event rule manually if not required.")
		return None
	logging("There is no any audit event type configured.")

	return True

def fixRule56059():
	#Checking for keyword never,task
	if (OsName.lower() == 'amazon linux ami') :
		if runOnShell("grep -ri '\s*-a\s*never,\s*task\s*' /etc/audit/audit.rules ") != "" :
        		logging(" Disabling the system call auditing to audit the events properly.")
        		runOnShell("sed -ie 's/\s*-a\s*never,\s*task\s*/  /'  /etc/audit/audit.rules")

	return None

def checkRule56060():
    '''This rule provides the rsyslog configuration for review purpose and makes sure it is legitimate.'''
    if not CheckPackage("rsyslog"):
        logging("To install rsyslog package, please remediate V-56063.")
        return None

    if OsName.lower() == "ubuntu":
        filePath = "/etc/default/rsyslog"
    else:
        filePath = "/etc/sysconfig/rsyslog"

    if not os.path.exists('/etc/rsyslog.conf') or not os.path.exists(filePath):
        logging("The rsyslog configuration file(s) does not exist. Please fix this manually by reinstalling the rsyslog package.")
        return None

    checkDetails = runOnShell('cat /etc/rsyslog.conf | grep -v "^#"')
    checkSysconfigDetails = runOnShell('cat ' + filePath + ' | grep -v "^#"')
    logging('Please review the above rsyslog configuration details manually to make sure it is legitimate.')
    return None

def fixRule56060():
    logging("Review the rsyslog configuration details and make sure it is legitimate.")
    return None

def checkRule56061():
    '''This rule produces the DNS entry for the system for review.'''
    checkNetworkEntry = ""
    logging('Checking the DNS entry on the system for review.')
    checkEntry = runOnShell('cat /etc/resolv.conf | grep -w nameserver | grep -v "^#"')

    if OsName.lower() == "ubuntu":
        checkNetworkEntry = runOnShell('cat /etc/network/interfaces | grep -w dns-nameservers | grep -v "^#"')

    if checkEntry or checkNetworkEntry:
        logging('Please review DNS entry on the system and ensure that it is legitimate.')
        return None
    logging('The DNS entry for the system does not exist.')
    return True

def fixRule56061():
    logging('Please review DNS entry on the system and ensure that it is legitimate.')
    return None

def checkRule56062():
	if not CheckPackage ("rsyslog"):
		logging("rsyslog is not installed on system. Please remediate rule V-56063 to get rsyslog package installed.")
		return None
	if not checkServiceRunlevel("rsyslog"):
		return False
	return True

def fixRule56062():
	if not CheckPackage ("rsyslog"):
		logging("rsyslog is not installed on system. Please remediate rule V-56063 to get the rsyslog package installed.")
		return None
        RunService("rsyslog",False)

def checkRule56063():
	if CheckPackage("rsyslog"):
		return True
	else:
		return False

def fixRule56063():
	logging("Installing rsyslog service on the system.")
	if not InstallPackage("rsyslog"):
		logging("Something went wrong while installing rsyslog. Please fix this manually.")
		return None

def checkRule56064():
    if checkSSHDSyntax() == None:
        return None

    logging ("Checking if X11 forwarding is disabled.")
    x11Frwd = runOnShell('grep -iw "X11Forwarding" /etc/ssh/sshd_config | grep -v "^#"').splitlines()
    flag = False
    for x11Value in x11Frwd:
        x11Value = x11Value.translate(string.maketrans("\n\t\r", "   "))
        x11Value = re.sub(' +', ' ', x11Value)
        if tokenMatchIC("X11Forwarding yes", x11Value):
            logging("X11Forwarding is enabled.")
            return False
        if tokenMatchIC("X11Forwarding no", x11Value):
            flag = True

    if flag:
        logging("X11Forwarding is not enabled.")
        return True
    logging("X11Forwading is not configured.")
    return False

def fixRule56064():
    fileString = ''
    x11DisableValue = "X11Forwarding no\n"
    x11EnableValue = "#X11Forwarding yes\n"
    flag = False
    enableFlag = False
    lastLine = ""
#   Coverting the lines in file to list.
    openFileData = open("/etc/ssh/sshd_config").readlines()
    for value in openFileData:
#       Commenting the line if X11Forwarding yes found in list.
        if value.startswith("X11Forwarding yes"):
            if not enableFlag:
                if not tokenMatch('Cloud Raxak updated next line',lastLine):
                    fileString += "# Cloud Raxak updated next line\n"
                fileString += x11EnableValue
                enableFlag = True
        elif value.startswith("X11Forwarding"):
            if not flag:
                logging ("Disabling the X11 forwarding.")
                if not tokenMatch('Cloud Raxak updated next line',lastLine):
                    fileString += "# Cloud Raxak updated next line\n"
                fileString += x11DisableValue
                flag = True
        else:
            fileString += value
            lastLine = value

#   Appending if no value is set for X11Forwarding.
    if not flag:
        logging ("Disabling the X11 forwarding.")
        fileString += "\n# Cloud Raxak updated next line\n"
        fileString += x11DisableValue

    fout = None
    fout = open("/etc/ssh/sshd_config", 'wt')
    if fout != None:
        fout.write(fileString)
        fout.close()

#   Changes made will only be valid after sshd restart.
    RunService("ssh")


def checkRule56065():
	""""Checking the installation of anacron package."""
	logging("As Anacron is run by crond hence checking if crond service is installed.")
	if not CheckService("crond"):
		return False
	logging("Checking if anacrontab package is installed.")
	if OsName.lower() == "ubuntu":
		anacron_pkg = runOnShell("dpkg -s anacron")
	else: 
		anacron_pkg = runOnShell("rpm -qa cronie-anacron")

	if ("is not installed" in anacron_pkg) or ("deinstall" in anacron_pkg) or anacron_pkg == "":
	    logging("crond service is enabled but anacrontab package does not exist.")
	    return False
		
	logging("anacrontab package is installed on the system.")
	return True

def fixRule56065():
	if OsName.lower() == "ubuntu":
		if not os.path.exists('/usr/sbin/cron'):
			logging("Installing the crond service.")
		if "dpkg was interrupted" in runOnShell('apt-get -y install cron', False):
			logging("dpkg is not properly configured, it needs to be configured properly using \
command 'dpkg --configure -a'. Please fix this manually.")
			return None
		if not os.path.exists('/usr/sbin/anacron'):
			logging("Installing the anacron service.")
		if "dpkg was interrupted" in runOnShell('apt-get -y install anacron', False):
			logging("dpkg is not properly configured, it needs to be configured properly using \
command 'dpkg --configure -a'. Please fix this manually.")
			return None
		logging("Enabling the crond service on the system boot and runtime configuration.")
		runOnShell("service cron start ; sysv-rc-conf --level 0123456 cron on")
	else:
		if os.path.exists('/usr/sbin/crond'):
			if not os.path.exists('/etc/anacrontab'):
				logging("crond service is installed in the system but anacrontab file does not exist , hence installing the crond service.")
				runOnShell('yum -y remove cronie cronie-anacron',False)
				runOnShell('yum -y install cronie cronie-anacron',False)
		else:
			logging("Installing the crond service.")
			runOnShell('yum -y install cronie cronie-anacron',False)
	
		logging("Enabling the crond service on the system boot and runtime configuration.")
		if ((OsVersion >= (7,0)) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
			runOnShell("systemctl enable crond.service;systemctl start crond.service")
		else:
			runOnShell("service crond start ; chkconfig --level 0123456 crond on")


def checkRule56066():
    ''' This rule is checking DHCP server packages and uninstalling them if exist.'''
    if OsName.lower() == "ubuntu":
        logging("Checking for the DHCP server package(s) in the system.")
        checkDHCP = runOnShell("dpkg --list | grep -i dhcp | grep -i server | cut -d' ' -f3")
        if checkDHCP != "":
            logging("The DHCP server package(s) exist in the system.")
            return False
    else:
        if CheckPackage("dhcp") or CheckPackage("dnsmasq"):
            return False
    logging("DHCP server package(s) does not exist.")
    return True

def fixRule56066():
    if OsName.lower() == "ubuntu":
        checkDHCP = runOnShell("dpkg --list | grep -i dhcp | grep -i server | cut -d' ' -f3")
        if checkDHCP:
            splitData = checkDHCP.splitlines()
            logging("Uninstalling DHCP server from the system.")
            for package in splitData:
                removePackage = runOnShell('DEBIAN_FRONTEND=noninteractive apt-get -y purge '+ package, False)
                if "dpkg was interrupted" in removePackage:
                    logging("dpkg is not properly configured, it needs to be configured properly using command 'dpkg --configure -a'. Please fix this manually.")
                    return None
    else:
        logging("Uninstalling DHCP Server from the system.")
	if CheckPackage("dhcp"):
            runOnShell('rpm -e dhcp --nodeps')
        if CheckPackage("dnsmasq"):
            runOnShell('rpm -e dnsmasq --nodeps')

def checkRule56067():
	'''This rule intends to reject the ICMP redirects from outside'''

	logging("Checking if system is using IPv6.")
	res_enable = runOnShell('ip -6 addr show')
	flag_ipv6 = True
	if res_enable != "":
	    flag_ipv6 = False
	    logging("Checking if IPv6 kernel module is in use.")
	    if (( OsVersion >= (7,0) ) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		check_connection = runOnShell("ss -6taupn | grep ESTAB")
	    else:
		check_connection = runOnShell("netstat -tauplnA inet6 | grep ESTABLISHED")
	    if check_connection != "":
		logging("The system uses IPv6, so the rule is not applicable.")
		return None

	#Checking the parameter runtime. 
        accept_redirect_val = runOnShell("sysctl -a | grep net.ipv6.conf.all.accept_redirects")
	try:
		setting = accept_redirect_val.split()[2]
	except IndexError:
                logging("System is not configured to reject ICMP redirects.")
                return False
        if atoi(setting) != 0:
		logging("Accepting ICMP redirects has few legitimate uses. It should be disabled unless system is a Network Device.")
                return False

	#Checking the parameter from sysctl.conf file. 
	logging("Loading the setting defined during boot time to verify the ICMP redirects acceptance after system reboot.") 
        reboot_value = runOnShell("grep -w net.ipv6.conf.all.accept_redirects /etc/sysctl.conf | grep -v '^#'")
        reboot_value = reboot_value.translate(string.maketrans("\n\t\r", "   "))
	if reboot_value == "":
		logging("ICMP redirects rejection setting is not configured.") 
                return False
		
	if keyValEqMatch_new("net.ipv6.conf.all.accept_redirects","0",reboot_value):
		logging("ICMP redirects rejection setting is configured correctly.")
		return True
	else:
		logging("ICMP redirects rejection setting is not configured correctly.")
		return False

def fixRule56067():
	logging("Disabling the IPv6 Redirect Acceptance")
	runOnShell("sysctl -w net.ipv6.conf.all.accept_redirects=0")
        with open("/etc/sysctl.conf", "r") as file_read:
            ipv6_conf_default = False
            file_string = ""
            lastLine = ""
            for line in file_read:
                if isL(line) and "net.ipv6.conf.all.accept_redirects" in line:
                    if not tokenMatch('Cloud Raxak updated next line',lastLine):
                        file_string += "# Cloud Raxak updated next line\n"
                    file_string += "net.ipv6.conf.all.accept_redirects = 0\n"
                    ipv6_conf_default = True
                else:
                    file_string += line
                    lastLine = line

            if not(ipv6_conf_default):
                if not tokenMatch('Cloud Raxak updated next line',lastLine):
                	file_string += "# Cloud Raxak updated next line\n"
                file_string += "net.ipv6.conf.all.accept_redirects = 0\n"

	fout = None
	fout = open("/etc/sysctl.conf", 'wt')
	if fout != None:
		fout.write(file_string)
		fout.close()
	

def checkRule56068():
	logging("Checking if system using IPv6.")
	res_enable = runOnShell('ip -6 addr show')
	flag_ipv6 = True
	if res_enable != "":
	    flag_ipv6 = False
	    logging("Checking if IPv6 kernel module is in use.")
	    if (( OsVersion >= (7,0) ) and (OsName.lower() == 'centos' or OsName.lower() == 'redhat')):
		check_connection = runOnShell("ss -6taupn | grep ESTAB")
	    else:
		check_connection = runOnShell("netstat -tauplnA inet6 | grep ESTABLISHED")
	    if check_connection != "":
		logging("The system uses IPv6, so the rule is not applicable.")
		return None

	success_count = 0
	logging("Checking if IPv6 Router Advertisements is disabled.")
	for parameter in ['net.ipv6.conf.default.accept_ra','net.ipv6.conf.all.accept_ra']:
		accept_ra_val = runOnShell("sysctl -a | grep '" + parameter +" = 0'")
		try:
			setting = accept_ra_val.split()[2]
		except IndexError:
		        logging("System is not configured to reject IPv6 Router Advertisements.")
		        return False
		if atoi(setting) != 0:
			logging("IPv6 Router Advertisements setting is not configured.") 
		        return False
		
		logging("Loading the setting defined during boot time to verify the IPv6 Router Advertisements after system reboot.") 
		reboot_value = runOnShell("grep -w '" + parameter + "' /etc/sysctl.conf | grep -v '^#'")
		reboot_value = reboot_value.translate(string.maketrans("\n\t\r", "   "))
		if reboot_value == "":
			logging("IPv6 Router Advertisements setting is not configured.") 
		        return False
			
		if keyValEqMatch_new(parameter,"0",reboot_value):
			logging("IPv6 Router Advertisements is disabled")
			success_count = success_count+1
		else:
			logging("IPv6 Router Advertisements is enabled.")
			return False

	if success_count == 2:
		return True
		
def fixRule56068():
	logging("Disabling the IPv6 Router Advertisements")
	runOnShell("sysctl -w net.ipv6.conf.default.accept_ra=0")
	runOnShell("sysctl -w net.ipv6.conf.all.accept_ra=0")
        with open("/etc/sysctl.conf", "r") as file_read:
            ipv6_conf_default_ra = False
            ipv6_conf_all_ra = False
            file_string = ""
            lastLine = ""
            for line in file_read:
                if isL(line) and "net.ipv6.conf.default.accept_ra" in line:
                    if not tokenMatch('Cloud Raxak updated next line',lastLine):
                        file_string += "# Cloud Raxak updated next line\n"
                    file_string += "net.ipv6.conf.default.accept_ra = 0\n"
                    ipv6_conf_default_ra = True
                elif isL(line) and "net.ipv6.conf.all.accept_ra" in line:
                    if not tokenMatch('Cloud Raxak updated next line',lastLine):
                        file_string += "# Cloud Raxak updated next line\n"
                    file_string += "net.ipv6.conf.all.accept_ra = 0\n"
                    ipv6_conf_all_ra = True
                else:
                    file_string += line
                    lastLine = line
            if not(ipv6_conf_default_ra):
                file_string += "# Cloud Raxak updated next line\n"
                file_string += "net.ipv6.conf.default.accept_ra = 0\n"
            if not(ipv6_conf_all_ra):
                file_string += "# Cloud Raxak updated next line\n"
                file_string += "net.ipv6.conf.all.accept_ra = 0\n"
            fout = None
            fout = open("/etc/sysctl.conf", 'wt')
            if fout != None:
            	fout.write(file_string)
            	fout.close()


def checkRule56075():
	if CheckPackage("vsftpd"):
		return False
	else:
		return True

def fixRule56075():
	logging("Uninstalling FTP server(vsftpd) daemon from the system..")
	if OsName.lower() == "ubuntu":
		if "dpkg was interrupted" in runOnShell('DEBIAN_FRONTEND=noninteractive apt-get -y remove vsftpd', False):
			logging("dpkg is not properly configured, it needs to be configured properly using command 'dpkg --configure -a'. Please fix this manually.")
			return None
	else:
		runOnShell('rpm -e vsftpd --nodeps')

def checkRule56076():
        # The package "samba" is exactly the same across linux distros: Redhat,Centos 6.X and 7.0, Ubuntu 14.04
	if CheckPackage("samba"):
		return False
	else:
		return True

def fixRule56076():
	logging("Uninstalling Samba Server package from the system.")
	if OsName.lower() == "ubuntu":
		if "dpkg was interrupted" in runOnShell('DEBIAN_FRONTEND=noninteractive apt-get -y purge samba', False):
			logging("dpkg is not properly configured, it needs to be configured properly using command 'dpkg --configure -a'. Please fix this manually.")
                        return None
	else:
		runOnShell('rpm -e samba --nodeps')

def checkRule56077():
        # The package "telnet" is exactly the same across linux distros: Redhat,Centos 6.X and 7.0, Ubuntu 14.04
	if CheckPackage("telnet"):
		return False
	else:
		return True

def fixRule56077():
	logging("Uninstalling Telnet package from the system.")
	if OsName.lower() == "ubuntu":
		if "dpkg was interrupted" in runOnShell('DEBIAN_FRONTEND=noninteractive apt-get -y remove telnet', False):
			logging("dpkg is not properly configured, it needs to be configured properly using command 'dpkg --configure -a'. Please fix this manually.")
                        return None
	else:
		runOnShell('rpm -e telnet --nodeps')

def checkRule56078():
        # The package "tftp" is exactly the same across linux distros: Redhat,Centos 6.X and 7.0, Ubuntu 14.04
	if CheckPackage("tftp"):
		return False
	else:
		return True

def fixRule56078():
        logging("Uninstalling TFTP package from the system.")
	if OsName.lower() == "ubuntu":
		# DEBIAN_FRONTEND=noninteractive is used to suppress the debconf errors that appear in the console log.
		if "dpkg was interrupted" in runOnShell('DEBIAN_FRONTEND=noninteractive apt-get -y remove tftp', False):
			logging("dpkg is not properly configured, it needs to be configured properly using command 'dpkg --configure -a'. Please fix this manually.")
                        return None
	else:
		runOnShell('rpm -e tftp --nodeps')

def checkRule56054():
	logging("Checking if there is wireless interface(s).")
	if runOnShell("cat /proc/net/wireless |sed '1,2d'|cut -d: -f1 |tr -d ' '") != "":
		logging("Please fix it manually if ineterface is up.")
		return None

	logging("There is not any wireless interface.")
	return True


def fixRule56054():
	return None



#####################################################

#----------------- end of module ruleset


if __name__ == '__channelexec__':
	runlocal = False
	outchan = channel.gateway.newchannel()
	sys.stdout = outchan.makefile("w")
	channel.send(outchan)
	consoleChan = channel.gateway.newchannel()
	channel.send(consoleChan)
	while not channel.isclosed():
		rule = channel.receive()


                if rule[0] == "C":
                    logging("C command " + str(rule[1:]))
                    methodName = 'checkRule' + str(rule[1:])
                else:
                    methodName = 'fixRule' + str(rule[1:]) 
                possibles = globals().copy()
                possibles.update(locals())
		try:
			method = possibles.get(methodName)
			retval = method()
    		except:
    			logging ("Method not found")
			retval = None
		
		channel.send(retval)
